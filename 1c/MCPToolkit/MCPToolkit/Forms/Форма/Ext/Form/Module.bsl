// ═══════════════════════════════════════════════════════════════════════════════
// Модуль формы внешней обработки MCPToolkitКлиент
// Клиент для подключения к MCP прокси-серверу
// Совместимость: 1С:Предприятие 8.2.13+ / 8.3.25
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ПЕРЕМЕННЫЕ МОДУЛЯ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Перем ФлагПодключения;

&НаКлиенте
Перем ИнтервалОпроса;

&НаКлиенте
Перем МаксимальноеКоличествоПопытокПереподключения;

&НаКлиенте
Перем ТекущееКоличествоПопытокПереподключения;

&НаКлиенте
Перем КэшТокеновМетаданныхРасширений;

// ─────────────────────────────────────────────────────────────────────────────────
// ОБРАБОТЧИКИ СОБЫТИЙ ФОРМЫ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	// Загрузка сохранённого адреса сервера
	ЗагрузитьНастройки();
	
	// Установка начального статуса
	Статус = "Отключено";
	Подключено = Ложь;
	
	// Значение по умолчанию для адреса сервера
	Если ПустаяСтрока(АдресСервера) Тогда
		АдресСервера = "http://localhost:6003";
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)
	
	// Инициализация переменных
	ФлагПодключения = Ложь;
	ИнтервалОпроса = 1; // секунды
	МаксимальноеКоличествоПопытокПереподключения = 5;
	ТекущееКоличествоПопытокПереподключения = 0;
	
	// Клиентский кэш токенов для расширений (адреса ВременногоХранилища)
	КэшТокеновМетаданныхРасширений = Новый Соответствие;
	
КонецПроцедуры

&НаКлиенте
Процедура ПриЗакрытии(Отказ)
	
	// Отключение при закрытии формы
	Если ФлагПодключения Тогда
		ОтключитьсяОтСервера();
	КонецЕсли;
	
КонецПроцедуры


// ─────────────────────────────────────────────────────────────────────────────────
// КОМАНДЫ ФОРМЫ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура Подключиться(Команда)
	
	Если ПустаяСтрока(АдресСервера) Тогда
		ПоказатьПредупреждение(, "Укажите адрес сервера");
		Возврат;
	КонецЕсли;
	
	// Сохранение адреса сервера
	СохранитьНастройкиНаСервере(АдресСервера);
	
	// Инициализация переменных если не были инициализированы
	Если ИнтервалОпроса = Неопределено Тогда
		ИнтервалОпроса = 1;
	КонецЕсли;
	
	// Запуск подключения
	ФлагПодключения = Истина;
	ТекущееКоличествоПопытокПереподключения = 0;
	
	УстановитьСтатус("Подключение...", Ложь);
	ДобавитьВЛог("Подключение к серверу: " + АдресСервера);
	
	// Запуск цикла опроса
	ПодключитьОбработчикОжидания("ЦиклОпроса", 1, Ложь);
	
КонецПроцедуры

&НаКлиенте
Процедура Отключиться(Команда)
	
	ОтключитьсяОтСервера();
	
КонецПроцедуры

&НаКлиенте
Процедура ОчиститьЖурнал(Команда)
	
	Лог = "";
	
КонецПроцедуры

&НаКлиенте
Процедура ОтключитьсяОтСервера()
	
	ФлагПодключения = Ложь;
	
	Попытка
		ОтключитьОбработчикОжидания("ЦиклОпроса");
	Исключение
		// Обработчик уже отключен
	КонецПопытки;
	
	УстановитьСтатус("Отключено", Ложь);
	ДобавитьВЛог("Отключено от сервера");
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ЦИКЛ ОПРОСА (LONG POLLING)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ЦиклОпроса()
	
	Если Не ФлагПодключения Тогда
		Возврат;
	КонецЕсли;
	
	// Получение команды с сервера
	РезультатЗапроса = ПолучитьКомандуССервера(АдресСервера);
	
	Если РезультатЗапроса.Успех Тогда
		
		// Сброс счётчика попыток при успешном подключении
		ТекущееКоличествоПопытокПереподключения = 0;
		
		Если Не Подключено Тогда
			УстановитьСтатус("Подключено", Истина);
			ДобавитьВЛог("Успешное подключение к серверу");
		КонецЕсли;
		
		Если РезультатЗапроса.ЕстьКоманда Тогда
			// Выполнение команды
			ОбработатьКоманду(РезультатЗапроса.Команда);
		КонецЕсли;
		
	Иначе
		// Ошибка подключения
		ОбработатьОшибкуПодключения(РезультатЗапроса.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры


&НаКлиенте
Процедура ОбработатьОшибкуПодключения(ОписаниеОшибки)
	
	// Инициализация если не были инициализированы
	Если ТекущееКоличествоПопытокПереподключения = Неопределено Тогда
		ТекущееКоличествоПопытокПереподключения = 0;
	КонецЕсли;
	Если МаксимальноеКоличествоПопытокПереподключения = Неопределено Тогда
		МаксимальноеКоличествоПопытокПереподключения = 5;
	КонецЕсли;
	
	ТекущееКоличествоПопытокПереподключения = ТекущееКоличествоПопытокПереподключения + 1;
	
	Если ТекущееКоличествоПопытокПереподключения >= МаксимальноеКоличествоПопытокПереподключения Тогда
		// Превышено количество попыток переподключения
		УстановитьСтатус("Ошибка: " + ОписаниеОшибки, Ложь);
		ДобавитьВЛог("Ошибка подключения: " + ОписаниеОшибки + ". Превышено количество попыток.");
		ОтключитьсяОтСервера();
	Иначе
		// Попытка переподключения
		УстановитьСтатус("Переподключение (" + ТекущееКоличествоПопытокПереподключения + "/" + МаксимальноеКоличествоПопытокПереподключения + ")...", Ложь);
		ДобавитьВЛог("Ошибка подключения: " + ОписаниеОшибки + ". Попытка переподключения...");
	КонецЕсли;
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// КЭШ ДЛЯ МЕТАДАННЫХ РАСШИРЕНИЙ (клиент хранит токены, сервер хранит данные во ВременномХранилище)
// Внешний API не меняется: токены не уходят наружу (в ОтправитьРезультатНаСервер есть whitelist полей).
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция ПолучитьКэшТокеновМетаданныхРасширений()
	Если КэшТокеновМетаданныхРасширений = Неопределено Тогда
		КэшТокеновМетаданныхРасширений = Новый Соответствие;
	КонецЕсли;
	Возврат КэшТокеновМетаданныхРасширений;
КонецФункции

&НаКлиенте
Функция СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции)
	Ключ = ?(Фильтр = Неопределено, "", Строка(Фильтр));
	
	Если Секции = Неопределено Тогда
		Возврат Ключ;
	КонецЕсли;
	
	Попытка
		Если ТипЗнч(Секции) = Тип("Массив") Тогда
			СтрСекции = "";
			Для Каждого Секция Из Секции Цикл
				Секция = СокрЛП(Строка(Секция));
				Если ПустаяСтрока(Секция) Тогда
					Продолжить;
				КонецЕсли;
				СтрСекции = СтрСекции + ?(ПустаяСтрока(СтрСекции), "", ",") + Секция;
			КонецЦикла;
			Если НЕ ПустаяСтрока(СтрСекции) Тогда
				Ключ = Ключ + "|" + СтрСекции;
			КонецЕсли;
		Иначе
			Ключ = Ключ + "|" + Строка(Секции);
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Возврат Ключ;
КонецФункции

&НаКлиенте
Функция ВыполнитьКомандуНаСервереСКэшированием(Команда)
	ИмяИнструмента = "";
	Попытка
		ИмяИнструмента = СокрЛП(Команда.tool);
	Исключение
		ИмяИнструмента = "";
	КонецПопытки;
	
	// Важно: Команда может быть фиксированной структурой (read-only), поэтому НЕ модифицируем ее.
	// Всегда работаем с копией params в обычной Структуре.
	ПараметрыИсходные = Неопределено;
	Если Команда.Свойство("params") Тогда
		ПараметрыИсходные = Команда.params;
	КонецЕсли;
	
	// ВАЖНО: имя "Параметры" в модуле формы может конфликтовать с одноименным
	// системным/форменным свойством (read-only). Используем уникальное имя.
	ПараметрыКоманды = Новый Структура;
	Если ПараметрыИсходные <> Неопределено Тогда
		Попытка
			Для Каждого Пара Из ПараметрыИсходные Цикл
				ПараметрыКоманды.Вставить(Пара.Ключ, Пара.Значение);
			КонецЦикла;
		Исключение
			// Если params не коллекция/не итерируется - оставляем пустыми
		КонецПопытки;
	КонецЕсли;
	
	ИмяРасширения = Неопределено;
	Фильтр = "";
	Секции = Неопределено;
	
	Если ИмяИнструмента = "get_metadata" И ПараметрыКоманды <> Неопределено Тогда
		Если ПараметрыКоманды.Свойство("extension_name") Тогда
			ИмяРасширения = ПараметрыКоманды.extension_name;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("filter") Тогда
			Фильтр = ПараметрыКоманды.filter;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("sections") Тогда
			Секции = ПараметрыКоманды.sections;
		КонецЕсли;
	КонецЕсли;
	
	КлючДеталей = "";
	
	// Добавляем токены кэша только для режима "объекты расширения" (extension_name="Имя")
	Если ИмяИнструмента = "get_metadata"
		И ИмяРасширения <> Неопределено
		И ТипЗнч(ИмяРасширения) = Тип("Строка")
		И НЕ ПустаяСтрока(ИмяРасширения) Тогда
		
		Кэш = ПолучитьКэшТокеновМетаданныхРасширений();
		Запись = Кэш.Получить(ИмяРасширения);
		
		Если Запись = Неопределено Тогда
			Запись = Новый Структура(
				"hash, data_token, index_token, details, details_order",
				"",
				Неопределено,
				Неопределено,
				Новый Соответствие,
				Новый Массив
			);
			Кэш.Вставить(ИмяРасширения, Запись);
		КонецЕсли;
		
		Если Запись.hash <> "" Тогда
			ПараметрыКоманды.Вставить("mcp_cache_hash", Запись.hash);
		КонецЕсли;
		Если Запись.data_token <> Неопределено Тогда
			ПараметрыКоманды.Вставить("mcp_cache_data_token", Запись.data_token);
		КонецЕсли;
		Если Запись.index_token <> Неопределено Тогда
			ПараметрыКоманды.Вставить("mcp_cache_index_token", Запись.index_token);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(Фильтр) Тогда
			КлючДеталей = СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции);
			ТокенДеталей = Запись.details.Получить(КлючДеталей);
			Если ТокенДеталей <> Неопределено Тогда
				ПараметрыКоманды.Вставить("mcp_cache_details_token", ТокенДеталей);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Передаем на сервер копию команды с измененными params (если добавили токены кэша)
	КомандаНаСервер = Новый Структура;
	Попытка
		Если Команда.Свойство("id") Тогда
			КомандаНаСервер.Вставить("id", Команда.id);
		КонецЕсли;
	Исключение
	КонецПопытки;
	КомандаНаСервер.Вставить("tool", ИмяИнструмента);
	КомандаНаСервер.Вставить("params", ПараметрыКоманды);
	
	Результат = ВыполнитьКомандуНаСервере(КомандаНаСервер);
	
	// Обновляем кэш по внутренним полям результата (они не уходят наружу из-за whitelist)
	Если ИмяИнструмента = "get_metadata"
		И ИмяРасширения <> Неопределено
		И ТипЗнч(ИмяРасширения) = Тип("Строка")
		И НЕ ПустаяСтрока(ИмяРасширения) Тогда
		
		Попытка
			Если Результат <> Неопределено
				И ТипЗнч(Результат) = Тип("Структура") Тогда
				
				Кэш = ПолучитьКэшТокеновМетаданныхРасширений();
				Запись = Кэш.Получить(ИмяРасширения);
				Если Запись = Неопределено Тогда
					Запись = Новый Структура(
						"hash, data_token, index_token, details, details_order",
						"",
						Неопределено,
						Неопределено,
						Новый Соответствие,
						Новый Массив
					);
				КонецЕсли;
				
				НовХеш = "";
				Если Результат.Свойство("mcp_cache_hash") Тогда
					НовХеш = Строка(Результат.mcp_cache_hash);
				КонецЕсли;
				
				Если НЕ ПустаяСтрока(НовХеш) И Запись.hash <> "" И Запись.hash <> НовХеш Тогда
					Запись.hash = НовХеш;
					Запись.data_token = Неопределено;
					Запись.index_token = Неопределено;
					Запись.details = Новый Соответствие;
					Запись.details_order = Новый Массив;
				ИначеЕсли НЕ ПустаяСтрока(НовХеш) Тогда
					Запись.hash = НовХеш;
				КонецЕсли;
				
				Если Результат.Свойство("mcp_cache_data_token") Тогда
					Запись.data_token = Результат.mcp_cache_data_token;
				КонецЕсли;
				Если Результат.Свойство("mcp_cache_index_token") Тогда
					Запись.index_token = Результат.mcp_cache_index_token;
				КонецЕсли;
				
				Если Результат.Свойство("mcp_cache_details_token") И НЕ ПустаяСтрока(Фильтр) Тогда
					Если ПустаяСтрока(КлючДеталей) Тогда
						КлючДеталей = СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции);
					КонецЕсли;
					ТокенДеталей = Результат.mcp_cache_details_token;
					Если ТокенДеталей <> Неопределено Тогда
						Запись.details.Вставить(КлючДеталей, ТокенДеталей);
						Запись.details_order.Добавить(КлючДеталей);
						
						// Ограничиваем размер кэша деталей, чтобы не раздувать память/ВременноеХранилище бесконечно
						МаксДеталей = 50;
						Если Запись.details_order.Количество() > МаксДеталей Тогда
							СтарыйКлюч = Запись.details_order[0];
							Запись.details_order.Удалить(0);
							Попытка
								Запись.details.Удалить(СтарыйКлюч);
							Исключение
							КонецПопытки;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Кэш.Вставить(ИмяРасширения, Запись);
				
				// Не светим токены в текстовых логах формы
				Если Результат.Свойство("mcp_cache_hash") Тогда Результат.Удалить("mcp_cache_hash"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_data_token") Тогда Результат.Удалить("mcp_cache_data_token"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_index_token") Тогда Результат.Удалить("mcp_cache_index_token"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_details_token") Тогда Результат.Удалить("mcp_cache_details_token"); КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ОбработатьКоманду(Команда)
	
	// Формируем информативное сообщение о команде
	ТекстКоманды = ПолучитьТекстКоманды(Команда);
	ДобавитьВЛог("Получена команда: " + Команда.tool + Символы.ПС + ТекстКоманды);
	
	// Проверка необходимости подтверждения опасной операции
	Если Команда.Свойство("params") И Команда.params <> Неопределено Тогда
		ПараметрыКоманды = Команда.params;
		
		Если ПараметрыКоманды.Свойство("requires_approval") И ПараметрыКоманды.requires_approval = Истина Тогда
			
			// Получение массива опасных ключевых слов
			МассивОпасныхСлов = Новый Массив;
			ОпасныеСлова = "";
			Если ПараметрыКоманды.Свойство("dangerous_keywords") Тогда
				Для Каждого Слово Из ПараметрыКоманды.dangerous_keywords Цикл
					МассивОпасныхСлов.Добавить(Слово);
					ОпасныеСлова = ОпасныеСлова + ?(ПустаяСтрока(ОпасныеСлова), "", ", ") + Слово;
				КонецЦикла;
			КонецЕсли;
			
 			// Проверка автоматического разрешения
 			Если ВсеОперацииАвтоРазрешены(МассивОпасныхСлов) Тогда
 				ДобавитьВЛог("Операции автоматически разрешены: " + ОпасныеСлова);
				Попытка
					Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
				Исключение
					ТекстОшибки = ОписаниеОшибки();
					ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
					Результат = Новый Структура(
						"success, error",
						Ложь,
						"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
						+ " / Error executing command in 1C server: " + ТекстОшибки
					);
				КонецПопытки;
 				РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
 				
 				Если РезультатОтправки.Успех Тогда
 					ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
				Иначе
					ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
				КонецЕсли;
				
				Возврат;
			КонецЕсли;
			
			// Получение кода
			Код = "";
			Если ПараметрыКоманды.Свойство("code") Тогда
				Код = ПараметрыКоманды.code;
			КонецЕсли;
			
			ДобавитьВЛог("Требуется подтверждение пользователя. Опасные слова: " + ОпасныеСлова);
			
			// Показ формы подтверждения
			ПараметрыФормы = Новый Структура;
			ПараметрыФормы.Вставить("ОпасныеСлова", ОпасныеСлова);
			ПараметрыФормы.Вставить("Код", Код);
			
			ОписаниеОповещения = Новый ОписаниеОповещения(
				"ОбработатьРезультатПодтверждения", 
				ЭтаФорма, 
				Новый Структура("Команда", Команда)
			);
			
			ОткрытьФорму(
				"ВнешняяОбработка.MCPToolkitКлиент.Форма.ФормаПодтверждения",
				ПараметрыФормы,
				ЭтаФорма,
				,
				,
				,
				ОписаниеОповещения,
				РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс
			);
			
			Возврат;
		КонецЕсли;
 	КонецЕсли;
 	
 	// Обычное выполнение без подтверждения
	Попытка
		Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
		Результат = Новый Структура(
			"success, error",
			Ложь,
			"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
			+ " / Error executing command in 1C server: " + ТекстОшибки
		);
	КонецПопытки;
 	
 	// Отправка результата на сервер
 	РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
	
	Если РезультатОтправки.Успех Тогда
		ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
	Иначе
		ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьРезультатПодтверждения(Разрешено, ДополнительныеПараметры) Экспорт
	
	Команда = ДополнительныеПараметры.Команда;
	
 	Если Разрешено = Истина Тогда
 		ДобавитьВЛог("Пользователь разрешил выполнение опасной операции");
		Попытка
			Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
		Исключение
			ТекстОшибки = ОписаниеОшибки();
			ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
			Результат = Новый Структура(
				"success, error",
				Ложь,
				"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
				+ " / Error executing command in 1C server: " + ТекстОшибки
			);
		КонецПопытки;
 	Иначе
 		ДобавитьВЛог("Пользователь отклонил выполнение опасной операции");
		
		// Формирование списка опасных слов для сообщения
		ОпасныеСлова = "";
		Если Команда.Свойство("params") И Команда.params <> Неопределено Тогда
			ПараметрыКоманды = Команда.params;
			Если ПараметрыКоманды.Свойство("dangerous_keywords") Тогда
				Для Каждого Слово Из ПараметрыКоманды.dangerous_keywords Цикл
					ОпасныеСлова = ОпасныеСлова + ?(ПустаяСтрока(ОпасныеСлова), "", ", ") + Слово;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Результат = Новый Структура("success, error", Ложь, 
			"Операция отклонена пользователем. Код содержит опасные ключевые слова: " + ОпасныеСлова + 
			" / Operation rejected by user. Code contains dangerous keywords: " + ОпасныеСлова);
	КонецЕсли;
	
	// Отправка результата на сервер
	РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
	
	Если РезультатОтправки.Успех Тогда
		ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
	Иначе
		ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ВсеОперацииАвтоРазрешены(МассивОпасныхСлов)
	
	// Соответствие ключевых слов и флагов автоматического разрешения
	СоответствиеФлагов = Новый Соответствие;
	СоответствиеФлагов.Вставить("ЗАПИСАТЬ", АвтоРазрешитьЗаписать);
	СоответствиеФлагов.Вставить("WRITE", АвтоРазрешитьЗаписать);
	СоответствиеФлагов.Вставить("УСТАНОВИТЬПРИВИЛЕГИРОВАННЫЙРЕЖИМ", АвтоРазрешитьПривилегированныйРежим);
	СоответствиеФлагов.Вставить("SETPRIVILEGEDMODE", АвтоРазрешитьПривилегированныйРежим);
	
	// Проверка каждого опасного слова
	Для Каждого Слово Из МассивОпасныхСлов Цикл
		СловоВерхнийРегистр = ВРег(Слово);
		ФлагРазрешения = СоответствиеФлагов.Получить(СловоВерхнийРегистр);
		
		Если ФлагРазрешения = Неопределено Или ФлагРазрешения = Ложь Тогда
			Возврат Ложь; // Есть неразрешённая операция
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина; // Все операции автоматически разрешены
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстКоманды(Команда)
	
	ТекстКоманды = "";
	Отступ = "    "; // 4 пробела
	
	Если Не Команда.Свойство("params") Или Команда.params = Неопределено Тогда
		Возврат Отступ + "(без параметров)";
	КонецЕсли;
	
	ПараметрыКоманды = Команда.params;
	
	Если Команда.tool = "execute_query" Тогда
		Если ПараметрыКоманды.Свойство("query") Тогда
			ТекстКоманды = ПараметрыКоманды.query;
		КонецЕсли;
	ИначеЕсли Команда.tool = "execute_code" Тогда
		Если ПараметрыКоманды.Свойство("code") Тогда
			ТекстКоманды = ПараметрыКоманды.code;
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_metadata" Тогда
		Если ПараметрыКоманды.Свойство("filter") И Не ПустаяСтрока(ПараметрыКоманды.filter) Тогда
			ТекстКоманды = "фильтр: " + ПараметрыКоманды.filter;
		Иначе
			ТекстКоманды = "(все метаданные)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_event_log" Тогда
		ЧастиТекста = Новый Массив;
		Если ПараметрыКоманды.Свойство("start_date") И ЗначениеЗаполнено(ПараметрыКоманды.start_date) Тогда
			ЧастиТекста.Добавить("с " + ПараметрыКоманды.start_date);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("end_date") И ЗначениеЗаполнено(ПараметрыКоманды.end_date) Тогда
			ЧастиТекста.Добавить("по " + ПараметрыКоманды.end_date);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("levels") И ПараметрыКоманды.levels <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.levels) И ПараметрыКоманды.levels.Количество() > 0 Тогда
			ЧастиТекста.Добавить("уровни: " + СоединитьМассив(ПараметрыКоманды.levels, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("limit") И ЗначениеЗаполнено(ПараметрыКоманды.limit) Тогда
			ЧастиТекста.Добавить("лимит: " + ПараметрыКоманды.limit);
		КонецЕсли;
		// Фильтры по объекту (приоритет: object_description > link > data)
		Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.object_description.Свойство("Представление") Тогда
					ЧастиТекста.Добавить("объект: " + ПараметрыКоманды.object_description.Представление);
				ИначеЕсли ПараметрыКоманды.object_description.Свойство("ТипОбъекта") Тогда
					ЧастиТекста.Добавить("объект (тип): " + ПараметрыКоманды.object_description.ТипОбъекта);
				Иначе
					ЧастиТекста.Добавить("объект: (описание объекта)");
				КонецЕсли;
			Иначе
				ЧастиТекста.Добавить("объект: (некорректное описание)");
			КонецЕсли;
		ИначеЕсли ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
			ЧастиТекста.Добавить("ссылка: " + ПараметрыКоманды.link);
		ИначеЕсли ПараметрыКоманды.Свойство("data") И ЗначениеЗаполнено(ПараметрыКоманды.data) Тогда
			ЧастиТекста.Добавить("данные: " + ПараметрыКоманды.data);
		КонецЕсли;
		// Остальные фильтры
		Если ПараметрыКоманды.Свойство("metadata_type") И ПараметрыКоманды.metadata_type <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.metadata_type) И ПараметрыКоманды.metadata_type.Количество() > 0 Тогда
			ЧастиТекста.Добавить("метаданные: " + СоединитьМассив(ПараметрыКоманды.metadata_type, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("user") И ПараметрыКоманды.user <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.user) И ПараметрыКоманды.user.Количество() > 0 Тогда
			ЧастиТекста.Добавить("пользователи: " + СоединитьМассив(ПараметрыКоманды.user, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("session") И ПараметрыКоманды.session <> Неопределено Тогда
			Если ЭтоКоллекция(ПараметрыКоманды.session) И ПараметрыКоманды.session.Количество() > 0 Тогда
				МассивСеансов = Новый Массив;
				Для Каждого Сеанс Из ПараметрыКоманды.session Цикл
					МассивСеансов.Добавить(Строка(Сеанс));
				КонецЦикла;
				ЧастиТекста.Добавить("сеансы: " + СоединитьМассив(МассивСеансов, ", "));
			ИначеЕсли Не ЭтоКоллекция(ПараметрыКоманды.session) И ЗначениеЗаполнено(ПараметрыКоманды.session) Тогда
				ЧастиТекста.Добавить("сеанс: " + Строка(ПараметрыКоманды.session));
			КонецЕсли;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("application") И ПараметрыКоманды.application <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.application) И ПараметрыКоманды.application.Количество() > 0 Тогда
			ЧастиТекста.Добавить("приложения: " + СоединитьМассив(ПараметрыКоманды.application, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("computer") И ЗначениеЗаполнено(ПараметрыКоманды.computer) Тогда
			ЧастиТекста.Добавить("компьютер: " + ПараметрыКоманды.computer);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("comment_contains") И ЗначениеЗаполнено(ПараметрыКоманды.comment_contains) Тогда
			ЧастиТекста.Добавить("комментарий содержит: " + ПараметрыКоманды.comment_contains);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("transaction_status") И ЗначениеЗаполнено(ПараметрыКоманды.transaction_status) Тогда
			ЧастиТекста.Добавить("статус транзакции: " + ПараметрыКоманды.transaction_status);
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			// Каждый параметр на новой строке с отступом в 4 пробела
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(журнал регистрации)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_object_by_link" Тогда
		Если ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
			ТекстКоманды = "ссылка: " + ПараметрыКоманды.link;
		Иначе
			ТекстКоманды = "(пустая ссылка)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_link_of_object" Тогда
		Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.object_description.Свойство("Представление") Тогда
					ТекстКоманды = "объект: " + ПараметрыКоманды.object_description.Представление;
				ИначеЕсли ПараметрыКоманды.object_description.Свойство("ТипОбъекта") Тогда
					ТекстКоманды = "тип: " + ПараметрыКоманды.object_description.ТипОбъекта;
				Иначе
					ТекстКоманды = "(описание объекта)";
				КонецЕсли;
			Иначе
				ТекстКоманды = "(некорректное описание)";
			КонецЕсли;
		Иначе
			ТекстКоманды = "(пустое описание)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "find_references_to_object" Тогда
		ЧастиТекста = Новый Массив;
		// Целевой объект
		Если ПараметрыКоманды.Свойство("target_object_description") И ПараметрыКоманды.target_object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.target_object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.target_object_description.Свойство("Представление") Тогда
					ЧастиТекста.Добавить("цель: " + ПараметрыКоманды.target_object_description.Представление);
				ИначеЕсли ПараметрыКоманды.target_object_description.Свойство("ТипОбъекта") Тогда
					ЧастиТекста.Добавить("цель (тип): " + ПараметрыКоманды.target_object_description.ТипОбъекта);
				Иначе
					ЧастиТекста.Добавить("цель: (описание объекта)");
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Области поиска
		Если ПараметрыКоманды.Свойство("search_scope") И ПараметрыКоманды.search_scope <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.search_scope) И ПараметрыКоманды.search_scope.Количество() > 0 Тогда
			ЧастиТекста.Добавить("области: " + СоединитьМассив(ПараметрыКоманды.search_scope, ", "));
		КонецЕсли;
		// Фильтр метаданных
		Если ПараметрыКоманды.Свойство("meta_filter") И ПараметрыКоманды.meta_filter <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.meta_filter) = Тип("Структура") Тогда
				Если ПараметрыКоманды.meta_filter.Свойство("names") И ПараметрыКоманды.meta_filter.names <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.meta_filter.names) И ПараметрыКоманды.meta_filter.names.Количество() > 0 Тогда
					ЧастиТекста.Добавить("фильтр имён: " + СоединитьМассив(ПараметрыКоманды.meta_filter.names, ", "));
				ИначеЕсли ПараметрыКоманды.meta_filter.Свойство("name_mask") И ЗначениеЗаполнено(ПараметрыКоманды.meta_filter.name_mask) Тогда
					ЧастиТекста.Добавить("маска: " + ПараметрыКоманды.meta_filter.name_mask);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Лимиты
		Если ПараметрыКоманды.Свойство("limit_hits") И ЗначениеЗаполнено(ПараметрыКоманды.limit_hits) Тогда
			ЧастиТекста.Добавить("лимит: " + ПараметрыКоманды.limit_hits);
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(поиск ссылок на объект)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_access_rights" Тогда
		ЧастиТекста = Новый Массив;
		Если ПараметрыКоманды.Свойство("metadata_object") И ЗначениеЗаполнено(ПараметрыКоманды.metadata_object) Тогда
			ЧастиТекста.Добавить("объект: " + ПараметрыКоманды.metadata_object);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("user_name") И ЗначениеЗаполнено(ПараметрыКоманды.user_name) Тогда
			ЧастиТекста.Добавить("пользователь: " + ПараметрыКоманды.user_name);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("rights_filter") И ПараметрыКоманды.rights_filter <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.rights_filter) И ПараметрыКоманды.rights_filter.Количество() > 0 Тогда
			ЧастиТекста.Добавить("права: " + СоединитьМассив(ПараметрыКоманды.rights_filter, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("roles_filter") И ПараметрыКоманды.roles_filter <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.roles_filter) И ПараметрыКоманды.roles_filter.Количество() > 0 Тогда
			ЧастиТекста.Добавить("роли: " + СоединитьМассив(ПараметрыКоманды.roles_filter, ", "));
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(права доступа)";
		КонецЕсли;
	Иначе
		ТекстКоманды = "(неизвестная команда)";
	КонецЕсли;
	
	// Преобразуем экранированные символы
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\r", "");
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\t", "    ");
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\n", Символы.ПС);
	
	// Добавляем отступ к каждой строке
	ТекстКоманды = Отступ + СтрЗаменить(ТекстКоманды, Символы.ПС, Символы.ПС + Отступ);
	
	Возврат ТекстКоманды;
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстРезультата(Результат)
	
	Отступ = "    "; // 4 пробела
	ТекстРезультата = "";
	
	Если Результат.Свойство("success") И Результат.success = Истина Тогда
		Если Результат.Свойство("data") Тогда
			ТекстРезультата = ЗаписатьJSON2(Результат.data);
		Иначе
			ТекстРезультата = "(нет данных)";
		КонецЕсли;
	Иначе
		Если Результат.Свойство("error") Тогда
			ТекстРезультата = "Ошибка: " + Результат.error;
		Иначе
			ТекстРезультата = "(неизвестная ошибка)";
		КонецЕсли;
	КонецЕсли;
	
	// Преобразуем экранированные символы
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\r", "");
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\t", "    ");
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\n", Символы.ПС);
	
	// Добавляем отступ к каждой строке
	ТекстРезультата = Отступ + СтрЗаменить(ТекстРезультата, Символы.ПС, Символы.ПС + Отступ);
	
	Возврат ТекстРезультата;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// HTTP-ЗАПРОСЫ К СЕРВЕРУ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция СформироватьПутьЗапроса(БазовыйПуть, ПараметрыЗапроса)
	
	// ПараметрыЗапроса - Структура с параметрами
	// Возвращает путь вида "/1c/poll?channel=abc&timeout=30"
	
	Если ПараметрыЗапроса.Количество() = 0 Тогда
		Возврат БазовыйПуть;
	КонецЕсли;
	
	ЧастиПараметров = Новый Массив;
	Для Каждого КлючЗначение Из ПараметрыЗапроса Цикл
		Если Не ПустаяСтрока(КлючЗначение.Значение) Тогда
			ЧастиПараметров.Добавить(КлючЗначение.Ключ + "=" + КлючЗначение.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Если ЧастиПараметров.Количество() = 0 Тогда
		Возврат БазовыйПуть;
	КонецЕсли;
	
	Возврат БазовыйПуть + "?" + СоединитьМассив(ЧастиПараметров, "&");
	
КонецФункции

&НаКлиенте
Функция ПолучитьКомандуССервера(Адрес)
	
	Результат = Новый Структура("Успех, ЕстьКоманда, Команда, ОписаниеОшибки", Ложь, Ложь, Неопределено, "");
	
	Попытка
		
		// Разбор URL
		СтруктураURL = РазобратьURL(Адрес);
		
		// Создание HTTP-соединения
		Если СтруктураURL.Протокол = "https" Тогда
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30, Новый ЗащищенноеСоединениеOpenSSL());
		Иначе
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30);
		КонецЕсли;
		
		// Формирование параметров запроса с channel
		ПараметрыЗапроса = Новый Структура;
		Если Не ПустаяСтрока(ИдентификаторКанала) Тогда
			ПараметрыЗапроса.Вставить("channel", СокрЛП(ИдентификаторКанала));
		КонецЕсли;
		
		ПутьЗапроса = СформироватьПутьЗапроса(СтруктураURL.Путь + "/1c/poll", ПараметрыЗапроса);
		
		// Формирование запроса
		Запрос = Новый HTTPЗапрос(ПутьЗапроса);
		Запрос.Заголовки.Вставить("Accept", "application/json");
		
		// Выполнение запроса
		Ответ = Соединение.Получить(Запрос);
		
		Если Ответ.КодСостояния = 200 Тогда
			// Есть команда
			ТелоОтвета = Ответ.ПолучитьТелоКакСтроку("UTF-8");
			Если Не ПустаяСтрока(ТелоОтвета) Тогда
				Команда = ПрочитатьJSON2(ТелоОтвета);
				Результат.Успех = Истина;
				Результат.ЕстьКоманда = Истина;
				Результат.Команда = Команда;
			Иначе
				Результат.Успех = Истина;
				Результат.ЕстьКоманда = Ложь;
			КонецЕсли;
		ИначеЕсли Ответ.КодСостояния = 204 Тогда
			// Нет команд (таймаут long polling)
			Результат.Успех = Истина;
			Результат.ЕстьКоманда = Ложь;
		Иначе
			Результат.ОписаниеОшибки = "HTTP " + Ответ.КодСостояния;
		КонецЕсли;
		
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции


&НаКлиенте
Функция ОтправитьРезультатНаСервер(Адрес, ИдКоманды, Результат)
	
	РезультатОтправки = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	Попытка
		
		// Разбор URL
		СтруктураURL = РазобратьURL(Адрес);
		
		// Создание HTTP-соединения
		Если СтруктураURL.Протокол = "https" Тогда
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30, Новый ЗащищенноеСоединениеOpenSSL());
		Иначе
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30);
		КонецЕсли;
		
		// Формирование тела запроса
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("id", ИдКоманды);
		
		Если Результат.Свойство("success") И Результат.success Тогда
			ТелоЗапроса.Вставить("success", Истина);
			
			// Безопасное получение data - может отсутствовать при ошибке
			Если Результат.Свойство("data") Тогда
				ТелоЗапроса.Вставить("data", Результат.data);
			КонецЕсли;
			
			// Схема результата (опционально, для execute_query include_schema=true)
			Если Результат.Свойство("schema") Тогда
				ТелоЗапроса.Вставить("schema", Результат.schema);
			КонецЕсли;
			
			// Дополнительные (опциональные) мета-поля результата (например, для постраничного вывода get_metadata)
			// Важно: whitelist, чтобы не прокидывать на сервер произвольные поля/мусор.
			ДопПоля = Новый Массив;
			ДопПоля.Добавить("truncated");
			ДопПоля.Добавить("limit");
			ДопПоля.Добавить("returned");
			ДопПоля.Добавить("count");
			ДопПоля.Добавить("offset");
			ДопПоля.Добавить("has_more");
			ДопПоля.Добавить("next_offset");
			ДопПоля.Добавить("last_date");
			ДопПоля.Добавить("next_same_second_offset");
			ДопПоля.Добавить("configuration");
			ДопПоля.Добавить("extension");
			
			Для Каждого ИмяПоля Из ДопПоля Цикл
				Если Результат.Свойство(ИмяПоля) Тогда
					ЗначениеПоля = Результат[ИмяПоля];
					Если ЗначениеПоля <> Неопределено Тогда
						ТелоЗапроса.Вставить(ИмяПоля, ЗначениеПоля);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ТелоЗапроса.Вставить("success", Ложь);
			
			// Безопасное получение error
			Если Результат.Свойство("error") Тогда
				ТелоЗапроса.Вставить("error", Результат.error);
			Иначе
				ТелоЗапроса.Вставить("error", "Неизвестная ошибка");
			КонецЕсли;
		КонецЕсли;
		
		ТелоJSON = ЗаписатьJSON2(ТелоЗапроса);
		
		// Формирование параметров запроса с channel
		ПараметрыЗапроса = Новый Структура;
		Если Не ПустаяСтрока(ИдентификаторКанала) Тогда
			ПараметрыЗапроса.Вставить("channel", СокрЛП(ИдентификаторКанала));
		КонецЕсли;
		
		ПутьЗапроса = СформироватьПутьЗапроса(СтруктураURL.Путь + "/1c/result", ПараметрыЗапроса);
		
		// Формирование запроса
		Запрос = Новый HTTPЗапрос(ПутьЗапроса);
		Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
		Запрос.УстановитьТелоИзСтроки(ТелоJSON, "UTF-8");
		
		// Выполнение запроса
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		
		Если Ответ.КодСостояния = 200 Или Ответ.КодСостояния = 204 Тогда
			РезультатОтправки.Успех = Истина;
		Иначе
			РезультатОтправки.ОписаниеОшибки = "HTTP " + Ответ.КодСостояния;
		КонецЕсли;
		
	Исключение
		РезультатОтправки.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат РезультатОтправки;
	
КонецФункции

&НаКлиенте
Функция РазобратьURL(URL)
	
	Результат = Новый Структура("Протокол, Хост, Порт, Путь", "http", "", 80, "");
	
	АдресБезПротокола = URL;
	
	// Определение протокола
	Если НРег(Лев(URL, 8)) = "https://" Тогда
		Результат.Протокол = "https";
		Результат.Порт = 443;
		АдресБезПротокола = Сред(URL, 9);
	ИначеЕсли НРег(Лев(URL, 7)) = "http://" Тогда
		Результат.Протокол = "http";
		Результат.Порт = 80;
		АдресБезПротокола = Сред(URL, 8);
	КонецЕсли;
	
	// Разделение хоста и пути
	ПозицияСлеша = Найти(АдресБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		ХостСПортом = Лев(АдресБезПротокола, ПозицияСлеша - 1);
		Результат.Путь = Сред(АдресБезПротокола, ПозицияСлеша);
	Иначе
		ХостСПортом = АдресБезПротокола;
		Результат.Путь = "";
	КонецЕсли;
	
	// Разделение хоста и порта
	ПозицияДвоеточия = Найти(ХостСПортом, ":");
	Если ПозицияДвоеточия > 0 Тогда
		Результат.Хост = Лев(ХостСПортом, ПозицияДвоеточия - 1);
		Попытка
			Результат.Порт = Число(Сред(ХостСПортом, ПозицияДвоеточия + 1));
		Исключение
			// Оставляем порт по умолчанию
		КонецПопытки;
	Иначе
		Результат.Хост = ХостСПортом;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ДИСПЕТЧЕР КОМАНД
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ВыполнитьКомандуНаСервере(Команда)
	
	ИмяИнструмента = СокрЛП(Команда.tool);
	ПараметрыКоманды = Неопределено;
	
	Если Команда.Свойство("params") Тогда
		ПараметрыКоманды = Команда.params;
	КонецЕсли;
	
	// Диспетчеризация по имени инструмента
	Если ИмяИнструмента = "execute_query" Тогда
		
		ТекстЗапроса = "";
		ПараметрыЗапроса = Новый Соответствие;
		Лимит = 1000;
		ВключитьСхему = Ложь;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("query") Тогда
				ТекстЗапроса = ПараметрыКоманды.query;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("params") Тогда
				ПараметрыЗапроса = ПараметрыКоманды.params;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit") Тогда
				Лимит = ПараметрыКоманды.limit;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("include_schema") Тогда
				ВключитьСхему = (ПараметрыКоманды.include_schema = Истина);
			КонецЕсли;
		КонецЕсли;
		
		Возврат ВыполнитьЗапрос(ТекстЗапроса, ПараметрыЗапроса, Лимит, ВключитьСхему);
		
	ИначеЕсли ИмяИнструмента = "execute_code" Тогда
		
		Код = "";
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("code") Тогда
			Код = ПараметрыКоманды.code;
		КонецЕсли;
		
		Возврат ВыполнитьКод(Код);
		
	ИначеЕсли ИмяИнструмента = "get_metadata" Тогда

		Фильтр = "";
		ТипМетаданных = "";
		МаскаИмени = "";
		Лимит = 100;
		Смещение = 0;
		Секции = Неопределено;
		ИмяРасширения = Неопределено;  // КРИТИЧНО: Неопределено, НЕ ""
		КэшПараметры = Неопределено;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("filter") Тогда
				Фильтр = ПараметрыКоманды.filter;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("meta_type") Тогда
				ТипМетаданных = ПараметрыКоманды.meta_type;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("name_mask") Тогда
				МаскаИмени = ПараметрыКоманды.name_mask;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit") Тогда
				Лимит = ПараметрыКоманды.limit;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("offset") Тогда
				Смещение = ПараметрыКоманды.offset;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("sections") Тогда
				Секции = ПараметрыКоманды.sections;
			КонецЕсли;
			// extension_name: присваиваем ТОЛЬКО если свойство есть в JSON
			Если ПараметрыКоманды.Свойство("extension_name") Тогда
				ИмяРасширения = ПараметрыКоманды.extension_name;  // может быть "" (список расширений)
			КонецЕсли;
			
			// Внутренние параметры кэша (токены ВременногоХранилища), добавляются на клиенте.
			Если ПараметрыКоманды.Свойство("mcp_cache_hash")
				Или ПараметрыКоманды.Свойство("mcp_cache_data_token")
				Или ПараметрыКоманды.Свойство("mcp_cache_index_token")
				Или ПараметрыКоманды.Свойство("mcp_cache_details_token") Тогда
				
				КэшПараметры = Новый Структура(
					"hash, data_token, index_token, details_token",
					?(ПараметрыКоманды.Свойство("mcp_cache_hash"), ПараметрыКоманды.mcp_cache_hash, ""),
					?(ПараметрыКоманды.Свойство("mcp_cache_data_token"), ПараметрыКоманды.mcp_cache_data_token, Неопределено),
					?(ПараметрыКоманды.Свойство("mcp_cache_index_token"), ПараметрыКоманды.mcp_cache_index_token, Неопределено),
					?(ПараметрыКоманды.Свойство("mcp_cache_details_token"), ПараметрыКоманды.mcp_cache_details_token, Неопределено)
				);
			КонецЕсли;
		КонецЕсли;

		Возврат ПолучитьМетаданные(Фильтр, ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, ИмяРасширения, КэшПараметры);
		
	ИначеЕсли ИмяИнструмента = "get_event_log" Тогда
		
		// Парсим даты из ISO формата
		ДатаНачала = Неопределено;
		ДатаОкончания = Неопределено;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("start_date") И ЗначениеЗаполнено(ПараметрыКоманды.start_date) Тогда
				ДатаНачала = ПрочитатьДатуИзISO(ПараметрыКоманды.start_date);
			КонецЕсли;
			
			Если ПараметрыКоманды.Свойство("end_date") И ЗначениеЗаполнено(ПараметрыКоманды.end_date) Тогда
				ДатаОкончания = ПрочитатьДатуИзISO(ПараметрыКоманды.end_date);
			КонецЕсли;
		КонецЕсли;
		
		Уровни = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("levels") Тогда
			Уровни = ПараметрыКоманды.levels;
		КонецЕсли;
		
		События = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("events") Тогда
			События = ПараметрыКоманды.events;
		КонецЕсли;
		
		Лимит = 100;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("limit") Тогда
			Лимит = ПараметрыКоманды.limit;
		КонецЕсли;
		
		// Разрешение параметра фильтра по объекту (приоритет: object_description > link > data)
		ДанныеОбъекта = Неопределено;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			// Приоритет 1: object_description
			Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
				Попытка
					ДанныеОбъекта = СформироватьНавигационнуюСсылку(ПараметрыКоманды.object_description);
				Исключение
					// Возвращаем явную ошибку при невозможности сформировать навигационную ссылку
					Возврат Новый Структура("success, error", Ложь, 
						"Ошибка формирования навигационной ссылки: " + ОписаниеОшибки() + 
						" / Error creating navigation link: " + ОписаниеОшибки());
				КонецПопытки;
			
			// Приоритет 2: link
			ИначеЕсли ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
				ДанныеОбъекта = ПараметрыКоманды.link;
			
			// Приоритет 3: data (обратная совместимость)
			ИначеЕсли ПараметрыКоманды.Свойство("data") И ЗначениеЗаполнено(ПараметрыКоманды.data) Тогда
				ДанныеОбъекта = ПараметрыКоманды.data;
			КонецЕсли;
		КонецЕсли;
		
		ТипыМетаданных = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("metadata_type") Тогда
			ТипыМетаданных = ПараметрыКоманды.metadata_type;
		КонецЕсли;
		
		ФильтрПользователи = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("user") Тогда
			ФильтрПользователи = ПараметрыКоманды.user;
		КонецЕсли;
		
		Сеансы = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("session") Тогда
			Сеансы = ПараметрыКоманды.session;
		КонецЕсли;
		
		Приложения = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("application") Тогда
			Приложения = ПараметрыКоманды.application;
		КонецЕсли;
		
		Компьютер = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("computer") Тогда
			Компьютер = ПараметрыКоманды.computer;
		КонецЕсли;
		
		ПодстрокаКомментария = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("comment_contains") Тогда
			ПодстрокаКомментария = ПараметрыКоманды.comment_contains;
		КонецЕсли;
		
		СтатусТранзакции = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("transaction_status") Тогда
			СтатусТранзакции = ПараметрыКоманды.transaction_status;
		КонецЕсли;

		// Курсорная пагинация: смещение записей в пределах начальной секунды
		СмещениеВСекунде = 0;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("same_second_offset") И ЗначениеЗаполнено(ПараметрыКоманды.same_second_offset) Тогда
			СмещениеВСекунде = ПараметрыКоманды.same_second_offset;
		КонецЕсли;

		Возврат ПолучитьЖурналРегистрации(ДатаНачала, ДатаОкончания, Уровни, События, Лимит,
			ДанныеОбъекта, ТипыМетаданных, ФильтрПользователи, Сеансы, Приложения, Компьютер,
			ПодстрокаКомментария, СтатусТранзакции, СмещениеВСекунде);
		
	ИначеЕсли ИмяИнструмента = "get_object_by_link" Тогда
		
		Ссылка = "";
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("link") Тогда
			Ссылка = ПараметрыКоманды.link;
		КонецЕсли;
		
		Возврат ПолучитьОбъектПоНавигационнойСсылке(Ссылка);
		
	ИначеЕсли ИмяИнструмента = "get_link_of_object" Тогда

		ОписаниеОбъекта = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("object_description") Тогда
			ОписаниеОбъекта = ПараметрыКоманды.object_description;
		КонецЕсли;

		Возврат ПолучитьНавигационнуюСсылкуПоОписанию(ОписаниеОбъекта);

	ИначеЕсли ИмяИнструмента = "find_references_to_object" Тогда

		ОписаниеЦелевогоОбъекта = Неопределено;
		ОбластиПоиска = Неопределено;
		ФильтрМетаданных = Неопределено;
		ЛимитНайденных = 200;
		ЛимитНаМетуОбъект = 20;
		БюджетВремениСек = 30;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("target_object_description") Тогда
				ОписаниеЦелевогоОбъекта = ПараметрыКоманды.target_object_description;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("search_scope") Тогда
				ОбластиПоиска = ПараметрыКоманды.search_scope;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("meta_filter") Тогда
				ФильтрМетаданных = ПараметрыКоманды.meta_filter;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit_hits") Тогда
				ЛимитНайденных = ПараметрыКоманды.limit_hits;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit_per_meta") Тогда
				ЛимитНаМетуОбъект = ПараметрыКоманды.limit_per_meta;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("timeout_budget_sec") Тогда
				БюджетВремениСек = ПараметрыКоманды.timeout_budget_sec;
			КонецЕсли;
		КонецЕсли;

		Возврат НайтиСсылкиНаОбъект(ОписаниеЦелевогоОбъекта, ОбластиПоиска, ФильтрМетаданных,
			ЛимитНайденных, ЛимитНаМетуОбъект, БюджетВремениСек);

	ИначеЕсли ИмяИнструмента = "get_access_rights" Тогда

		ИмяОбъектаМетаданных = "";
		ИмяПользователяИБ = Неопределено;
		ФильтрПрав = Неопределено;
		ФильтрРолей = Неопределено;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("metadata_object") Тогда
				ИмяОбъектаМетаданных = ПараметрыКоманды.metadata_object;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("user_name") Тогда
				ИмяПользователяИБ = ПараметрыКоманды.user_name;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("rights_filter") Тогда
				ФильтрПрав = ПараметрыКоманды.rights_filter;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("roles_filter") Тогда
				ФильтрРолей = ПараметрыКоманды.roles_filter;
			КонецЕсли;
		КонецЕсли;

		Возврат ПолучитьПраваДоступа(ИмяОбъектаМетаданных, ИмяПользователяИБ, ФильтрПрав, ФильтрРолей);

	Иначе
		
		Возврат Новый Структура("success, error", Ложь, "Неизвестный инструмент: " + ИмяИнструмента);
		
	КонецЕсли;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ВЫПОЛНЕНИЕ ЗАПРОСОВ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция БезопасноеЗначениеДляПередачи(Значение, Глубина = 0)
	
	Если Глубина > 5 Тогда
		Возврат "<max_depth>";
	КонецЕсли;
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	Если ТипЗначения = Тип("Строка")
		Или ТипЗначения = Тип("Число")
		Или ТипЗначения = Тип("Булево")
		Или ТипЗначения = Тип("Дата") Тогда
		Возврат Значение;
	КонецЕсли;
	
	Если ТипЗначения = Тип("УникальныйИдентификатор") Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
	Если ЭтоСсылка(ТипЗначения) Тогда
		Если ЗначениеЗаполнено(Значение) Тогда
			Возврат ОписаниеОбъектаПоСсылке(Значение);
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Массив") Тогда
		Результат = Новый Массив;
		Для Каждого Элемент Из Значение Цикл
			Результат.Добавить(БезопасноеЗначениеДляПередачи(Элемент, Глубина + 1));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;

	// ФиксированныйМассив (FixedArray) - сериализуем как обычный массив
	Если ТипЗначения = Тип("ФиксированныйМассив") Тогда
		Результат = Новый Массив;
		Попытка
			Для Каждого Элемент Из Значение Цикл
				Результат.Добавить(БезопасноеЗначениеДляПередачи(Элемент, Глубина + 1));
			КонецЦикла;
		Исключение
			// Если по какой-то причине не итерируется - оставим пустой массив
		КонецПопытки;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Структура") Тогда
		Результат = Новый Структура;
		Для Каждого Пара Из Значение Цикл
			Результат.Вставить(Пара.Ключ, БезопасноеЗначениеДляПередачи(Пара.Значение, Глубина + 1));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Соответствие") Тогда
		Результат = Новый Массив;
		Для Каждого Пара Из Значение Цикл
			Результат.Добавить(Новый Структура(
				"key, value",
				БезопасноеЗначениеДляПередачи(Пара.Ключ, Глубина + 1),
				БезопасноеЗначениеДляПередачи(Пара.Значение, Глубина + 1)
			));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Результат = Новый Массив;
		Для Каждого СтрокаТаблицы Из Значение Цикл
			СтрокаРезультата = Новый Структура;
			Для Каждого Колонка Из Значение.Колонки Цикл
				СтрокаРезультата.Вставить(Колонка.Имя, БезопасноеЗначениеДляПередачи(СтрокаТаблицы[Колонка.Имя], Глубина + 1));
			КонецЦикла;
			Результат.Добавить(СтрокаРезультата);
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;

	// ОписаниеТипов (TypeDescription) -> строковое перечисление типов
	// Строка(ТипЗнч(ОписаниеТипов)) возвращает "Описание типов" (не "ОписаниеТипов"), поэтому используем прямое сравнение типов
	Если ТипЗначения = Тип("ОписаниеТипов") Тогда
		Попытка
			Возврат ПолучитьСтроковоеПредставлениеОписанияТипов(Значение);
		Исключение
			// Если по какой-то причине не удалось - обработаем ниже как строку
		КонецПопытки;
	КонецЕсли;

	// СвязьПоТипу (TypeLink) -> объект {ПутьКДанным?, ЭлементСвязи?}
	// Важно: если связь не настроена, возвращаем пустой объект {}, чтобы ключ properties.СвязьПоТипу оставался,
	// но не превращался в неинформативную строку "СвязьПоТипу".
	Попытка
		Если ТипЗначения = Тип("СвязьПоТипу") Тогда
			Результат = Новый Структура;
			
			Попытка
				ПутьКДанным = Значение.ПутьКДанным;
				Если ПутьКДанным <> Неопределено И НЕ ПустаяСтрока(Строка(ПутьКДанным)) Тогда
					Результат.Вставить("ПутьКДанным", Строка(ПутьКДанным));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				ЭлементСвязи = Значение.ЭлементСвязи;
				Если ЭлементСвязи <> Неопределено И ЭлементСвязи <> 0 Тогда
					Результат.Вставить("ЭлементСвязи", ЭлементСвязи);
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;

	// СвязьПараметраВыбора (ChoiceParameterLink) -> объект {Имя?, ПутьКДанным?, ИзменениеЗначения?}
	// Используется в СвязиПараметровВыбора (ChoiceParameterLinks): ФиксированныйМассив элементов этого типа.
	Попытка
		Если ТипЗначения = Тип("СвязьПараметраВыбора") Тогда
			Результат = Новый Структура;
			
			Попытка
				ИмяСвязи = Значение.Имя;
				Если ИмяСвязи <> Неопределено И НЕ ПустаяСтрока(Строка(ИмяСвязи)) Тогда
					Результат.Вставить("Имя", Строка(ИмяСвязи));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				ПутьКДанным = Значение.ПутьКДанным;
				Если ПутьКДанным <> Неопределено И НЕ ПустаяСтрока(Строка(ПутьКДанным)) Тогда
					Результат.Вставить("ПутьКДанным", Строка(ПутьКДанным));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				РежимИзменения = Значение.ИзменениеЗначения;
				Если РежимИзменения <> Неопределено Тогда
					Результат.Вставить("ИзменениеЗначения", Строка(РежимИзменения));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставОбщегоРеквизита (CommonAttributeContent) -> массив элементов состава
	// Каждый элемент: {Метаданные, Использование, УсловноеРазделение}
	Попытка
		Если ТипЗначения = Тип("СоставОбщегоРеквизита") Тогда
			Результат = Новый Массив;
			
			// Добавляем поле УсловноеРазделение только если оно реально встречается хотя бы у одного элемента.
			// Если встречается - ключ должен присутствовать у всех строк (у остальных будет null), чтобы табличный вывод не "терял" колонку.
			НужноПолеУсловноеРазделение = Ложь;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					Попытка
						Если ЭлементСостава.УсловноеРазделение <> Неопределено Тогда
							НужноПолеУсловноеРазделение = Истина;
							Прервать;
						КонецЕсли;
					Исключение
					КонецПопытки;
				КонецЦикла;
			Исключение
			КонецПопытки;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Метаданные (MetadataObject) -> ПолноеИмя() если возможно
					Попытка
						Мета = ЭлементСостава.Метаданные;
						Если Мета <> Неопределено Тогда
							ПолноеИмяМета = ПолноеИмяМетаданныхЕслиВозможно(Мета);
							Если ПолноеИмяМета = Неопределено Тогда
								Попытка
									ПолноеИмяМета = Мета.ПолноеИмя();
								Исключение
									ПолноеИмяМета = Строка(Мета);
								КонецПопытки;
							КонецЕсли;
							ЭлементJSON.Вставить("Метаданные", ПолноеИмяМета);
						КонецЕсли;
					Исключение
					КонецПопытки;
					
					// Использование (CommonAttributeUse) -> строка значения перечисления
					Попытка
						ЭлементJSON.Вставить("Использование", Строка(ЭлементСостава.Использование));
					Исключение
					КонецПопытки;
					
					// УсловноеРазделение (ConditionalSeparation): Константа/Булево/реквизит и т.д.
					Если НужноПолеУсловноеРазделение Тогда
						УсловиеJSON = Неопределено;
						Попытка
							Условие = ЭлементСостава.УсловноеРазделение;
							Если Условие <> Неопределено Тогда
								УсловиеJSON = ПолноеИмяМетаданныхЕслиВозможно(Условие);
								Если УсловиеJSON = Неопределено Тогда
									УсловиеJSON = БезопасноеЗначениеДляПередачи(Условие, Глубина + 1);
								КонецЕсли;
							КонецЕсли;
						Исключение
						КонецПопытки;
						ЭлементJSON.Вставить("УсловноеРазделение", УсловиеJSON);
					КонецЕсли;
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставПланаОбмена (ExchangePlanContent) -> массив элементов состава
	// Каждый элемент: {Метаданные, АвтоРегистрация}
	Попытка
		Если ТипЗначения = Тип("СоставПланаОбмена") Тогда
			Результат = Новый Массив;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Метаданные (MetadataObject) -> ПолноеИмя() если возможно
					ПолноеИмяМета = Неопределено;
					Попытка
						Мета = ЭлементСостава.Метаданные;
						Если Мета <> Неопределено Тогда
							ПолноеИмяМета = ПолноеИмяМетаданныхЕслиВозможно(Мета);
							Если ПолноеИмяМета = Неопределено Тогда
								Попытка
									ПолноеИмяМета = Мета.ПолноеИмя();
								Исключение
									ПолноеИмяМета = Строка(Мета);
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("Метаданные", ПолноеИмяМета);
					
					// АвтоРегистрация (AutoChangeRecord) -> строка значения перечисления
					АвтоРегистрацияJSON = Неопределено;
					Попытка
						АвтоРегистрацияJSON = Строка(ЭлементСостава.АвтоРегистрация);
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("АвтоРегистрация", АвтоРегистрацияJSON);
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставФункциональнойОпции (FunctionalOptionContent) -> массив элементов состава
	// Каждый элемент: {Объект}
	Попытка
		Если ТипЗначения = Тип("СоставФункциональнойОпции") Тогда
			Результат = Новый Массив;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Объект (MetadataObject) -> ПолноеИмя() если возможно
					ПолноеИмяОбъекта = Неопределено;
					Попытка
						ОбъектМета = ЭлементСостава.Объект;
						Если ОбъектМета <> Неопределено Тогда
							ПолноеИмяОбъекта = ПолноеИмяМетаданныхЕслиВозможно(ОбъектМета);
							Если ПолноеИмяОбъекта = Неопределено Тогда
								Попытка
									ПолноеИмяОбъекта = ОбъектМета.ПолноеИмя();
								Исключение
									ПолноеИмяОбъекта = Строка(ОбъектМета);
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("Объект", ПолноеИмяОбъекта);
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
  	
	// ОписаниеЗащитыОтОпасныхДействий (UnsafeOperationProtectionDescription) -> Булево
	// Возвращаем флаг ПредупреждатьОбОпасныхДействиях, чтобы в JSON было true/false.
	Если Строка(ТипЗначения) = "ОписаниеЗащитыОтОпасныхДействий" Тогда
		Попытка
			Возврат (Значение.ПредупреждатьОбОпасныхДействиях = Истина);
		Исключение
			// Если свойство недоступно (например, платформа < 8.3.8) - вернём строковое представление
		КонецПопытки;
	КонецЕсли;
 	
	Попытка
		Возврат Строка(Значение);
	Исключение
		Возврат "<" + Строка(ТипЗначения) + ">";
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ВыполнитьЗапрос(ТекстЗапроса, ПараметрыЗапроса, Лимит, ВключитьСхему = Ложь)
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		
		// Установка параметров запроса
		Если ТипЗнч(ПараметрыЗапроса) = Тип("Соответствие") Тогда
			Для Каждого Параметр Из ПараметрыЗапроса Цикл
				ЗначениеПараметра = Параметр.Значение;
				// Конвертация описания объекта обратно в ссылку
				ЗначениеПараметра = ОбъектИнформационнойБазыПоОписанию(ЗначениеПараметра);
				Запрос.УстановитьПараметр(Параметр.Ключ, ЗначениеПараметра);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ПараметрыЗапроса) = Тип("Структура") Тогда
			Для Каждого Параметр Из ПараметрыЗапроса Цикл
				ЗначениеПараметра = Параметр.Значение;
				// Конвертация описания объекта обратно в ссылку
				ЗначениеПараметра = ОбъектИнформационнойБазыПоОписанию(ЗначениеПараметра);
				Запрос.УстановитьПараметр(Параметр.Ключ, ЗначениеПараметра);
			КонецЦикла;
		КонецЕсли;
		
		РезультатЗапроса = Запрос.Выполнить();
		
		// Формирование схемы если запрошено
		Схема = Неопределено;
		Если ВключитьСхему Тогда
			Схема = СформироватьСхемуРезультата(РезультатЗапроса);
		КонецЕсли;
		
		Выборка = РезультатЗапроса.Выбрать();
		
		МассивРезультата = Новый Массив;
		Счетчик = 0;
		
		Пока Выборка.Следующий() И Счетчик < Лимит Цикл
			
			СтрокаРезультата = Новый Структура;
			
			Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
				Значение = Выборка[Колонка.Имя];
				СтрокаРезультата.Вставить(Колонка.Имя, БезопасноеЗначениеДляПередачи(Значение));
			КонецЦикла;
			
			МассивРезультата.Добавить(СтрокаРезультата);
			Счетчик = Счетчик + 1;
			
		КонецЦикла;
		
		// Возврат результата с учетом параметра ВключитьСхему
		Если ВключитьСхему Тогда
			Возврат Новый Структура("success, data, schema", Истина, МассивРезультата, Схема);
		Иначе
			Возврат Новый Структура("success, data", Истина, МассивРезультата);
		КонецЕсли;
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// Формирует схему результата запроса с информацией о типах колонок
//
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - результат выполнения запроса
//
// Возвращаемое значение:
//  Структура - схема с полем columns (массив описаний колонок)
//    * columns - Массив - массив структур с описанием колонок:
//      ** name - Строка - имя колонки
//      ** types - Массив - массив строковых представлений типов (отсортирован, без дублей)
//
&НаСервереБезКонтекста
Функция СформироватьСхемуРезультата(РезультатЗапроса)
	
	МассивКолонок = Новый Массив;
	
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		
		МассивТипов = Новый Массив;
		
		Для Каждого Тип Из Колонка.ТипЗначения.Типы() Цикл
			СтроковыйТип = ПолучитьСтроковоеПредставлениеТипаДляСхемы(Тип);
			МассивТипов.Добавить(СтроковыйТип);
		КонецЦикла;
		
		// Сортировка и удаление дублей
		МассивТипов = УдалитьДублиИСортировать(МассивТипов);
		
		ОписаниеКолонки = Новый Структура("name, types", Колонка.Имя, МассивТипов);
		МассивКолонок.Добавить(ОписаниеКолонки);
		
	КонецЦикла;
	
	Возврат Новый Структура("columns", МассивКолонок);
	
КонецФункции

// Получает строковое представление типа для схемы результата запроса
//
// Параметры:
//  Тип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - строковое представление типа
//
&НаСервереБезКонтекста
Функция ПолучитьСтроковоеПредставлениеТипаДляСхемы(Тип)
	
	// Используем существующую функцию ЭтоСсылка для проверки ссылочного типа
	// и существующую СтроковоеПредставлениеТипа для получения полного имени
	
	Если ЭтоСсылка(Тип) Тогда
		// Для ссылочных типов используем СтроковоеПредставлениеТипа
		// Возвращает полное имя: "СправочникСсылка.Контрагенты"
		Возврат СтроковоеПредставлениеТипа(Тип);
	Иначе
		// Для примитивных типов используем Строка(Тип)
		// Возвращает: "Строка", "Число", "Дата", "Булево"
		Возврат Строка(Тип);
	КонецЕсли;
	
КонецФункции

// Удаляет дубликаты из массива строк и сортирует его
//
// Параметры:
//  МассивСтрок - Массив - массив строк для обработки
//
// Возвращаемое значение:
//  Массив - отсортированный массив уникальных строк
//
&НаСервереБезКонтекста
Функция УдалитьДублиИСортировать(МассивСтрок)
	
	// Используем соответствие для удаления дублей
	Соответствие = Новый Соответствие;
	Для Каждого Строка Из МассивСтрок Цикл
		Соответствие.Вставить(Строка, Истина);
	КонецЦикла;
	
	// Собираем уникальные значения
	УникальныеЗначения = Новый Массив;
	Для Каждого КлючЗначение Из Соответствие Цикл
		УникальныеЗначения.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	// Сортировка через СписокЗначений
	СписокДляСортировки = Новый СписокЗначений;
	Для Каждого Значение Из УникальныеЗначения Цикл
		СписокДляСортировки.Добавить(Значение);
	КонецЦикла;
	СписокДляСортировки.СортироватьПоЗначению();
	
	// Результат
	Результат = Новый Массив;
	Для Каждого Элемент Из СписокДляСортировки Цикл
		Результат.Добавить(Элемент.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ВЫПОЛНЕНИЕ ПРОИЗВОЛЬНОГО КОДА
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ВыполнитьКод(Код)
	
	Попытка
		
		Результат = Неопределено;
		Выполнить(Код);
		
		Возврат Новый Структура("success, data", Истина, БезопасноеЗначениеДляПередачи(Результат));
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПОЛУЧЕНИЕ МЕТАДАННЫХ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьМетаданные(Фильтр, ТипМетаданных = "", МаскаИмени = "", Лимит = 100, Смещение = 0, Секции = Неопределено, ИмяРасширения = Неопределено, КэшПараметры = Неопределено)

	Попытка

		// Обработка расширений: ИмяРасширения <> Неопределено означает работу с расширениями
		Если ИмяРасширения <> Неопределено Тогда
			Если ПустаяСтрока(ИмяРасширения) Тогда
				// Пустая строка = запрос списка всех расширений
				Возврат ПолучитьСписокРасширений();
			Иначе
				// Конкретное имя = работа с метаданными внутри расширения
				Возврат ПолучитьМетаданныеРасширения(ИмяРасширения, Фильтр,
							ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, КэшПараметры);
			КонецЕсли;
		КонецЕсли;

		// Основная конфигурация (ИмяРасширения = Неопределено)
		Если ПустаяСтрока(Фильтр) Тогда
			// Новый контракт:
			// - без filter и без meta_type и без name_mask: сводка (configuration + roots)
			// - meta_type задан (или задан name_mask): список объектов данного типа (или "*" для полного списка)
			ТипТипМетаданных = ТипЗнч(ТипМетаданных);
			НетТипаМетаданных = (ТипМетаданных = Неопределено) Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных));

			Если НетТипаМетаданных И ПустаяСтрока(МаскаИмени) Тогда
				Возврат ПолучитьСводкуМетаданных();
			Иначе
				Если НетТипаМетаданных Тогда
					ТипМетаданных = "*";
				КонецЕсли;
				Возврат ПолучитьСписокМетаданных(ТипМетаданных, МаскаИмени, Лимит, Смещение);
			КонецЕсли;
		Иначе
			Возврат ПолучитьДетальныеМетаданные(Фильтр, Секции);
		КонецЕсли;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// РАБОТА С РАСШИРЕНИЯМИ КОНФИГУРАЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьКоллекциюИзРасширения(ОбъектРасширения, ИмяКоллекции)
	// Унифицированный доступ к коллекциям метаданных внутри объекта расширения.
	// В разных версиях/контекстах платформа может по-разному предоставлять доступ:
	// - через свойство (ОбъектРасширения.<Коллекция>)
	// - через индексатор (ОбъектРасширения[<Коллекция>])
	
	Коллекция = Неопределено;
	
	Попытка
		Коллекция = Вычислить("ОбъектРасширения." + ИмяКоллекции);
	Исключение
		Коллекция = Неопределено;
	КонецПопытки;
	
	Если Коллекция = Неопределено Тогда
		Попытка
			Коллекция = ОбъектРасширения[ИмяКоллекции];
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Коллекция;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокРасширений()
	// Возвращает список всех подключённых расширений конфигурации

	Попытка
		// Платформенный API для расширений находится в глобальном контексте:
		//   РасширенияКонфигурации (ConfigurationExtensionsManager)
		// В рантайм-метаданных (Метаданные.…) этого поля может не быть.
		МассивРасширений = Неопределено;
		Попытка
			МассивРасширений = РасширенияКонфигурации.Получить();
		Исключение
			МассивРасширений = Неопределено;
		КонецПопытки;

		Если МассивРасширений = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширения конфигурации недоступны в данной версии платформы");
		КонецЕсли;

		СписокРасширений = Новый Массив;

		Для Каждого ТекРасширение Из МассивРасширений Цикл
			ИнфоРасширения = Новый Структура;
			
			// Возвращаем свойства объекта РасширениеКонфигурации (ConfigurationExtension).
			// Количество объектов расширения намеренно НЕ возвращаем: это отдельная задача
			// и может зависеть от способа анализа данных расширения.
			СвойстваРасширения = Новый Массив;
			СвойстваРасширения.Добавить("Имя");
			СвойстваРасширения.Добавить("Синоним");
			СвойстваРасширения.Добавить("Версия");
			СвойстваРасширения.Добавить("Активно");
			СвойстваРасширения.Добавить("БезопасныйРежим");
			СвойстваРасширения.Добавить("ГлавныйУзел");
			СвойстваРасширения.Добавить("ЗащитаОтОпасныхДействий");
			СвойстваРасширения.Добавить("ИспользоватьОсновныеРолиДляВсехПользователей");
			СвойстваРасширения.Добавить("ИспользуетсяВРаспределеннойИнформационнойБазе");
			СвойстваРасширения.Добавить("Назначение");
			СвойстваРасширения.Добавить("ОбластьДействия");
			СвойстваРасширения.Добавить("ОсновныеРоли");
			СвойстваРасширения.Добавить("УникальныйИдентификатор");
			СвойстваРасширения.Добавить("ХешСумма");
			
			Для Каждого ИмяСвойства Из СвойстваРасширения Цикл
				ЗначениеСвойства = Неопределено;
				Попытка
					ЗначениеСвойства = Вычислить("ТекРасширение." + ИмяСвойства);
				Исключение
					ЗначениеСвойства = Неопределено;
				КонецПопытки;
				
				// Спец. обработка: ЗащитаОтОпасныхДействий.
				// По справке это не булево, а объект ОписаниеЗащитыОтОпасныхДействий,
				// но в API мы хотим возвращать простое true/false.
				Если ИмяСвойства = "ЗащитаОтОпасныхДействий" Тогда
					БулевоЗначение = Неопределено;
					Попытка
						Если ЗначениеСвойства <> Неопределено Тогда
							БулевоЗначение = (ЗначениеСвойства.ПредупреждатьОбОпасныхДействиях = Истина);
						КонецЕсли;
					Исключение
						БулевоЗначение = Неопределено;
					КонецПопытки;
					ЗначениеСвойства = БулевоЗначение;
				КонецЕсли;
				
				// Вставляем ключ всегда, даже если значение Неопределено (будет null в JSON).
				ИнфоРасширения.Вставить(ИмяСвойства, БезопасноеЗначениеДляПередачи(ЗначениеСвойства));
			КонецЦикла;

			СписокРасширений.Добавить(ИнфоРасширения);
		КонецЦикла;

		Возврат Новый Структура("success, data", Истина, СписокРасширений);

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КЭШ МЕТАДАННЫХ РАСШИРЕНИЙ (ОбъектМетаданныхКонфигурация)
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьКэшМетаданныхРасширений()
	// В модуле формы (особенно при проверке "Толстый клиент (обычное приложение)")
	// серверные модульные переменные недоступны/нестабильны для &НаСервереБезКонтекста.
	// Поэтому кэш здесь отключён: возвращаем новый контейнер, который не сохраняется между вызовами.
	Возврат Новый Соответствие;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьКлючКэшаРасширения(Расширение)
	Ключ = "";
	Попытка
		Если Расширение.УникальныйИдентификатор <> Неопределено Тогда
			Ключ = Строка(Расширение.УникальныйИдентификатор);
		КонецЕсли;
	Исключение
		Ключ = "";
	КонецПопытки;

	Если ПустаяСтрока(Ключ) Тогда
		Попытка
			Ключ = Расширение.Имя;
		Исключение
			Ключ = "";
		КонецПопытки;
	КонецЕсли;

	Возврат Ключ;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьХешРасширенияСтрокой(Расширение)
	Хеш = "";
	Попытка
		Хеш = Строка(Расширение.ХешСумма);
	Исключение
		Хеш = "";
	КонецПопытки;
	Возврат Хеш;
КонецФункции

&НаСервереБезКонтекста
Функция ПостроитьИндексМетаданныхРасширения(МетаданныеРасширения)
	// Возвращает ТаблицаЗначений со всеми объектами расширения (верхний уровень),
	// отсортированную по ПолноеИмя (через SortKey) для стабильной пагинации.
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Тип");
	Таблица.Колонки.Добавить("Имя");
	Таблица.Колонки.Добавить("Синоним");
	Таблица.Колонки.Добавить("ПолноеИмя");
	Таблица.Колонки.Добавить("SortKey");

	КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
	Для Каждого ОписаниеТипа Из КорневыеТипы Цикл

		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("МетаданныеРасширения." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;

		Если Коллекция = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Для Каждого ОбъектМетаданных Из Коллекция Цикл

			Имя = "";
			Синоним = "";
			ПолноеИмя = "";

			Попытка
				Имя = ОбъектМетаданных.Имя;
			Исключение
				Имя = "";
			КонецПопытки;

			Попытка
				Синоним = ОбъектМетаданных.Синоним;
			Исключение
				Синоним = "";
			КонецПопытки;

			Попытка
				ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			Исключение
				ПолноеИмя = "";
			КонецПопытки;

			Если ПустаяСтрока(ПолноеИмя) Тогда
				Если НЕ ПустаяСтрока(Имя) Тогда
					ПолноеИмя = ОписаниеТипа.Тип + "." + Имя;
				Иначе
					ПолноеИмя = ОписаниеТипа.Тип;
				КонецЕсли;
			КонецЕсли;

			Стр = Таблица.Добавить();
			Стр.Тип = ОписаниеТипа.Тип;
			Стр.Имя = Имя;
			Стр.Синоним = Синоним;
			Стр.ПолноеИмя = ПолноеИмя;
			Стр.SortKey = ВРег(ПолноеИмя);

		КонецЦикла;
	КонецЦикла;

	Таблица.Сортировать("SortKey, ПолноеИмя");
	Возврат Таблица;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры = Неопределено)
	// Возвращает структуру:
	// - success: Булево
	// - metadata: ОбъектМетаданныхКонфигурация | Неопределено
	// - index: ТаблицаЗначений | Неопределено
	// - is_empty: Булево (Истина если расширение пустое: ПолучитьДанные() вернуло Неопределено без ошибки)
	// - error: Строка (если success=Ложь)
	// - hash: Строка (ХешСумма расширения)
	// - data_token: адрес ВременногоХранилища для ДвоичныхДанных (best effort)
	Рез = Новый Структура("success, metadata, index, is_empty, error, hash, data_token",
		Ложь, Неопределено, Неопределено, Ложь, "", "", Неопределено);

	Если Расширение = Неопределено Тогда
		Рез.error = "Расширение не задано";
		Возврат Рез;
	КонецЕсли;

	Хеш = ПолучитьХешРасширенияСтрокой(Расширение);
	Рез.hash = Хеш;

	// Получаем бинарные данные расширения
	Данные = Неопределено;
	ОшибкаДанных = "";
	
	// 1) Попытка использовать токен кэша (ВременноеХранилище) если хеш совпадает
	Если КэшПараметры <> Неопределено Тогда
		Попытка
			Если КэшПараметры.Свойство("hash")
				И КэшПараметры.hash = Хеш
				И КэшПараметры.Свойство("data_token")
				И КэшПараметры.data_token <> Неопределено Тогда
				
				ТокенДанных = КэшПараметры.data_token;
				Попытка
					Данные = ПолучитьИзВременногоХранилища(ТокенДанных);
					Рез.data_token = ТокенДанных;
				Исключение
					Данные = Неопределено;
					Рез.data_token = Неопределено;
				КонецПопытки;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// 2) Если токена нет/протух, получаем данные через API расширения
	Попытка
		Если Данные = Неопределено Тогда
			Данные = Расширение.ПолучитьДанные();
		КонецЕсли;
	Исключение
		ОшибкаДанных = ОписаниеОшибки();
		Данные = Неопределено;
	КонецПопытки;

	Если Данные = Неопределено Тогда
		Если НЕ ПустаяСтрока(ОшибкаДанных) Тогда
			Рез.error = "Не удалось получить данные расширения: " + ОшибкаДанных;
			Возврат Рез;
		КонецЕсли;

		// Пустое расширение (GetData() вернуло Неопределено без ошибки)
		Рез.success = Истина;
		Рез.is_empty = Истина;

		Возврат Рез;
	КонецЕсли;
	
	// 3) Кладём ДвоичныеДанные во ВременноеХранилище (best effort), если ещё нет токена
	Если Рез.data_token = Неопределено Тогда
		Попытка
			Рез.data_token = ПоместитьВоВременноеХранилище(Данные);
		Исключение
			Рез.data_token = Неопределено;
		КонецПопытки;
	КонецЕсли;

	// Парсим метаданные расширения
	МетаданныеРасширения = Неопределено;
	ОшибкаПарсинга = "";
	Попытка
		МетаданныеРасширения = Новый ОбъектМетаданныхКонфигурация(Данные);
	Исключение
		ОшибкаПарсинга = ОписаниеОшибки();
		МетаданныеРасширения = Неопределено;
	КонецПопытки;

	Если МетаданныеРасширения = Неопределено Тогда
		Рез.error = "Не удалось прочитать метаданные расширения (ОбъектМетаданныхКонфигурация): " + ОшибкаПарсинга;
		Возврат Рез;
	КонецЕсли;

	Индекс = ПостроитьИндексМетаданныхРасширения(МетаданныеРасширения);

	Рез.success = Истина;
	Рез.metadata = МетаданныеРасширения;
	Рез.index = Индекс;

	Возврат Рез;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьМетаданныеРасширения(ИмяРасширения, Фильтр, ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, КэшПараметры = Неопределено)
	// Маршрутизатор для работы с метаданными конкретного расширения

	Попытка
		// 1. Проверяем доступность API расширений
		МассивРасширений = Неопределено;
		Попытка
			Отбор = Новый Структура("Имя", ИмяРасширения);
			МассивРасширений = РасширенияКонфигурации.Получить(Отбор);
		Исключение
			МассивРасширений = Неопределено;
		КонецПопытки;

		Если МассивРасширений = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширения конфигурации недоступны в данной версии платформы");
		КонецЕсли;

		// 2. Находим расширение по имени
		НайденноеРасширение = Неопределено;
		Если ТипЗнч(МассивРасширений) = Тип("Массив") И МассивРасширений.Количество() > 0 Тогда
			НайденноеРасширение = МассивРасширений[0];
		КонецЕсли;

		// 3. Обработка ошибки: расширение не найдено
		Если НайденноеРасширение = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширение не найдено: " + ИмяРасширения);
		КонецЕсли;

		// 4. Выбор режима: details или list
		Если НЕ ПустаяСтрока(Фильтр) Тогда
			Возврат ПолучитьДетальныеМетаданныеРасширения(НайденноеРасширение, Фильтр, Секции, КэшПараметры);
		Иначе
			// Новый контракт (симметрия с основной конфигурацией):
			// Если не задано filter/meta_type/name_mask — возвращаем summary по типам внутри расширения.
			ТипТипМетаданных = ТипЗнч(ТипМетаданных);
			НетТипаМетаданных = (ТипМетаданных = Неопределено)
				Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных));

			Если ТипТипМетаданных = Тип("Массив") Тогда
				Попытка
					Если ТипМетаданных.Количество() = 0 Тогда
						НетТипаМетаданных = Истина;
					КонецЕсли;
				Исключение
				КонецПопытки;
			КонецЕсли;

			Если НетТипаМетаданных И ПустаяСтрока(МаскаИмени) Тогда
				Возврат ПолучитьСводкуМетаданныхРасширения(НайденноеРасширение, КэшПараметры);
			КонецЕсли;

			Возврат ПолучитьСписокМетаданныхРасширения(НайденноеРасширение,
						ТипМетаданных, МаскаИмени, Лимит, Смещение, КэшПараметры);
		КонецЕсли;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСводкуМетаданныхРасширения(Расширение, КэшПараметры = Неопределено)
	// Возвращает summary по корневым типам ВНУТРИ расширения:
	// {success: true, data: [{Тип, Количество}...], configuration: {...}, extension: "ИмяРасширения"}

	Попытка
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		ТокенИндекса = Неопределено;
		Индекс = Неопределено;

		// 1) Попытка использовать кэш индекса (ВременноеХранилище) если хеш совпадает
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash")
					И КэшПараметры.hash = ТекущийХеш Тогда

					Если КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;

					Если КэшПараметры.Свойство("index_token")
						И КэшПараметры.index_token <> Неопределено Тогда

						ТокенИндекса = КэшПараметры.index_token;
						КэшИндекс = Неопределено;
						Попытка
							КэшИндекс = ПолучитьИзВременногоХранилища(ТокенИндекса);
						Исключение
							КэшИндекс = Неопределено;
						КонецПопытки;

						Если КэшИндекс <> Неопределено
							И ТипЗнч(КэшИндекс) = Тип("ТаблицаЗначений") Тогда
							Индекс = КэшИндекс;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// 2) Если индекса нет - строим/получаем заново (используя кэш ДвоичныхДанных, если он есть)
		Если Индекс = Неопределено Тогда
			РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
			Если НЕ РезМД.success Тогда
				Возврат Новый Структура("success, error", Ложь, РезМД.error);
			КонецЕсли;

			ТекущийХеш = РезМД.hash;
			ТокенДанных = РезМД.data_token;

			Если РезМД.is_empty Тогда
				// Пустое расширение: все типы по 0
				Счетчики = Новый Соответствие;
				Для Каждого ОписаниеТипа Из ПолучитьКорневыеТипыМетаданных() Цикл
					Счетчики.Вставить(ОписаниеТипа.Тип, 0);
				КонецЦикла;

				Сводка = Новый Массив;
				Для Каждого ОписаниеТипа Из ПолучитьКорневыеТипыМетаданных() Цикл
					Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, 0));
				КонецЦикла;

				ИнфоКонф = ПолучитьИнформациюОКонфигурации();
				Результат = Новый Структура("success, data, configuration, extension", Истина, Сводка, ИнфоКонф, Расширение.Имя);

				// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
				Результат.Вставить("mcp_cache_hash", ТекущийХеш);
				Если ТокенДанных <> Неопределено Тогда
					Результат.Вставить("mcp_cache_data_token", ТокенДанных);
				КонецЕсли;

				Возврат Результат;
			КонецЕсли;

			Индекс = РезМД.index;
			Если Индекс = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Не удалось построить индекс метаданных расширения");
			КонецЕсли;

			// Кэшируем индекс во ВременномХранилище (best effort)
			Попытка
				ТокенИндекса = ПоместитьВоВременноеХранилище(Индекс);
			Исключение
				ТокенИндекса = Неопределено;
			КонецПопытки;
		КонецЕсли;

		// 3) Подсчет по типам (одним проходом по индексу)
		Счетчики = Новый Соответствие;
		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Счетчики.Вставить(ОписаниеТипа.Тип, 0);
		КонецЦикла;

		Для Каждого СтрИндекса Из Индекс Цикл
			ТипСтроки = "";
			Попытка
				ТипСтроки = Строка(СтрИндекса.Тип);
			Исключение
				ТипСтроки = "";
			КонецПопытки;

			Если ПустаяСтрока(ТипСтроки) Тогда
				Продолжить;
			КонецЕсли;

			Текущее = Счетчики.Получить(ТипСтроки);
			Если Текущее = Неопределено Тогда
				Счетчики.Вставить(ТипСтроки, 1);
			Иначе
				Счетчики.Вставить(ТипСтроки, Текущее + 1);
			КонецЕсли;
		КонецЦикла;

		Сводка = Новый Массив;
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Кол = Счетчики.Получить(ОписаниеТипа.Тип);
			Если Кол = Неопределено Тогда
				Кол = 0;
			КонецЕсли;
			Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, Кол));
		КонецЦикла;

		ИнфоКонф = ПолучитьИнформациюОКонфигурации();
		Результат = Новый Структура("success, data, configuration, extension", Истина, Сводка, ИнфоКонф, Расширение.Имя);

		// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенИндекса <> Неопределено Тогда
			Результат.Вставить("mcp_cache_index_token", ТокенИндекса);
		КонецЕсли;

		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокМетаданныхРасширения(Расширение, ТипМетаданных, МаскаИмени, Лимит, Смещение, КэшПараметры = Неопределено)
	// Возвращает список объектов метаданных внутри расширения (list-режим с пагинацией)

	Попытка
		// list-режим расширения: используем кэш индекса (ТаблицаЗначений) во ВременномХранилище, если доступен.
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		ТокенИндекса = Неопределено;
		Индекс = Неопределено;
		
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash")
					И КэшПараметры.hash = ТекущийХеш
					И КэшПараметры.Свойство("index_token")
					И КэшПараметры.index_token <> Неопределено Тогда
					
					ТокенИндекса = КэшПараметры.index_token;
					Попытка
						КэшИндекс = ПолучитьИзВременногоХранилища(ТокенИндекса);
					Исключение
						КэшИндекс = Неопределено;
					КонецПопытки;
					
					Если КэшИндекс <> Неопределено И ТипЗнч(КэшИндекс) = Тип("ТаблицаЗначений") Тогда
						Индекс = КэшИндекс;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		// Если индекса нет в кэше - строим заново (используя кэш ДвоичныхДанных, если он есть)
		Если Индекс = Неопределено Тогда
			РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
			Если НЕ РезМД.success Тогда
				Возврат Новый Структура("success, error", Ложь, РезМД.error);
			КонецЕсли;
			
			ТекущийХеш = РезМД.hash;
			ТокенДанных = РезМД.data_token;
			
			// Пустое расширение: объектов нет
			Если РезМД.is_empty Тогда
				Результат = Новый Структура;
				Результат.Вставить("success", Истина);
				Результат.Вставить("data", Новый Массив);
				Результат.Вставить("extension", Расширение.Имя);
				Результат.Вставить("truncated", Ложь);
				Результат.Вставить("limit", Лимит);
				Результат.Вставить("returned", 0);
				Результат.Вставить("count", 0);
				Результат.Вставить("offset", Смещение);
				Результат.Вставить("has_more", Ложь);
				Результат.Вставить("next_offset", Смещение);
				Результат.Вставить("mcp_cache_hash", ТекущийХеш);
				Если ТокенДанных <> Неопределено Тогда
					Результат.Вставить("mcp_cache_data_token", ТокенДанных);
				КонецЕсли;
				Возврат Результат;
			КонецЕсли;
			
			Индекс = РезМД.index;
			Если Индекс = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Не удалось построить индекс метаданных расширения");
			КонецЕсли;
			
			// Кэшируем индекс во ВременномХранилище (best effort)
			Попытка
				ТокенИндекса = ПоместитьВоВременноеХранилище(Индекс);
			Исключение
				ТокенИндекса = Неопределено;
			КонецПопытки;
		Иначе
			// Индекс пришёл из кэша; попытаемся вернуть токен ДвоичныхДанных для обновления клиентского кэша (если передан)
			Если КэшПараметры <> Неопределено Тогда
				Попытка
					Если КэшПараметры.Свойство("hash") И КэшПараметры.hash = ТекущийХеш
						И КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;

		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();

		// ТипМетаданных может быть строкой ("Документ", "*") или массивом строк
		ТипыДляОбработки = Новый Массив;
		ТипТипМетаданных = ТипЗнч(ТипМетаданных);
		
		Если ТипМетаданных = Неопределено Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных)) Тогда
			ТипМетаданных = "*";
			ТипТипМетаданных = Тип("Строка");
		КонецЕсли;
		
		Если ТипТипМетаданных = Тип("Строка") Тогда
			
			Если ТипМетаданных = "*" Тогда
				ТипыДляОбработки = КорневыеТипы;
			Иначе
				ОписаниеЗапрошенногоТипа = Неопределено;
				Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
					Если ОписаниеТипа.Тип = ТипМетаданных Тогда
						ОписаниеЗапрошенногоТипа = ОписаниеТипа;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
					Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ТипМетаданных);
				КонецЕсли;
				
				ТипыДляОбработки.Добавить(ОписаниеЗапрошенногоТипа);
			КонецЕсли;
			
		ИначеЕсли ТипТипМетаданных = Тип("Массив") Тогда
			
			ЗапрошеныВсеТипы = Ложь;
			Уникальные = Новый Соответствие;
			
			Попытка
				Для Каждого ИмяТипа Из ТипМетаданных Цикл
					ИмяТипа = СокрЛП(Строка(ИмяТипа));
					Если ПустаяСтрока(ИмяТипа) Тогда
						Продолжить;
					КонецЕсли;
					Если ИмяТипа = "*" Тогда
						ЗапрошеныВсеТипы = Истина;
						Прервать;
					КонецЕсли;
					Уникальные.Вставить(ИмяТипа, Истина);
				КонецЦикла;
			Исключение
				Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
			КонецПопытки;
			
			Если ЗапрошеныВсеТипы Тогда
				ТипыДляОбработки = КорневыеТипы;
			Иначе
				Для Каждого Пара Из Уникальные Цикл
					ИмяТипа = Пара.Ключ;
					ОписаниеЗапрошенногоТипа = Неопределено;
					Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
						Если ОписаниеТипа.Тип = ИмяТипа Тогда
							ОписаниеЗапрошенногоТипа = ОписаниеТипа;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
					Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
						Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ИмяТипа);
					КонецЕсли;
					
					ТипыДляОбработки.Добавить(ОписаниеЗапрошенногоТипа);
				КонецЦикла;
			КонецЕсли;
			
		Иначе
			Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
		КонецЕсли;

		// Быстрый фильтр по типам (если не "*")
		РазрешенныеТипы = Неопределено;
		Если НЕ (ТипТипМетаданных = Тип("Строка") И ТипМетаданных = "*") Тогда
			РазрешенныеТипы = Новый Соответствие;
			Для Каждого ОписаниеТипа Из ТипыДляОбработки Цикл
				РазрешенныеТипы.Вставить(ОписаниеТипа.Тип, Истина);
			КонецЦикла;
		КонецЕсли;

		Если Смещение < 0 Тогда
			Смещение = 0;
		КонецЕсли;

		МаскаВерхнийРегистр = "";
		Если МаскаИмени <> Неопределено Тогда
			Попытка
				МаскаВерхнийРегистр = ВРег(МаскаИмени);
			Исключение
				МаскаВерхнийРегистр = "";
			КонецПопытки;
		КонецЕсли;

		РезультатСписок = Новый Массив;
		ВсегоПодходящих = 0;
		Возвращено = 0;
		ЕстьЕще = Ложь;

		Для Каждого СтрИндекса Из Индекс Цикл
			Если РазрешенныеТипы <> Неопределено Тогда
				Если РазрешенныеТипы.Получить(СтрИндекса.Тип) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;

			Если НЕ ПрошелФильтрПоМаске(СтрИндекса.Имя, СтрИндекса.Синоним, МаскаВерхнийРегистр) Тогда
				Продолжить;
			КонецЕсли;

			// ВАЖНО: count должен быть точным, поэтому не прерываем обход после набора страницы.
			// После достижения лимита перестаём добавлять элементы в data, но продолжаем считать ВсегоПодходящих.
			Если ВсегоПодходящих >= Смещение И Возвращено < Лимит Тогда
				РезультатСписок.Добавить(Новый Структура("ПолноеИмя, Синоним", СтрИндекса.ПолноеИмя, СтрИндекса.Синоним));
				Возвращено = Возвращено + 1;
			КонецЕсли;

			ВсегоПодходящих = ВсегоПодходящих + 1;
		КонецЦикла;

		ЕстьЕще = (Смещение + Возвращено) < ВсегоПодходящих;
		Обрезано = ЕстьЕще;
		СледующееСмещение = Смещение + Возвращено;

		Результат = Новый Структура;
		Результат.Вставить("success", Истина);
		Результат.Вставить("data", РезультатСписок);
		Результат.Вставить("extension", Расширение.Имя);
		Результат.Вставить("truncated", Обрезано);
		Результат.Вставить("limit", Лимит);
		Результат.Вставить("returned", Возвращено);
		Результат.Вставить("count", ВсегоПодходящих);
		Результат.Вставить("offset", Смещение);
		Результат.Вставить("has_more", Обрезано);
		Результат.Вставить("next_offset", СледующееСмещение);
		
		// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенИндекса <> Неопределено Тогда
			Результат.Вставить("mcp_cache_index_token", ТокенИндекса);
		КонецЕсли;
		
		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеРасширения(Расширение, Фильтр, Секции, КэшПараметры = Неопределено)
	// Возвращает детальную структуру объекта метаданных внутри расширения (details-режим)

	Попытка
		// Парсим Фильтр: "ТипМетаданных.ИмяОбъекта[.ОстатокПути]"
		ПозицияТочки = Найти(Фильтр, ".");
		Если ПозицияТочки = 0 Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Неверный формат фильтра: " + Фильтр + ". Ожидается 'ТипМетаданных.ИмяОбъекта'");
		КонецЕсли;

		ТипОбъекта = Лев(Фильтр, ПозицияТочки - 1);
		ОстатокПослеТипа = Сред(Фильтр, ПозицияТочки + 1);

		// Ищем вторую точку — она отделяет ИмяОбъекта от пути к элементу коллекции
		ПозицияВторойТочки = Найти(ОстатокПослеТипа, ".");
		Если ПозицияВторойТочки = 0 Тогда
			// Формат "Тип.Объект" — стандартное поведение
			ИмяОбъекта = ОстатокПослеТипа;
			ОстатокПутиЭлемента = "";
		Иначе
			ИмяОбъекта = Лев(ОстатокПослеТипа, ПозицияВторойТочки - 1);
			ОстатокПутиЭлемента = Сред(ОстатокПослеТипа, ПозицияВторойТочки + 1);
		КонецЕсли;

		// Находим коллекцию по типу
		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
		ИмяКоллекции = "";
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Если ОписаниеТипа.Тип = ТипОбъекта Тогда
				ИмяКоллекции = ОписаниеТипа.Коллекция;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если ПустаяСтрока(ИмяКоллекции) Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Неизвестный тип метаданных: " + ТипОбъекта);
		КонецЕсли;
		
		// Попытка взять details-ответ из кэша (ВременноеХранилище) если хеш расширения совпадает
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash") И КэшПараметры.hash = ТекущийХеш Тогда
					Если КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;
					
					Если КэшПараметры.Свойство("details_token") И КэшПараметры.details_token <> Неопределено Тогда
						ТокенДеталей = КэшПараметры.details_token;
						КэшДетали = Неопределено;
						Попытка
							КэшДетали = ПолучитьИзВременногоХранилища(ТокенДеталей);
						Исключение
							КэшДетали = Неопределено;
						КонецПопытки;
						
						Если КэшДетали <> Неопределено И ТипЗнч(КэшДетали) = Тип("Структура") Тогда
							Если КэшДетали.Свойство("success") И КэшДетали.success Тогда
								// Лёгкая валидация: если в data есть ПолноеИмя, сверим с запрошенным
								Попытка
									Если КэшДетали.Свойство("data")
										И ТипЗнч(КэшДетали.data) = Тип("Структура")
										И КэшДетали.data.Свойство("ПолноеИмя")
										И КэшДетали.data.ПолноеИмя <> Фильтр Тогда
										КэшДетали = Неопределено;
									КонецЕсли;
								Исключение
								КонецПопытки;
							Иначе
								КэшДетали = Неопределено;
							КонецЕсли;
						Иначе
							КэшДетали = Неопределено;
						КонецЕсли;
						
						Если КэшДетали <> Неопределено Тогда
							КэшДетали.Вставить("mcp_cache_hash", ТекущийХеш);
							КэшДетали.Вставить("mcp_cache_details_token", ТокенДеталей);
							Если ТокенДанных <> Неопределено Тогда
								КэшДетали.Вставить("mcp_cache_data_token", ТокенДанных);
							КонецЕсли;
							Возврат КэшДетали;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Получаем метаданные расширения из бинарных данных (GetData) и коллекцию из них.
		// Это даёт корректный результат и совпадает по формату с основной конфигурацией.
		РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
		Если НЕ РезМД.success Тогда
			Возврат Новый Структура("success, error", Ложь, РезМД.error);
		КонецЕсли;
		
		ТекущийХеш = РезМД.hash;
		ТокенДанных = РезМД.data_token;

		Если РезМД.is_empty Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Объект не найден в расширении (расширение пустое): " + Фильтр);
		КонецЕсли;

		МетаданныеРасширения = РезМД.metadata;
		Если МетаданныеРасширения = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь, "Не удалось получить метаданные расширения");
		КонецЕсли;

		КоллекцияВРасширении = Неопределено;
		Попытка
			КоллекцияВРасширении = Вычислить("МетаданныеРасширения." + ИмяКоллекции);
		Исключение
			КоллекцияВРасширении = Неопределено;
		КонецПопытки;

		Если КоллекцияВРасширении = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Коллекция " + ИмяКоллекции + " недоступна в метаданных расширения " + Расширение.Имя);
		КонецЕсли;

		// Ищем объект по имени
		ОбъектМД = Неопределено;
		Для Каждого ТекОбъект Из КоллекцияВРасширении Цикл
			Если ТекОбъект.Имя = ИмяОбъекта Тогда
				ОбъектМД = ТекОбъект;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если ОбъектМД = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Объект не найден в расширении: " + Фильтр);
		КонецЕсли;

		// Навигация к элементу коллекции (если filter указывает глубже Тип.Объект)
		Если НЕ ПустаяСтрока(ОстатокПутиЭлемента) Тогда
			ЭлементМД = НайтиЭлементВКоллекцииОбъекта(ОбъектМД, ОстатокПутиЭлемента);
			Если ЭлементМД = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь,
					"Элемент не найден в расширении: " + Фильтр);
			КонецЕсли;
			Возврат ПолучитьДетальныеМетаданныеЭлементаРасширения(ЭлементМД, Фильтр, Секции, Расширение, ТекущийХеш, ТокенДанных);
		КонецЕсли;

		// Формируем детальную структуру объекта
		ИнформацияОбОбъекте = Новый Структура;
		ИнформацияОбОбъекте.Вставить("ТипОбъектаМетаданных", ТипОбъекта);
		ИнформацияОбОбъекте.Вставить("Имя", ОбъектМД.Имя);
		ИнформацияОбОбъекте.Вставить("Синоним", ОбъектМД.Синоним);
		
		ПолноеИмяФакт = Фильтр;
		Попытка
			ПолноеИмяФакт = ОбъектМД.ПолноеИмя();
		Исключение
			ПолноеИмяФакт = Фильтр;
		КонецПопытки;
		ИнформацияОбОбъекте.Вставить("ПолноеИмя", ПолноеИмяФакт);

		// Маркеры расширений: берём ТОЛЬКО из объекта метаданных расширения (ОбъектМетаданныхКонфигурация),
		// чтобы показать "Заимствованный/Собственный" в контексте расширения, а не рантайм-смёрженные метаданные.
		МеткиРасширений = ПолучитьExtensionMarksИзМетаданныхРасширения(ОбъектМД);
		Если МеткиРасширений <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("extension_marks", МеткиРасширений);
		КонецЕсли;

		// Реквизиты
		Реквизиты = Новый Массив;
		ЕстьКоллекцияРеквизитов = Ложь;

		// Стандартные реквизиты (Код, Наименование, Ссылка и т.д.)
		Попытка
			КоллекцияСтдРеквизитов = ОбъектМД.СтандартныеРеквизиты;
			ЕстьКоллекцияРеквизитов = Истина;
			Для Каждого СтдРеквизит Из КоллекцияСтдРеквизитов Цикл
				Попытка
					СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
						СтдРеквизит.Имя,
						СтдРеквизит.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип),
						Истина);

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(СтдРеквизит);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					Реквизиты.Добавить(СтрокаРеквизита);
				Исключение
					// Пропускаем проблемный стандартный реквизит
				КонецПопытки;
			КонецЦикла;
		Исключение
			// У объекта нет коллекции СтандартныеРеквизиты
		КонецПопытки;

		// Пользовательские реквизиты
		Попытка
			КоллекцияРеквизитов = ОбъектМД.Реквизиты;
			ЕстьКоллекцияРеквизитов = Истина;
			Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
					Реквизит.Имя,
					Реквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип),
					Ложь);

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;

				Реквизиты.Добавить(СтрокаРеквизита);
			КонецЦикла;
		Исключение
			// У некоторых объектов нет пользовательских реквизитов
		КонецПопытки;

		Если ЕстьКоллекцияРеквизитов Тогда
			ИнформацияОбОбъекте.Вставить("Реквизиты", Реквизиты);
		КонецЕсли;

		// Реквизиты адресации (для задач)
		Если ТипОбъекта = "Задача" Тогда
			РеквизитыАдресации = Неопределено;
			Попытка
				РеквизитыАдресации = Новый Массив;
				Для Каждого РеквизитАдресации Из ОбъектМД.РеквизитыАдресации Цикл
					СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
						РеквизитАдресации.Имя,
						РеквизитАдресации.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(РеквизитАдресации.Тип));

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(РеквизитАдресации);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					РеквизитыАдресации.Добавить(СтрокаРеквизита);
				КонецЦикла;
			Исключение
				// Секция не применима/недоступна
				РеквизитыАдресации = Неопределено;
			КонецПопытки;

			Если РеквизитыАдресации <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("РеквизитыАдресации", РеквизитыАдресации);
			КонецЕсли;
		КонецЕсли;

		// Табличные части
		Попытка
			ТабличныеЧасти = Новый Массив;
			Для Каждого ТабличнаяЧасть Из ОбъектМД.ТабличныеЧасти Цикл
				РеквизитыТЧ = Новый Массив;
				Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
					СтрокаРеквизитаТЧ = Новый Структура("Имя, Синоним, Тип",
						Реквизит.Имя,
						Реквизит.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизитаТЧ.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;
					
					РеквизитыТЧ.Добавить(СтрокаРеквизитаТЧ);
				КонецЦикла;
				
				СтрокаТЧ = Новый Структура("Имя, Синоним, Реквизиты",
					ТабличнаяЧасть.Имя,
					ТабличнаяЧасть.Синоним,
					РеквизитыТЧ);
				
				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(ТабличнаяЧасть);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаТЧ.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				ТабличныеЧасти.Добавить(СтрокаТЧ);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("ТабличныеЧасти", ТабличныеЧасти);
		Исключение
			// У некоторых объектов нет табличных частей
		КонецПопытки;

		// Измерения (для регистров)
		Попытка
			Измерения = Новый Массив;
			Для Каждого Измерение Из ОбъектМД.Измерения Цикл
				СтрокаИзмерения = Новый Структура("Имя, Синоним, Тип",
					Измерение.Имя,
					Измерение.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Измерение.Тип));

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Измерение);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаИзмерения.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				Измерения.Добавить(СтрокаИзмерения);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("Измерения", Измерения);
		Исключение
			// У некоторых объектов нет измерений
		КонецПопытки;

		// Ресурсы (для регистров)
		Попытка
			Ресурсы = Новый Массив;
			Для Каждого Ресурс Из ОбъектМД.Ресурсы Цикл
				СтрокаРесурса = Новый Структура("Имя, Синоним, Тип",
					Ресурс.Имя,
					Ресурс.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Ресурс.Тип));

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Ресурс);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаРесурса.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				Ресурсы.Добавить(СтрокаРесурса);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("Ресурсы", Ресурсы);
		Исключение
			// У некоторых объектов нет ресурсов
		КонецПопытки;

		// Значения перечисления
		Если ТипОбъекта = "Перечисление" Тогда
			Попытка
				ЗначенияПеречисления = Новый Массив;
				Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
					ЗначенияПеречисления.Добавить(Новый Структура("Имя, Синоним",
						ЗначениеПеречисления.Имя,
						ЗначениеПеречисления.Синоним));
				КонецЦикла;
				ИнформацияОбОбъекте.Вставить("ЗначенияПеречисления", ЗначенияПеречисления);
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Владельцы (для подчинённых справочников)
		Если ТипОбъекта = "Справочник" Тогда
			Попытка
				Если ОбъектМД.Владельцы.Количество() > 0 Тогда
					Владельцы = Новый Массив;
					Для Каждого Владелец Из ОбъектМД.Владельцы Цикл
						Владельцы.Добавить(Владелец.ПолноеИмя());
					КонецЦикла;
					ИнформацияОбОбъекте.Вставить("Владельцы", Владельцы);
				КонецЕсли;
			Исключение
				// У некоторых справочников нет владельцев
			КонецПопытки;
		КонецЕсли;

		// ПризнакиУчета и ПризнакиУчетаСубконто (только для планов счетов)
		Если ТипОбъекта = "ПланСчетов" Тогда
			Попытка
				КоллекцияПризнаков = ОбъектМД.ПризнакиУчета;
				Если КоллекцияПризнаков <> Неопределено Тогда
					МассивПризнаков = Новый Массив;
					Для Каждого Признак Из КоллекцияПризнаков Цикл
						МассивПризнаков.Добавить(Новый Структура("Имя, Синоним, Тип",
							Признак.Имя, Признак.Синоним,
							ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
					КонецЦикла;
					Если МассивПризнаков.Количество() > 0 Тогда
						ИнформацияОбОбъекте.Вставить("ПризнакиУчета", МассивПризнаков);
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;

			Попытка
				КоллекцияПризнаковСубконто = ОбъектМД.ПризнакиУчетаСубконто;
				Если КоллекцияПризнаковСубконто <> Неопределено Тогда
					МассивПризнаковСубконто = Новый Массив;
					Для Каждого Признак Из КоллекцияПризнаковСубконто Цикл
						МассивПризнаковСубконто.Добавить(Новый Структура("Имя, Синоним, Тип",
							Признак.Имя, Признак.Синоним,
							ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
					КонецЦикла;
					Если МассивПризнаковСубконто.Количество() > 0 Тогда
						ИнформацияОбОбъекте.Вставить("ПризнакиУчетаСубконто", МассивПризнаковСубконто);
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// СтандартныеТабличныеЧасти (для ПланСчетов и ПланВидовРасчета)
		Если ТипОбъекта = "ПланСчетов" ИЛИ ТипОбъекта = "ПланВидовРасчета" Тогда
			Попытка
				СтандартныеТабличныеЧасти = Новый Массив;
				Для Каждого СтдТЧ Из ОбъектМД.СтандартныеТабличныеЧасти Цикл
					РеквизитыСтдТЧ = Новый Массив;
					Попытка
						Для Каждого СтдРеквизит Из СтдТЧ.СтандартныеРеквизиты Цикл
							Попытка
								РеквизитыСтдТЧ.Добавить(Новый Структура("Имя, Синоним, Тип",
									СтдРеквизит.Имя,
									СтдРеквизит.Синоним,
									ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип)));
							Исключение
							КонецПопытки;
						КонецЦикла;
					Исключение
					КонецПопытки;

					СтрокаСтдТЧ = Новый Структура("Имя, Синоним, Реквизиты",
						СтдТЧ.Имя,
						СтдТЧ.Синоним,
						РеквизитыСтдТЧ);

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(СтдТЧ);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаСтдТЧ.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					СтандартныеТабличныеЧасти.Добавить(СтрокаСтдТЧ);
				КонецЦикла;
				Если СтандартныеТабличныеЧасти.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("СтандартныеТабличныеЧасти", СтандартныеТабличныеЧасти);
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Дополнительные секции детального ответа (управляемый "богатый" режим)
		Если СекцияЗапрошена(Секции, "properties") Тогда

			Свойства = Новый Структура;
			Кандидаты = Новый Массив;

			ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты);
			
			Для Каждого ИмяСвойства Из Кандидаты Цикл
				ЗначениеСвойства = Неопределено;
				Попытка
					ЗначениеСвойства = Вычислить("ОбъектМД." + ИмяСвойства);
				Исключение
					ЗначениеСвойства = Неопределено;
				КонецПопытки;
				
				Если ЗначениеСвойства <> Неопределено Тогда
					// Сериализация properties должна совпадать с основной конфигурацией:
					// сначала пытаемся получить ПолноеИмя() (или массив полных имён), иначе fallback.
					ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
					Если ЗначениеДляJSON = Неопределено Тогда
						ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
					КонецЕсли;
					Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
				КонецЕсли;
			КонецЦикла;
			
			ИнформацияОбОбъекте.Вставить("properties", Свойства);
			
		КонецЕсли;

		// Формы (если запрошена секция)
		Если СекцияЗапрошена(Секции, "forms") Тогда
			КоллекцияФорм = Неопределено;
			Попытка
				КоллекцияФорм = ОбъектМД.Формы;
			Исключение
				КоллекцияФорм = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияФорм <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("forms", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияФорм));
			КонецЕсли;
		КонецЕсли;

		// Команды (если запрошена секция)
		Если СекцияЗапрошена(Секции, "commands") Тогда
			КоллекцияКоманд = Неопределено;
			Попытка
				КоллекцияКоманд = ОбъектМД.Команды;
			Исключение
				КоллекцияКоманд = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияКоманд <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("commands", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияКоманд));
			КонецЕсли;
		КонецЕсли;

		// Макеты (если запрошена секция)
		Если СекцияЗапрошена(Секции, "layouts") Тогда
			КоллекцияМакетов = Неопределено;
			Попытка
				КоллекцияМакетов = ОбъектМД.Макеты;
			Исключение
				КоллекцияМакетов = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияМакетов <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("layouts", СекцияИзКоллекцииМакетов(КоллекцияМакетов));
			КонецЕсли;
		КонецЕсли;

		Если СекцияЗапрошена(Секции, "predefined") Тогда
			
			// 1) Если в рантайм-метаданных есть коллекция предопределенных - используем ее
			КоллекцияПредопределенных = Неопределено;
			Попытка
				КоллекцияПредопределенных = ОбъектМД.Предопределенные;
			Исключение
				КоллекцияПредопределенных = Неопределено;
			КонецПопытки;
			
			Если КоллекцияПредопределенных <> Неопределено Тогда
				Попытка
					ИнформацияОбОбъекте.Вставить("predefined", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияПредопределенных));
				Исключение
					// Если это не коллекция - игнорируем и пробуем fallback ниже
				КонецПопытки;
			КонецЕсли;
			
			// 2) Fallback для справочников: предопределенные данные хранятся как данные (отбор по Предопределенный)
			Если Не ИнформацияОбОбъекте.Свойство("predefined") И ТипОбъекта = "Справочник" Тогда
				ПредопределенныеДанные = ПолучитьПредопределенныеЭлементыСправочника(ИмяОбъекта, 200);
				Если ПредопределенныеДанные <> Неопределено Тогда
					ИнформацияОбОбъекте.Вставить("predefined", ПредопределенныеДанные);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;

		// Движения (только для документов — список регистров, в которых документ делает движения)
		Если СекцияЗапрошена(Секции, "movements") Тогда
			Если ТипОбъекта = "Документ" Тогда
				КоллекцияДвижений = Неопределено;
				Попытка
					КоллекцияДвижений = ОбъектМД.Движения;
				Исключение
					КоллекцияДвижений = Неопределено;
				КонецПопытки;

				Если КоллекцияДвижений <> Неопределено Тогда
					ИнформацияОбОбъекте.Вставить("movements", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияДвижений));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		// Характеристики (описания характеристик, привязанных к объекту метаданных)
		Если СекцияЗапрошена(Секции, "characteristics") Тогда
			КоллекцияХарактеристик = Неопределено;
			Попытка
				КоллекцияХарактеристик = ОбъектМД.Характеристики;
			Исключение
				КоллекцияХарактеристик = Неопределено;
			КонецПопытки;

			Если КоллекцияХарактеристик <> Неопределено Тогда
				МассивХарактеристик = Новый Массив;
				Для Каждого ОписаниеХарактеристики Из КоллекцияХарактеристик Цикл
					ЭлементХарактеристики = Новый Структура;

					// ВидыХарактеристик — ссылка на ПланВидовХарактеристик → ПолноеИмя()
					Попытка
						ВидыХар = ОписаниеХарактеристики.ВидыХарактеристик;
						Если ВидыХар <> Неопределено Тогда
							Попытка
								ЭлементХарактеристики.Вставить("ВидыХарактеристик", ВидыХар.ПолноеИмя());
							Исключение
								ЭлементХарактеристики.Вставить("ВидыХарактеристик", Строка(ВидыХар));
							КонецПопытки;
						КонецЕсли;
					Исключение
					КонецПопытки;

					// ЗначенияХарактеристик — ссылка на регистр сведений → ПолноеИмя()
					Попытка
						ЗначенияХар = ОписаниеХарактеристики.ЗначенияХарактеристик;
						Если ЗначенияХар <> Неопределено Тогда
							Попытка
								ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", ЗначенияХар.ПолноеИмя());
							Исключение
								ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", Строка(ЗначенияХар));
							КонецПопытки;
						КонецЕсли;
					Исключение
					КонецПопытки;

					// ЗначениеОтбораВидов — произвольный тип
					Попытка
						ЗначениеОтбора = ОписаниеХарактеристики.ЗначениеОтбораВидов;
						Если ЗначениеОтбора <> Неопределено Тогда
							ЭлементХарактеристики.Вставить("ЗначениеОтбораВидов",
								БезопасноеЗначениеДляПередачи(ЗначениеОтбора));
						КонецЕсли;
					Исключение
					КонецПопытки;

					// Поля (строковые свойства) — через Вычислить с безопасным доступом
					ПоляСтроковые = Новый Структура;
					ПоляСтроковые.Вставить("ПолеВида",                                "ПолеВида");
					ПоляСтроковые.Вставить("ПолеЗначения",                            "ПолеЗначения");
					ПоляСтроковые.Вставить("ПолеИспользованияМножественныхЗначений",  "ПолеИспользованияМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеКлюча",                               "ПолеКлюча");
					ПоляСтроковые.Вставить("ПолеКлючаМножественныхЗначений",          "ПолеКлючаМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеОбъекта",                             "ПолеОбъекта");
					ПоляСтроковые.Вставить("ПолеОтбораВидов",                         "ПолеОтбораВидов");
					ПоляСтроковые.Вставить("ПолеПорядкаМножественныхЗначений",        "ПолеПорядкаМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеПутиКДанным",                         "ПолеПутиКДанным");

					Для Каждого КлючЗначение Из ПоляСтроковые Цикл
						Попытка
							ЗначениеПоля = Вычислить("ОписаниеХарактеристики." + КлючЗначение.Значение);
							Если ЗначениеПоля <> Неопределено И Не ПустаяСтрока(Строка(ЗначениеПоля)) Тогда
								ЭлементХарактеристики.Вставить(КлючЗначение.Ключ, Строка(ЗначениеПоля));
							КонецЕсли;
						Исключение
						КонецПопытки;
					КонецЦикла;

					// Пропускаем пустые элементы (все поля = Неопределено/пустые)
					Если ЭлементХарактеристики.Количество() > 0 Тогда
						МассивХарактеристик.Добавить(ЭлементХарактеристики);
					КонецЕсли;
				КонецЦикла;

				Если МассивХарактеристик.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("characteristics", МассивХарактеристик);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Результат = Новый Структура;
		Результат.Вставить("success", Истина);
		Результат.Вставить("data", ИнформацияОбОбъекте);
		Результат.Вставить("extension", Расширение.Имя);
		
		// Кэшируем готовый details-ответ (best effort) и возвращаем токен для клиентского кэша
		ТокенДеталей = Неопределено;
		Попытка
			ТокенДеталей = ПоместитьВоВременноеХранилище(Результат);
		Исключение
			ТокенДеталей = Неопределено;
		КонецПопытки;
		
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенДеталей <> Неопределено Тогда
			Результат.Вставить("mcp_cache_details_token", ТокенДеталей);
		КонецЕсли;

		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеЭлементаРасширения(ОбъектМетаданных, ПолноеИмяФильтра, Секции, Расширение, ТекущийХеш, ТокенДанных)

	ИнформацияОбЭлементе = Новый Структура;
	ИнформацияОбЭлементе.Вставить("ПолноеИмя", ПолноеИмяФильтра);
	ИнформацияОбЭлементе.Вставить("Имя", ОбъектМетаданных.Имя);

	Попытка
		ИнформацияОбЭлементе.Вставить("Синоним", ОбъектМетаданных.Синоним);
	Исключение
	КонецПопытки;

	// Тип (описание типов) — есть у реквизитов, измерений, ресурсов
	Попытка
		ИнформацияОбЭлементе.Вставить("Тип",
			ПолучитьСтроковоеПредставлениеОписанияТипов(ОбъектМетаданных.Тип));
	Исключение
		// У некоторых элементов (ТабличнаяЧасть) нет свойства Тип
	КонецПопытки;

	// Для табличных частей — вернуть список реквизитов
	Попытка
		РеквизитыТЧ = Новый Массив;
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

			МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
			Если МеткиДочернего <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
			КонецЕсли;

			РеквизитыТЧ.Добавить(СтрокаРеквизита);
		КонецЦикла;
		ИнформацияОбЭлементе.Вставить("Реквизиты", РеквизитыТЧ);
	Исключение
		// Нет коллекции реквизитов (не ТабличнаяЧасть)
	КонецПопытки;

	// Extension marks
	МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(ОбъектМетаданных);
	Если МеткиДочернего <> Неопределено Тогда
		ИнформацияОбЭлементе.Вставить("extension_marks", МеткиДочернего);
	КонецЕсли;

	// Properties — расширенные свойства элемента
	Если СекцияЗапрошена(Секции, "properties") Тогда
		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты);

		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
			КонецПопытки;
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;

		ИнформацияОбЭлементе.Вставить("properties", Свойства);
	КонецЕсли;

	Результат = Новый Структура;
	Результат.Вставить("success", Истина);
	Результат.Вставить("data", ИнформацияОбЭлементе);
	Результат.Вставить("extension", Расширение.Имя);

	// Кэшируем (best effort)
	ТокенДеталей = Неопределено;
	Попытка
		ТокенДеталей = ПоместитьВоВременноеХранилище(Результат);
	Исключение
	КонецПопытки;

	Результат.Вставить("mcp_cache_hash", ТекущийХеш);
	Если ТокенДанных <> Неопределено Тогда
		Результат.Вставить("mcp_cache_data_token", ТокенДанных);
	КонецЕсли;
	Если ТокенДеталей <> Неопределено Тогда
		Результат.Вставить("mcp_cache_details_token", ТокенДеталей);
	КонецЕсли;

	Возврат Результат;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьКорневыеТипыМетаданных()
	
	// Список корневых типов метаданных (как в дереве конфигуратора).
	// Формат: Массив структур {Тип, Коллекция}, где Коллекция - имя свойства Метаданные.<Коллекция>.
	Типы = Новый Массив;
	
	// Общие
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Подсистема", "Подсистемы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийМодуль", "ОбщиеМодули"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПараметрСеанса", "ПараметрыСеанса"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Роль", "Роли"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийРеквизит", "ОбщиеРеквизиты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланОбмена", "ПланыОбмена"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "КритерийОтбора", "КритерииОтбора"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПодпискаНаСобытие", "ПодпискиНаСобытия"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегламентноеЗадание", "РегламентныеЗадания"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Бот", "Боты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ФункциональнаяОпция", "ФункциональныеОпции"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПараметрФункциональныхОпций", "ПараметрыФункциональныхОпций"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОпределяемыйТип", "ОпределяемыеТипы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ХранилищеНастроек", "ХранилищаНастроек"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяКоманда", "ОбщиеКоманды"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ГруппаКоманд", "ГруппыКоманд"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяФорма", "ОбщиеФормы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийМакет", "ОбщиеМакеты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяКартинка", "ОбщиеКартинки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WebСервис", "WebСервисы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "HTTPСервис", "HTTPСервисы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WSСсылка", "WSСсылки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WebSocketКлиент", "WebSocketКлиенты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "СервисИнтеграции", "СервисыИнтеграции"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ЭлементСтиля", "ЭлементыСтиля"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Стиль", "Стили"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Язык", "Языки"));
	
	// Прикладные
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Константа", "Константы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Справочник", "Справочники"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Документ", "Документы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ЖурналДокументов", "ЖурналыДокументов"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Перечисление", "Перечисления"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Отчет", "Отчеты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Обработка", "Обработки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланВидовХарактеристик", "ПланыВидовХарактеристик"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланСчетов", "ПланыСчетов"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланВидовРасчета", "ПланыВидовРасчета"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрСведений", "РегистрыСведений"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрНакопления", "РегистрыНакопления"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрБухгалтерии", "РегистрыБухгалтерии"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрРасчета", "РегистрыРасчета"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "БизнесПроцесс", "БизнесПроцессы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Задача", "Задачи"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ВнешнийИсточникДанных", "ВнешниеИсточникиДанных"));
	
	// Пользовательский тип (фиксируем по договорённости)
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПакетыXDTO", "ПакетыXDTO"));
	
	Возврат Типы;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСводкуМетаданных()
	
	Типы = ПолучитьКорневыеТипыМетаданных();
	Сводка = Новый Массив;
	
	Для Каждого ОписаниеТипа Из Типы Цикл
		
		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
		Количество = 0;
		Если Коллекция <> Неопределено Тогда
			Попытка
				Количество = Коллекция.Количество();
			Исключение
				Количество = 0;
			КонецПопытки;
		КонецЕсли;
		
		Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, Количество));
		
	КонецЦикла;
	
	ИнформацияОКонфигурации = ПолучитьИнформациюОКонфигурации();
	// Важно: data оставляем массивом (roots), чтобы в TOON-формате оставался табличный вывод.
	// Информацию о конфигурации возвращаем отдельным полем верхнего уровня.
	Возврат Новый Структура("success, data, configuration", Истина, Сводка, ИнформацияОКонфигурации);
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, Ключ)
	
	Если СтрокаСоединения = Неопределено Или ПустаяСтрока(СтрокаСоединения) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Пары = РазделитьСтрокуПоРазделителю(СтрокаСоединения, ";");
	
	Для Каждого Пара Из Пары Цикл
		
		Если ПустаяСтрока(Пара) Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРавно = Найти(Пара, "=");
		Если ПозицияРавно <= 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПараметра = СокрЛП(Лев(Пара, ПозицияРавно - 1));
		Если ИмяПараметра <> Ключ Тогда
			Продолжить;
		КонецЕсли;
		
		Значение = СокрЛП(Сред(Пара, ПозицияРавно + 1));
		
		// Убираем кавычки по краям, если есть
		Если СтрДлина(Значение) >= 2 Тогда
			Если Лев(Значение, 1) = Символ(34) И Прав(Значение, 1) = Символ(34) Тогда
				Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);
			КонецЕсли;
		КонецЕсли;
		
		Если ПустаяСтрока(Значение) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Значение;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяИБПоСтрокеСоединения(СтрокаСоединения)
	
	// Серверная ИБ: Srvr="...";Ref="MyBase";
	ИмяИБ = ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, "Ref");
	Если ИмяИБ <> Неопределено Тогда
		Возврат ИмяИБ;
	КонецЕсли;
	
	// Файловая ИБ: File="D:\Bases\MyBase";
	ПутьИБ = ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, "File");
	Если ПутьИБ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Возвращаем только последний сегмент пути (без раскрытия полного пути)
	РазделительПути = Символ(92); // обратный слеш
	ПутьИБ = СтрЗаменить(ПутьИБ, "/", РазделительПути);
	
	ПозицияПоследняя = 0;
	
	// В режиме совместимости 8.2 третий параметр Найти() может быть недоступен,
	// поэтому ищем последний разделитель простым проходом по строке.
	ДлинаПути = СтрДлина(ПутьИБ);
	Для Индекс = 1 По ДлинаПути Цикл
		Если Сред(ПутьИБ, Индекс, 1) = РазделительПути Тогда
			ПозицияПоследняя = Индекс;
		КонецЕсли;
	КонецЦикла;
	
	Если ПозицияПоследняя > 0 И ПозицияПоследняя < СтрДлина(ПутьИБ) Тогда
		ИмяИБ = Сред(ПутьИБ, ПозицияПоследняя + 1);
	Иначе
		ИмяИБ = ПутьИБ;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяИБ) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ИмяИБ;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИнформациюОКонфигурации()
	
	Инфо = Новый Структура;
	
	// Версия платформы (очень полезно для диагностики)
	Попытка
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо <> Неопределено Тогда
			ВерсияПлатформы = СисИнфо.ВерсияПриложения;
			Если ВерсияПлатформы <> Неопределено И Не ПустаяСтрока(ВерсияПлатформы) Тогда
				Инфо.Вставить("platform_version", БезопасноеЗначениеДляПередачи(Строка(ВерсияПлатформы)));
			КонецЕсли;
		КонецЕсли;
	Исключение
		// нет
	КонецПопытки;
	
	// Имя ИБ (часто полезно как контекст; без путей/адресов)
	Попытка
		СтрСоед = Вычислить("СтрокаСоединенияИнформационнойБазы()");
		Если СтрСоед <> Неопределено И Не ПустаяСтрока(СтрСоед) Тогда
			ИмяИБ = ПолучитьИмяИБПоСтрокеСоединения(СтрСоед);
			Если ИмяИБ <> Неопределено И Не ПустаяСтрока(ИмяИБ) Тогда
				Инфо.Вставить("infobase_name", БезопасноеЗначениеДляПередачи(ИмяИБ));
			КонецЕсли;
		КонецЕсли;
	Исключение
		// нет
	КонецПопытки;
	
	// Пытаемся получить объект метаданных конфигурации (если доступен)
	ОбъектКонфигурации = Неопределено;
	Попытка
		ОбъектКонфигурации = Метаданные.Конфигурация;
	Исключение
		ОбъектКонфигурации = Неопределено;
	КонецПопытки;
	
	Если ОбъектКонфигурации = Неопределено Тогда
		// На некоторых версиях/режимах может быть доступен только корневой объект Метаданные
		ОбъектКонфигурации = Метаданные;
	КонецЕсли;
	
	Свойства = Новый Структура;
	Кандидаты = Новый Массив;
	
	// Базовые/ожидаемые свойства конфигурации (если доступны в рантайме)
	Кандидаты.Добавить("Имя");
	Кандидаты.Добавить("Синоним");
	Кандидаты.Добавить("Комментарий");
	Кандидаты.Добавить("Поставщик");
	Кандидаты.Добавить("Версия");
	Кандидаты.Добавить("ВерсияКонфигурации");	
	Кандидаты.Добавить("ОсновнойЯзык");
	Кандидаты.Добавить("ОсновнойРежимЗапуска");
	Кандидаты.Добавить("РежимСовместимости");
	Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	Кандидаты.Добавить("РежимСовместимостиИнтерфейса");
	Кандидаты.Добавить("РежимИспользованияМодальности");
	Кандидаты.Добавить("РежимАвтонумерацииОбъектов");	
	Кандидаты.Добавить("РежимИспользованияБлочногоХраненияДвоичныхДанных");
	Кандидаты.Добавить("РежимИспользованияТабличныхПространствБазыДанных");
	Кандидаты.Добавить("ИспользоватьОбычныеФормыВУправляемомПриложении");
	Кандидаты.Добавить("ИспользоватьУправляемыеФормыВОбычномПриложении");

	Для Каждого ИмяСвойства Из Кандидаты Цикл
		ЗначениеСвойства = Неопределено;
		Попытка
			ЗначениеСвойства = Вычислить("ОбъектКонфигурации." + ИмяСвойства);
		Исключение
			ЗначениеСвойства = Неопределено;
		КонецПопытки;
		
		Если ЗначениеСвойства <> Неопределено Тогда
			Свойства.Вставить(ИмяСвойства, БезопасноеЗначениеДляПередачи(ЗначениеСвойства));
		КонецЕсли;
	КонецЦикла;
	
	Если Свойства.Количество() > 0 Тогда
		Инфо.Вставить("metadata", Свойства);
	КонецЕсли;
	
	Возврат Инфо;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокМетаданных(ТипМетаданных = "", МаскаИмени = "", Лимит = 100, Смещение = 0)
	
	// ТипМетаданных может быть строкой ("Документ", "*") или массивом строк (["Документ","РегистрСведений"])
	Типы = ПолучитьКорневыеТипыМетаданных();
	ТипыДляОбхода = Новый Массив;
	
	ТипТипМетаданных = ТипЗнч(ТипМетаданных);
	
	Если ТипМетаданных = Неопределено Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных)) Тогда
		ТипМетаданных = "*";
		ТипТипМетаданных = Тип("Строка");
	КонецЕсли;
	
	Если ТипТипМетаданных = Тип("Строка") Тогда
		
		Если ТипМетаданных = "*" Тогда
			ТипыДляОбхода = Типы;
		Иначе
			ОписаниеЗапрошенногоТипа = Неопределено;
			Для Каждого ОписаниеТипа Из Типы Цикл
				Если ОписаниеТипа.Тип = ТипМетаданных Тогда
					ОписаниеЗапрошенногоТипа = ОписаниеТипа;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ТипМетаданных);
			КонецЕсли;
			
			ТипыДляОбхода.Добавить(ОписаниеЗапрошенногоТипа);
		КонецЕсли;
		
	Иначе
		
		// Массив типов
		ЗапрошеныВсеТипы = Ложь;
		Уникальные = Новый Соответствие;
		
		Попытка
			Для Каждого ИмяТипа Из ТипМетаданных Цикл
				ИмяТипа = СокрЛП(Строка(ИмяТипа));
				Если ПустаяСтрока(ИмяТипа) Тогда
					Продолжить;
				КонецЕсли;
				Если ИмяТипа = "*" Тогда
					ЗапрошеныВсеТипы = Истина;
					Прервать;
				КонецЕсли;
				Уникальные.Вставить(ИмяТипа, Истина);
			КонецЦикла;
		Исключение
			Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
		КонецПопытки;
		
		Если ЗапрошеныВсеТипы Тогда
			ТипыДляОбхода = Типы;
		Иначе
			Для Каждого Пара Из Уникальные Цикл
				ИмяТипа = Пара.Ключ;
				ОписаниеЗапрошенногоТипа = Неопределено;
				Для Каждого ОписаниеТипа Из Типы Цикл
					Если ОписаниеТипа.Тип = ИмяТипа Тогда
						ОписаниеЗапрошенногоТипа = ОписаниеТипа;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
					Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ИмяТипа);
				КонецЕсли;
				
				ТипыДляОбхода.Добавить(ОписаниеЗапрошенногоТипа);
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	// Собираем все совпадения, сортируем по ПолноеИмя и делаем срез offset+limit
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("ПолноеИмя");
	Таблица.Колонки.Добавить("Синоним");
	Таблица.Колонки.Добавить("SortKey");
	
	МаскаВерхнийРегистр = "";
	Если МаскаИмени <> Неопределено Тогда
		Попытка
			МаскаВерхнийРегистр = ВРег(МаскаИмени);
		Исключение
			МаскаВерхнийРегистр = "";
		КонецПопытки;
	КонецЕсли;
	
	Для Каждого ОписаниеТипа Из ТипыДляОбхода Цикл
		
		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
		Если Коллекция = Неопределено Тогда
			// В режиме "*" пропускаем недоступные коллекции, иначе считаем ошибкой (тип явно запросили)
			Если (ТипТипМетаданных = Тип("Строка") И ТипМетаданных = "*") Тогда
				Продолжить;
			Иначе
				Возврат Новый Структура("success, error", Ложь,
					"Коллекция метаданных не найдена/недоступна: Метаданные." + ОписаниеТипа.Коллекция);
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого ОбъектМетаданных Из Коллекция Цикл
			
			Имя = "";
			Синоним = "";
			ПолноеИмя = "";
			
			Попытка
				Имя = ОбъектМетаданных.Имя;
			Исключение
				Имя = "";
			КонецПопытки;
			
			Попытка
				Синоним = ОбъектМетаданных.Синоним;
			Исключение
				Синоним = "";
			КонецПопытки;
			
			Если ПрошелФильтрПоМаске(Имя, Синоним, МаскаВерхнийРегистр) Тогда
				
				Попытка
					ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
				Исключение
					ПолноеИмя = "";
				КонецПопытки;
				
				Если ПустаяСтрока(ПолноеИмя) Тогда
					Если Не ПустаяСтрока(Имя) Тогда
						ПолноеИмя = ОписаниеТипа.Тип + "." + Имя;
					Иначе
						ПолноеИмя = ОписаниеТипа.Тип;
					КонецЕсли;
				КонецЕсли;
				
				Стр = Таблица.Добавить();
				Стр.ПолноеИмя = ПолноеИмя;
				Стр.Синоним = Синоним;
				Стр.SortKey = ВРег(ПолноеИмя);
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Таблица.Сортировать("SortKey, ПолноеИмя");
	
	Всего = Таблица.Количество();
	Если Смещение < 0 Тогда
		Смещение = 0;
	КонецЕсли;
	
	СписокОбъектов = Новый Массив;
	Возвращено = 0;
	
	Если Смещение < Всего Тогда
		ИндексПоследний = Мин(Смещение + Лимит - 1, Всего - 1);
		Для Индекс = Смещение По ИндексПоследний Цикл
			СтрокаТаблицы = Таблица.Получить(Индекс);
			СписокОбъектов.Добавить(Новый Структура("ПолноеИмя, Синоним", СтрокаТаблицы.ПолноеИмя, СтрокаТаблицы.Синоним));
			Возвращено = Возвращено + 1;
		КонецЦикла;
	КонецЕсли;
	
	ЕстьЕще = (Смещение + Возвращено) < Всего;
	СледующееСмещение = Смещение + Возвращено;
	
	Возврат Новый Структура("success, data, truncated, limit, returned, count, offset, has_more, next_offset",
		Истина,
		СписокОбъектов,
		ЕстьЕще,
		Лимит,
		Возвращено,
		Всего,
		Смещение,
		ЕстьЕще,
		СледующееСмещение);
	
КонецФункции

&НаСервереБезКонтекста
Функция ПрошелФильтрПоМаске(Имя, Синоним, МаскаВерхнийРегистр)
	
	Если ПустаяСтрока(МаскаВерхнийРегистр) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Найти(ВРег(Имя), МаскаВерхнийРегистр) > 0 
		Или Найти(ВРег(Синоним), МаскаВерхнийРегистр) > 0;
	
КонецФункции


&НаСервереБезКонтекста
Функция СекцияЗапрошена(Секции, ИмяСекции)
	
	Если Секции = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Для Каждого Секция Из Секции Цикл
			Если ВРег(Строка(Секция)) = ВРег(ИмяСекции) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	Исключение
		// Некорректный формат sections
	КонецПопытки;
	
	Возврат Ложь;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолноеИмяМетаданныхЕслиВозможно(Значение, Глубина = 0)
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Глубина > 5 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Универсальный способ: пробуем метод ПолноеИмя() (для MetadataObject/ОбъектМетаданных).
	// Если метода нет или он недоступен — вернём Неопределено, и дальше будет fallback через БезопасноеЗначениеДляПередачи().
	ПолноеИмя = "";
	Попытка
		ПолноеИмя = Значение.ПолноеИмя();
	Исключение
		ПолноеИмя = "";
	КонецПопытки;
	
	Если НЕ ПустаяСтрока(ПолноеИмя) Тогда
		Возврат ПолноеИмя;
	КонецЕсли;

	// Если это коллекция (в т.ч. коллекция метаданных), попробуем обойти её и собрать ПолныеИмёна элементов.
	МассивПолныхИмен = Новый Массив;
	Попытка
		Для Каждого ЭлементКоллекции Из Значение Цикл
			ЗначениеЭлемента = ПолноеИмяМетаданныхЕслиВозможно(ЭлементКоллекции, Глубина + 1);
			Если ЗначениеЭлемента = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(ЗначениеЭлемента) = Тип("Массив") Тогда
				Для Каждого ЭлементМассива Из ЗначениеЭлемента Цикл
					Если ЭлементМассива <> Неопределено И НЕ ПустаяСтрока(Строка(ЭлементМассива)) Тогда
						МассивПолныхИмен.Добавить(ЭлементМассива);
					КонецЕсли;
				КонецЦикла;
			Иначе
				Если НЕ ПустаяСтрока(Строка(ЗначениеЭлемента)) Тогда
					МассивПолныхИмен.Добавить(ЗначениеЭлемента);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		МассивПолныхИмен = Неопределено;
	КонецПопытки;
	
	Если МассивПолныхИмен <> Неопределено И МассивПолныхИмен.Количество() > 0 Тогда
		Возврат МассивПолныхИмен;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции


&НаСервереБезКонтекста
Процедура ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты)

	// Общие свойства (подставляются где доступны)
	Кандидаты.Добавить("Комментарий");

	Если ТипОбъекта = "ПодпискаНаСобытие" Тогда
		Кандидаты.Добавить("Источник");
		Кандидаты.Добавить("Обработчик");
		Кандидаты.Добавить("Событие");
	ИначеЕсли ТипОбъекта = "БизнесПроцесс" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("Задача");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ПривилегированныйРежимПриСозданииЗадач");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "Задача" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("АвтоПрефиксНомераЗадачи");
		Кандидаты.Добавить("Адресация");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ОсновнойРеквизитАдресации");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "Справочник" Тогда
		Кандидаты.Добавить("Иерархический");
		Кандидаты.Добавить("ВидИерархии");
		Кандидаты.Добавить("ИспользованиеПодчинения");
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ТипКода");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ИсторияДанных");
	ИначеЕсли ТипОбъекта = "Документ" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ТипНомера");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("Нумератор");
		Кандидаты.Добавить("Нумерация");
		Кандидаты.Добавить("ОперативноеПроведение");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ПривилегированныйРежимПриОтменеПроведения");
		Кандидаты.Добавить("ПривилегированныйРежимПриПроведении");
		Кандидаты.Добавить("Проведение");
		Кандидаты.Добавить("УдалениеДвижений");
		Кандидаты.Добавить("ЗаполнениеПоследовательностей");
		Кандидаты.Добавить("ЗаписьДвиженийПриПроведении");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ИсторияДанных");
	ИначеЕсли ТипОбъекта = "РегистрСведений" Тогда
		Кандидаты.Добавить("Периодичность");
		Кандидаты.Добавить("РежимЗаписи");
		Кандидаты.Добавить("ПериодичностьРегистраСведений");
		Кандидаты.Добавить("ОсновнойОтборПоПериоду");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("РазрешитьИтогиСрезПервых");
		Кандидаты.Добавить("РазрешитьИтогиСрезПоследних");
	ИначеЕсли ТипОбъекта = "РегистрНакопления" Тогда
		Кандидаты.Добавить("ВидРегистра");
		Кандидаты.Добавить("РазрешитьРазделениеИтогов");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "РегистрБухгалтерии" Тогда
		Кандидаты.Добавить("ПланСчетов");
		Кандидаты.Добавить("ДлинаУточненияПериода");
		Кандидаты.Добавить("Корреспонденция");
		Кандидаты.Добавить("РазрешитьРазделениеИтогов");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "ПланСчетов" Тогда
		Кандидаты.Добавить("АвтоПорядокПоКоду");
		Кандидаты.Добавить("ВидыСубконто");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ТипКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДлинаПорядка");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("МаксКоличествоСубконто");
		Кандидаты.Добавить("МаскаКода");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СерииКодов");
	ИначеЕсли ТипОбъекта = "РегистрРасчета" Тогда
		Кандидаты.Добавить("Периодичность");
		Кандидаты.Добавить("БазовыйПериод");
		Кандидаты.Добавить("График");
		Кандидаты.Добавить("ДатаГрафика");
		Кандидаты.Добавить("ЗначениеГрафика");
		Кандидаты.Добавить("ПериодДействия");
		Кандидаты.Добавить("ПланВидовРасчета");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "ГруппаКоманд" Тогда
		Кандидаты.Добавить("Категория");
	ИначеЕсли ТипОбъекта = "ЖурналДокументов" Тогда
		Кандидаты.Добавить("Графы");
		Кандидаты.Добавить("РегистрируемыеДокументы");
	ИначеЕсли ТипОбъекта = "Константа" Тогда
		Кандидаты.Добавить("ВыделятьОтрицательные");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("Маска");
		Кандидаты.Добавить("МногострочныйРежим");
		Кандидаты.Добавить("ПараметрыВыбора");
		Кандидаты.Добавить("ПроверкаЗаполнения");
		Кандидаты.Добавить("РежимПароля");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СвязиПараметровВыбора");
		Кандидаты.Добавить("СвязьПоТипу");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "КритерийОтбора" Тогда
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "Нумератор" Тогда
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ДопустимаяДлинаНомера");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "ОбщаяКоманда" Тогда
		Кандидаты.Добавить("Группа");
		Кандидаты.Добавить("ИзменяетДанные");
		Кандидаты.Добавить("Отображение");
		Кандидаты.Добавить("РежимИспользованияПараметра");
		Кандидаты.Добавить("ТипПараметраКоманды");
	ИначеЕсли ТипОбъекта = "ОбщийМодуль" Тогда
		Кандидаты.Добавить("ВнешнееСоединение");
		Кандидаты.Добавить("ВызовСервер");
		Кандидаты.Добавить("Глобальный");
		Кандидаты.Добавить("КлиентОбычноеПриложение");
		Кандидаты.Добавить("КлиентУправляемоеПриложение");
		Кандидаты.Добавить("ПовторноеИспользованиеВозвращаемыхЗначений");
		Кандидаты.Добавить("Привилегированный");
		Кандидаты.Добавить("Сервер");
	ИначеЕсли ТипОбъекта = "ОбщийРеквизит" Тогда
		Кандидаты.Добавить("АвтоИспользование");
		Кандидаты.Добавить("ВыделятьОтрицательные");
		Кандидаты.Добавить("ЗаполнятьИзДанныхЗаполнения");
		Кандидаты.Добавить("ЗначениеРазделенияДанных");
		Кандидаты.Добавить("ИспользованиеРазделенияДанных");
		Кандидаты.Добавить("ИспользованиеРазделяемыхДанных");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("Маска");
		Кандидаты.Добавить("МногострочныйРежим");
		Кандидаты.Добавить("ПроверкаЗаполнения");
		Кандидаты.Добавить("РазделениеАутентификации");
		Кандидаты.Добавить("РазделениеДанных");
		Кандидаты.Добавить("РазделениеПользователей");
		Кандидаты.Добавить("РазделениеРасширенийКонфигурации");
		Кандидаты.Добавить("РежимПароля");
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Тип");
		Кандидаты.Добавить("УсловноеРазделение");
	ИначеЕсли ТипОбъекта = "ОпределяемыйТип" Тогда
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "Отчет" Тогда
		Кандидаты.Добавить("ОсновнаяСхемаКомпоновкиДанных");
		Кандидаты.Добавить("ХранилищеВариантов");
		Кандидаты.Добавить("ХранилищеНастроек");
	ИначеЕсли ТипОбъекта = "ПараметрФункциональныхОпций" Тогда
		Кандидаты.Добавить("Использование");
	ИначеЕсли ТипОбъекта = "ПланВидовРасчета" Тогда
		Кандидаты.Добавить("БазовыеВидыРасчета");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("ЗависимостьОтВидовРасчета");
		Кандидаты.Добавить("ИспользованиеПериодаДействия");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипКода");
	ИначеЕсли ТипОбъекта = "ПланВидовХарактеристик" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ГруппыСверху");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("Иерархический");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СерииКодов");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "ПланОбмена" Тогда
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("Состав");
	ИначеЕсли ТипОбъекта = "Подсистема" Тогда
		Кандидаты.Добавить("ВключатьВКомандныйИнтерфейс");
		Кандидаты.Добавить("ИспользоватьОднуКоманду");
		Кандидаты.Добавить("Подсистемы");
		Кандидаты.Добавить("Состав");
	ИначеЕсли ТипОбъекта = "Последовательность" Тогда
		Кандидаты.Добавить("Движения");
		Кандидаты.Добавить("Документы");
		Кандидаты.Добавить("ПеремещениеГраницыПриПроведении");
	ИначеЕсли ТипОбъекта = "РегламентноеЗадание" Тогда
		Кандидаты.Добавить("ИмяМетода");
		Кандидаты.Добавить("ИнтервалПовтораПриАварийномЗавершении");
		Кандидаты.Добавить("Использование");
		Кандидаты.Добавить("Ключ");
		Кандидаты.Добавить("КоличествоПовторовПриАварийномЗавершении");
		Кандидаты.Добавить("Наименование");
		Кандидаты.Добавить("Предопределенное");
	ИначеЕсли ТипОбъекта = "ФункциональнаяОпция" Тогда
		Кандидаты.Добавить("ПривилегированныйРежимПриПолучении");
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Хранение");
	ИначеЕсли ТипОбъекта = "ОбщийМакет" Тогда
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "HTTPСервис" Тогда
		Кандидаты.Добавить("ВремяЖизниСеанса");
		Кандидаты.Добавить("КорневойURL");
		Кандидаты.Добавить("ПовторноеИспользованиеСеансов");
		Кандидаты.Добавить("ШаблоныURL");
	КонецЕсли;

КонецПроцедуры

&НаСервереБезКонтекста
Процедура ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты)
	Кандидаты.Добавить("БазовоеИзмерение");
	Кандидаты.Добавить("Балансовый");
	Кандидаты.Добавить("Ведущее");
	Кандидаты.Добавить("ВыделятьОтрицательные");
	Кандидаты.Добавить("ДанныеВедущихРегистров");
	Кандидаты.Добавить("ЗаполнятьИзДанныхЗаполнения");
	Кандидаты.Добавить("ЗапрещатьНезаполненныеЗначения");
	Кандидаты.Добавить("ИзмерениеАдресации");
	Кандидаты.Добавить("ИзмерениеРегистра");
	Кандидаты.Добавить("Использование");
	Кандидаты.Добавить("ИспользованиеВИтогах");
	Кандидаты.Добавить("ИсторияДанных");
	Кандидаты.Добавить("Маска");
	Кандидаты.Добавить("МногострочныйРежим");
	Кандидаты.Добавить("ОсновнойОтбор");
	Кандидаты.Добавить("ПараметрыВыбора");
	Кандидаты.Добавить("ПризнакУчета");
	Кандидаты.Добавить("ПризнакУчетаСубконто");
	Кандидаты.Добавить("ПроверкаЗаполнения");
	Кандидаты.Добавить("РежимПароля");
	Кандидаты.Добавить("СвязиПараметровВыбора");
	Кандидаты.Добавить("СвязьПоТипу");
	Кандидаты.Добавить("СоответствиеДвижениям");
	Кандидаты.Добавить("СоответствиеДокументам");
	Кандидаты.Добавить("ЗначениеЗаполнения");
КонецПроцедуры

&НаСервереБезКонтекста
Функция СекцияИзКоллекцииПолноеИмяСиноним(Коллекция)
	
	Результат = Новый Массив;
	
	Если Коллекция = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Каждого Элемент Из Коллекция Цикл
		
		ПолноеИмяЭлемента = "";
		СинонимЭлемента = "";
		
		Попытка
			ПолноеИмяЭлемента = Элемент.ПолноеИмя();
		Исключение
			ПолноеИмяЭлемента = "";
		КонецПопытки;
		
		Если ПустаяСтрока(ПолноеИмяЭлемента) Тогда
			Попытка
				ПолноеИмяЭлемента = Строка(Элемент);
			Исключение
				ПолноеИмяЭлемента = "";
			КонецПопытки;
		КонецЕсли;
		
		Попытка
			СинонимЭлемента = Элемент.Синоним;
		Исключение
			СинонимЭлемента = "";
		КонецПопытки;
		
		Результат.Добавить(Новый Структура("ПолноеИмя, Синоним", ПолноеИмяЭлемента, СинонимЭлемента));

	КонецЦикла;

	Возврат Результат;

КонецФункции

&НаСервереБезКонтекста
Функция СекцияИзКоллекцииМакетов(Коллекция)

	Результат = Новый Массив;

	Если Коллекция = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	Для Каждого Элемент Из Коллекция Цикл

		ПолноеИмяЭлемента = "";
		СинонимЭлемента = "";
		ТипМакетаЭлемента = "";

		Попытка
			ПолноеИмяЭлемента = Элемент.ПолноеИмя();
		Исключение
			ПолноеИмяЭлемента = "";
		КонецПопытки;

		Если ПустаяСтрока(ПолноеИмяЭлемента) Тогда
			Попытка
				ПолноеИмяЭлемента = Строка(Элемент);
			Исключение
				ПолноеИмяЭлемента = "";
			КонецПопытки;
		КонецЕсли;

		Попытка
			СинонимЭлемента = Элемент.Синоним;
		Исключение
			СинонимЭлемента = "";
		КонецПопытки;

		Попытка
			ТипМакетаЭлемента = Строка(Элемент.ТипМакета);
		Исключение
			ТипМакетаЭлемента = "";
		КонецПопытки;

		Результат.Добавить(Новый Структура("ПолноеИмя, Синоним, ТипМакета",
			ПолноеИмяЭлемента, СинонимЭлемента, ТипМакетаЭлемента));

	КонецЦикла;

	Возврат Результат;

КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьПредопределенныеЭлементыСправочника(ИмяСправочника, Лимит = 200)
	
	Если ПустаяСтрока(ИмяСправочника) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив;
	
	Попытка
		
		ТекстЗапроса = 
			"ВЫБРАТЬ ПЕРВЫЕ " + Строка(Лимит) + Символы.ПС +
			"	ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных," + Символы.ПС +
			"	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление" + Символы.ПС +
			"ИЗ" + Символы.ПС +
			"	Справочник." + ИмяСправочника + Символы.ПС +
			"ГДЕ" + Символы.ПС +
			"	Предопределенный";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Таблица = Запрос.Выполнить().Выгрузить();
		
		Для Каждого СтрокаТаблицы Из Таблица Цикл
			Результат.Добавить(Новый Структура(
				"ИмяПредопределенныхДанных, Представление",
				СтрокаТаблицы.ИмяПредопределенныхДанных,
				СтрокаТаблицы.Представление
			));
		КонецЦикла;
		
		Возврат Результат;
		
	Исключение
		// Не удалось получить предопределенные данные (недоступно/нет прав/не поддерживается)
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksЕслиНужно(МетаОбъект)
	// Возвращает структуру extension_marks для объекта метаданных, если объект
	// добавлен/заимствован/изменён расширениями конфигурации.
	// Если объект "обычный" (основная конфигурация, Собственный, нет изменений расширениями),
	// то возвращает Неопределено, чтобы не засорять ответ.
	
	Если МетаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Принадлежность = Неопределено;
	Попытка
		Принадлежность = МетаОбъект.ПринадлежностьОбъекта;
	Исключение
		Принадлежность = Неопределено;
	КонецПопытки;
	
	Расширение = Неопределено;
	Попытка
		Расширение = МетаОбъект.РасширениеКонфигурации();
	Исключение
		Расширение = Неопределено;
	КонецПопытки;
	
	ЕстьИзменения = Неопределено;
	Попытка
		ЕстьИзменения = (МетаОбъект.ЕстьИзмененияРасширениямиКонфигурации() = Истина);
	Исключение
		ЕстьИзменения = Неопределено;
	КонецПопытки;
	
	Показать = Ложь;
	
	Если Расширение <> Неопределено Тогда
		Показать = Истина;
	КонецЕсли;
	
	Если ЕстьИзменения = Истина Тогда
		Показать = Истина;
	КонецЕсли;
	
	Если НЕ Показать И Принадлежность <> Неопределено Тогда
		// В некоторых окружениях (толстый клиент/режим совместимости) идентификатор
		// ПринадлежностьОбъекта.<Значение> может быть недоступен как глобальный.
		// Поэтому сравниваем по строковому представлению (best effort).
		СтрПринадлежность = Строка(Принадлежность);
		Если СтрПринадлежность <> "Собственный" И СтрПринадлежность <> "Native" Тогда
			Показать = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ Показать Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИнфоРасширения = Неопределено;
	Если Расширение <> Неопределено Тогда
		ИнфоРасширения = Новый Структура;
		Попытка
			ИнфоРасширения.Вставить("Имя", Расширение.Имя);
		Исключение
		КонецПопытки;
		Попытка
			ИнфоРасширения.Вставить("Синоним", Расширение.Синоним);
		Исключение
		КонецПопытки;
		Попытка
			ИнфоРасширения.Вставить("УникальныйИдентификатор", БезопасноеЗначениеДляПередачи(Расширение.УникальныйИдентификатор));
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Метки = Новый Структура;
	Метки.Вставить("ПринадлежностьОбъекта", ?(Принадлежность = Неопределено, Неопределено, Строка(Принадлежность)));
	Метки.Вставить("РасширениеКонфигурации", ИнфоРасширения);
	Метки.Вставить("ЕстьИзмененияРасширениямиКонфигурации", ЕстьИзменения);
	
	Возврат Метки;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksИзМетаданныхРасширения(МетаОбъектРасширения)
	// Маркеры "принадлежности" для объекта, полученного из ОбъектМетаданныхКонфигурация
	// (т.е. из бинарных метаданных расширения).
	//
	// ВАЖНО: метод ЕстьИзмененияРасширениямиКонфигурации() в этом контексте может существовать,
	// но семантически относится к рантайм-метаданным текущего сеанса и на объекте расширения
	// обычно бесполезен (часто всегда Ложь). Поэтому тут возвращаем только то, что точно
	// относится к метаданным расширения: ПринадлежностьОбъекта (Native/Adopted).
	
	Метки = Новый Структура;
	
	Принадлежность = Неопределено;
	Попытка
		Принадлежность = МетаОбъектРасширения.ПринадлежностьОбъекта;
	Исключение
		Принадлежность = Неопределено;
	КонецПопытки;
	
	Метки.Вставить("ПринадлежностьОбъекта", ?(Принадлежность = Неопределено, Неопределено, Строка(Принадлежность)));
	
	Возврат Метки;
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(МетаОбъектРасширения)
	// Для дочерних объектов (реквизиты/табличные части/измерения/ресурсы) показываем метки
	// только если ПринадлежностьОбъекта = "Собственный" (Native), чтобы не раздувать ответ.
	
	Метки = ПолучитьExtensionMarksИзМетаданныхРасширения(МетаОбъектРасширения);
	
	СтрПринадлежность = "";
	Попытка
		Если Метки <> Неопределено И Метки.Свойство("ПринадлежностьОбъекта") И Метки.ПринадлежностьОбъекта <> Неопределено Тогда
			СтрПринадлежность = Строка(Метки.ПринадлежностьОбъекта);
		КонецЕсли;
	Исключение
		СтрПринадлежность = "";
	КонецПопытки;
	
	Если СтрПринадлежность = "Собственный" Или СтрПринадлежность = "Native" Тогда
		Возврат Метки;
	КонецЕсли;
	
	Возврат Неопределено;
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданные(ПолноеИмя, Секции = Неопределено)
	
	// Разбор полного имени (например, "Справочник.Номенклатура")
	ПозицияТочки = Найти(ПолноеИмя, ".");
	Если ПозицияТочки = 0 Тогда
		Возврат Новый Структура("success, error", Ложь, "Неверный формат имени объекта. Ожидается: Тип.Имя");
	КонецЕсли;
	
	ТипОбъекта = Лев(ПолноеИмя, ПозицияТочки - 1);
	ИмяОбъекта = Сред(ПолноеИмя, ПозицияТочки + 1);
	
	// Поиск объекта метаданных
	ОбъектМетаданных = Неопределено;
	
	// Основной способ: поиск по полному имени (поддерживает все типы, если доступно в платформе)
	Попытка
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	Исключение
		ОбъектМетаданных = Неопределено;
	КонецПопытки;
	
	// Fallback: поиск в коллекции по корневому типу
	Если ОбъектМетаданных = Неопределено Тогда
		
		ОписаниеТипа = Неопределено;
		Для Каждого Описание Из ПолучитьКорневыеТипыМетаданных() Цикл
			Если Описание.Тип = ТипОбъекта Тогда
				ОписаниеТипа = Описание;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ОписаниеТипа <> Неопределено Тогда
			Коллекция = Неопределено;
			Попытка
				Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
			Исключение
				Коллекция = Неопределено;
			КонецПопытки;
			
			Если Коллекция <> Неопределено Тогда
				Попытка
					ОбъектМетаданных = Коллекция.Найти(ИмяОбъекта);
				Исключение
					ОбъектМетаданных = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		// Для путей с >1 точкой (элементы коллекций) пробуем найти через родителя
		// Нужно для стандартных реквизитов, которые НайтиПоПолномуИмени не находит
		КоличествоТочек = 0;
		Для Сч = 1 По СтрДлина(ПолноеИмя) Цикл
			Если Сред(ПолноеИмя, Сч, 1) = "." Тогда
				КоличествоТочек = КоличествоТочек + 1;
			КонецЕсли;
		КонецЦикла;

		Если КоличествоТочек > 1 Тогда
			// Извлекаем "Тип.Объект" (первые 2 сегмента) и "ОстатокПути"
			ПозПервойТочки = Найти(ПолноеИмя, ".");
			ОстатокПослеТипа = Сред(ПолноеИмя, ПозПервойТочки + 1);
			ПозВторойТочки = Найти(ОстатокПослеТипа, ".");
			// Защита от кривого filter (например "Тип.Объект." без имени элемента)
			Если ПозВторойТочки > 0 И ПозВторойТочки < СтрДлина(ОстатокПослеТипа) Тогда
				ИмяРодителя = Лев(ПолноеИмя, ПозПервойТочки + ПозВторойТочки - 1);
				ОстатокПутиЭлемента = Сред(ОстатокПослеТипа, ПозВторойТочки + 1);

				// Находим родительский объект
				РодительМД = Неопределено;
				Попытка
					РодительМД = Метаданные.НайтиПоПолномуИмени(ИмяРодителя);
				Исключение
				КонецПопытки;

				Если РодительМД <> Неопределено Тогда
					ЭлементМД = НайтиЭлементВКоллекцииОбъекта(РодительМД, ОстатокПутиЭлемента);
					Если ЭлементМД <> Неопределено Тогда
						Возврат ПолучитьДетальныеМетаданныеЭлемента(ЭлементМД, ПолноеИмя, Секции);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Возврат Новый Структура("success, error", Ложь, "Объект не найден: " + ПолноеИмя);
	КонецЕсли;

	// Уточняем тип по фактическому полному имени (на случай, если исходная строка была нестандартной)
	ПолноеИмяФакт = ПолноеИмя;
	Попытка
		ПолноеИмяФакт = ОбъектМетаданных.ПолноеИмя();
	Исключение
		ПолноеИмяФакт = ПолноеИмя;
	КонецПопытки;
	
	ПозицияТочкиФакт = Найти(ПолноеИмяФакт, ".");
	Если ПозицияТочкиФакт > 0 Тогда
		ТипОбъекта = Лев(ПолноеИмяФакт, ПозицияТочкиФакт - 1);
	КонецЕсли;

	// Проверяем, является ли найденный объект элементом коллекции (Реквизит, Измерение и т.д.)
	// "Тип.Объект" = 1 точка, "Тип.Объект.Коллекция.Элемент" = 3 точки
	КоличествоТочекФакт = 0;
	Для Сч = 1 По СтрДлина(ПолноеИмяФакт) Цикл
		Если Сред(ПолноеИмяФакт, Сч, 1) = "." Тогда
			КоличествоТочекФакт = КоличествоТочекФакт + 1;
		КонецЕсли;
	КонецЦикла;

	Если КоличествоТочекФакт > 1 Тогда
		// Это элемент коллекции — возвращаем информацию только о нём
		Возврат ПолучитьДетальныеМетаданныеЭлемента(ОбъектМетаданных, ПолноеИмяФакт, Секции);
	КонецЕсли;
	
	// Формирование информации об объекте
	ИнформацияОбОбъекте = Новый Структура;
	ИнформацияОбОбъекте.Вставить("ТипОбъектаМетаданных", ТипОбъекта);
	ИнформацияОбОбъекте.Вставить("Имя", ОбъектМетаданных.Имя);
	ИнформацияОбОбъекте.Вставить("Синоним", ОбъектМетаданных.Синоним);
	ИнформацияОбОбъекте.Вставить("ПолноеИмя", ПолноеИмяФакт);
	
	// Маркеры расширений (показываем только если объект не "обычный")
	МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ОбъектМетаданных);
	Если МеткиРасширений <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("extension_marks", МеткиРасширений);
	КонецЕсли;
	
	// Реквизиты
	Реквизиты = Новый Массив;
	ЕстьКоллекцияРеквизитов = Ложь;

	// Стандартные реквизиты (Код, Наименование, Ссылка и т.д.)
	Попытка
		КоллекцияСтдРеквизитов = ОбъектМетаданных.СтандартныеРеквизиты;
		ЕстьКоллекцияРеквизитов = Истина;
		Для Каждого СтдРеквизит Из КоллекцияСтдРеквизитов Цикл
			Попытка
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
					СтдРеквизит.Имя,
					СтдРеквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип),
					Истина);

				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(СтдРеквизит);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;

				Реквизиты.Добавить(СтрокаРеквизита);
			Исключение
				// Пропускаем проблемный стандартный реквизит
			КонецПопытки;
		КонецЦикла;
	Исключение
		// У объекта нет коллекции СтандартныеРеквизиты
	КонецПопытки;

	// Пользовательские реквизиты
	Попытка
		КоллекцияРеквизитов = ОбъектМетаданных.Реквизиты;
		ЕстьКоллекцияРеквизитов = Истина;
		Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип),
				Ложь);

			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;

			Реквизиты.Добавить(СтрокаРеквизита);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет пользовательских реквизитов
	КонецПопытки;

	Если ЕстьКоллекцияРеквизитов Тогда
		ИнформацияОбОбъекте.Вставить("Реквизиты", Реквизиты);
	КонецЕсли;
	
	// Реквизиты адресации (для задач)
	Если ТипОбъекта = "Задача" Тогда
		РеквизитыАдресации = Неопределено;
		Попытка
			РеквизитыАдресации = Новый Массив;
			Для Каждого РеквизитАдресации Из ОбъектМетаданных.РеквизитыАдресации Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
					РеквизитАдресации.Имя,
					РеквизитАдресации.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(РеквизитАдресации.Тип));
				
				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(РеквизитАдресации);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;
				
				РеквизитыАдресации.Добавить(СтрокаРеквизита);
			КонецЦикла;
		Исключение
			// Секция не применима/недоступна
			РеквизитыАдресации = Неопределено;
		КонецПопытки;
		
		Если РеквизитыАдресации <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("РеквизитыАдресации", РеквизитыАдресации);
		КонецЕсли;
	КонецЕсли;
	
	// Табличные части
	ТабличныеЧасти = Неопределено;
	Попытка
		ТабличныеЧасти = Новый Массив;
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			РеквизитыТЧ = Новый Массив;
			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
					Реквизит.Имя,
					Реквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));
				
				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;
				
				РеквизитыТЧ.Добавить(СтрокаРеквизита);
			КонецЦикла;
			
			СтрокаТЧ = Новый Структура("Имя, Синоним, Реквизиты",
				ТабличнаяЧасть.Имя,
				ТабличнаяЧасть.Синоним,
				РеквизитыТЧ);
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ТабличнаяЧасть);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаТЧ.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			ТабличныеЧасти.Добавить(СтрокаТЧ);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет табличных частей (секция не применима)
		ТабличныеЧасти = Неопределено;
	КонецПопытки;
	Если ТабличныеЧасти <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("ТабличныеЧасти", ТабличныеЧасти);
	КонецЕсли;
	
	// Измерения (для регистров)
	Измерения = Неопределено;
	Попытка
		Измерения = Новый Массив;
		Для Каждого Измерение Из ОбъектМетаданных.Измерения Цикл
			СтрокаИзмерения = Новый Структура("Имя, Синоним, Тип",
				Измерение.Имя,
				Измерение.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Измерение.Тип));
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Измерение);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаИзмерения.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			Измерения.Добавить(СтрокаИзмерения);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет измерений (секция не применима)
		Измерения = Неопределено;
	КонецПопытки;
	Если Измерения <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("Измерения", Измерения);
	КонецЕсли;
	
	// Ресурсы (для регистров)
	Ресурсы = Неопределено;
	Попытка
		Ресурсы = Новый Массив;
		Для Каждого Ресурс Из ОбъектМетаданных.Ресурсы Цикл
			СтрокаРесурса = Новый Структура("Имя, Синоним, Тип",
				Ресурс.Имя,
				Ресурс.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Ресурс.Тип));
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Ресурс);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРесурса.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			Ресурсы.Добавить(СтрокаРесурса);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет ресурсов (секция не применима)
		Ресурсы = Неопределено;
	КонецПопытки;
	Если Ресурсы <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("Ресурсы", Ресурсы);
	КонецЕсли;
	
	// Значения перечисления
	Если ТипОбъекта = "Перечисление" Тогда
		ЗначенияПеречисления = Новый Массив;
		Для Каждого ЗначениеПеречисления Из ОбъектМетаданных.ЗначенияПеречисления Цикл
			ЗначенияПеречисления.Добавить(Новый Структура("Имя, Синоним", 
				ЗначениеПеречисления.Имя, 
				ЗначениеПеречисления.Синоним));
		КонецЦикла;
		ИнформацияОбОбъекте.Вставить("ЗначенияПеречисления", ЗначенияПеречисления);
	КонецЕсли;
	
	// Владельцы (для подчинённых справочников)
	Если ТипОбъекта = "Справочник" Тогда
		Попытка
			Если ОбъектМетаданных.Владельцы.Количество() > 0 Тогда
				Владельцы = Новый Массив;
				Для Каждого Владелец Из ОбъектМетаданных.Владельцы Цикл
					Владельцы.Добавить(Владелец.ПолноеИмя());
				КонецЦикла;
				ИнформацияОбОбъекте.Вставить("Владельцы", Владельцы);
			КонецЕсли;
		Исключение
			// У некоторых справочников нет владельцев
		КонецПопытки;
	КонецЕсли;

	// ПризнакиУчета и ПризнакиУчетаСубконто (только для планов счетов)
	Если ТипОбъекта = "ПланСчетов" Тогда
		Попытка
			КоллекцияПризнаков = ОбъектМетаданных.ПризнакиУчета;
			Если КоллекцияПризнаков <> Неопределено Тогда
				МассивПризнаков = Новый Массив;
				Для Каждого Признак Из КоллекцияПризнаков Цикл
					МассивПризнаков.Добавить(Новый Структура("Имя, Синоним, Тип",
						Признак.Имя, Признак.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
				КонецЦикла;
				Если МассивПризнаков.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("ПризнакиУчета", МассивПризнаков);
				КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;

		Попытка
			КоллекцияПризнаковСубконто = ОбъектМетаданных.ПризнакиУчетаСубконто;
			Если КоллекцияПризнаковСубконто <> Неопределено Тогда
				МассивПризнаковСубконто = Новый Массив;
				Для Каждого Признак Из КоллекцияПризнаковСубконто Цикл
					МассивПризнаковСубконто.Добавить(Новый Структура("Имя, Синоним, Тип",
						Признак.Имя, Признак.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
				КонецЦикла;
				Если МассивПризнаковСубконто.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("ПризнакиУчетаСубконто", МассивПризнаковСубконто);
				КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;

	// СтандартныеТабличныеЧасти (для ПланСчетов и ПланВидовРасчета)
	Если ТипОбъекта = "ПланСчетов" ИЛИ ТипОбъекта = "ПланВидовРасчета" Тогда
		Попытка
			СтандартныеТабличныеЧасти = Новый Массив;
			Для Каждого СтдТЧ Из ОбъектМетаданных.СтандартныеТабличныеЧасти Цикл
				РеквизитыСтдТЧ = Новый Массив;
				Попытка
					Для Каждого СтдРеквизит Из СтдТЧ.СтандартныеРеквизиты Цикл
						Попытка
							РеквизитыСтдТЧ.Добавить(Новый Структура("Имя, Синоним, Тип",
								СтдРеквизит.Имя,
								СтдРеквизит.Синоним,
								ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип)));
						Исключение
						КонецПопытки;
					КонецЦикла;
				Исключение
				КонецПопытки;

				СтрокаСтдТЧ = Новый Структура("Имя, Синоним, Реквизиты",
					СтдТЧ.Имя,
					СтдТЧ.Синоним,
					РеквизитыСтдТЧ);

				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(СтдТЧ);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаСтдТЧ.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;

				СтандартныеТабличныеЧасти.Добавить(СтрокаСтдТЧ);
			КонецЦикла;
			Если СтандартныеТабличныеЧасти.Количество() > 0 Тогда
				ИнформацияОбОбъекте.Вставить("СтандартныеТабличныеЧасти", СтандартныеТабличныеЧасти);
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;

	// Дополнительные секции детального ответа (управляемый "богатый" режим)
	Если СекцияЗапрошена(Секции, "properties") Тогда

		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		
		ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты);
		
		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
				ЗначениеСвойства = Неопределено;
			КонецПопытки;
			
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;
		
		ИнформацияОбОбъекте.Вставить("properties", Свойства);
		
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "forms") Тогда
		КоллекцияФорм = Неопределено;
		Попытка
			КоллекцияФорм = ОбъектМетаданных.Формы;
		Исключение
			КоллекцияФорм = Неопределено;
		КонецПопытки;
		
		Если КоллекцияФорм <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("forms", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияФорм));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "commands") Тогда
		КоллекцияКоманд = Неопределено;
		Попытка
			КоллекцияКоманд = ОбъектМетаданных.Команды;
		Исключение
			КоллекцияКоманд = Неопределено;
		КонецПопытки;
		
		Если КоллекцияКоманд <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("commands", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияКоманд));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "layouts") Тогда
		КоллекцияМакетов = Неопределено;
		Попытка
			КоллекцияМакетов = ОбъектМетаданных.Макеты;
		Исключение
			КоллекцияМакетов = Неопределено;
		КонецПопытки;
		
		Если КоллекцияМакетов <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("layouts", СекцияИзКоллекцииМакетов(КоллекцияМакетов));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "predefined") Тогда
		
		// 1) Если в рантайм-метаданных есть коллекция предопределенных - используем ее
		КоллекцияПредопределенных = Неопределено;
		Попытка
			КоллекцияПредопределенных = ОбъектМетаданных.Предопределенные;
		Исключение
			КоллекцияПредопределенных = Неопределено;
		КонецПопытки;
		
		Если КоллекцияПредопределенных <> Неопределено Тогда
			Попытка
				ИнформацияОбОбъекте.Вставить("predefined", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияПредопределенных));
			Исключение
				// Если это не коллекция - игнорируем и пробуем fallback ниже
			КонецПопытки;
		КонецЕсли;
		
		// 2) Fallback для справочников: предопределенные данные хранятся как данные (отбор по Предопределенный)
		Если Не ИнформацияОбОбъекте.Свойство("predefined") И ТипОбъекта = "Справочник" Тогда
			ПредопределенныеДанные = ПолучитьПредопределенныеЭлементыСправочника(ИмяОбъекта, 200);
			Если ПредопределенныеДанные <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("predefined", ПредопределенныеДанные);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;

	// Движения (только для документов — список регистров, в которых документ делает движения)
	Если СекцияЗапрошена(Секции, "movements") Тогда
		Если ТипОбъекта = "Документ" Тогда
			КоллекцияДвижений = Неопределено;
			Попытка
				КоллекцияДвижений = ОбъектМетаданных.Движения;
			Исключение
				КоллекцияДвижений = Неопределено;
			КонецПопытки;

			Если КоллекцияДвижений <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("movements", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияДвижений));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// Характеристики (описания характеристик, привязанных к объекту метаданных)
	Если СекцияЗапрошена(Секции, "characteristics") Тогда
		КоллекцияХарактеристик = Неопределено;
		Попытка
			КоллекцияХарактеристик = ОбъектМетаданных.Характеристики;
		Исключение
			КоллекцияХарактеристик = Неопределено;
		КонецПопытки;

		Если КоллекцияХарактеристик <> Неопределено Тогда
			МассивХарактеристик = Новый Массив;
			Для Каждого ОписаниеХарактеристики Из КоллекцияХарактеристик Цикл
				ЭлементХарактеристики = Новый Структура;

				// ВидыХарактеристик — ссылка на ПланВидовХарактеристик → ПолноеИмя()
				Попытка
					ВидыХар = ОписаниеХарактеристики.ВидыХарактеристик;
					Если ВидыХар <> Неопределено Тогда
						Попытка
							ЭлементХарактеристики.Вставить("ВидыХарактеристик", ВидыХар.ПолноеИмя());
						Исключение
							ЭлементХарактеристики.Вставить("ВидыХарактеристик", Строка(ВидыХар));
						КонецПопытки;
					КонецЕсли;
				Исключение
				КонецПопытки;

				// ЗначенияХарактеристик — ссылка на регистр сведений → ПолноеИмя()
				Попытка
					ЗначенияХар = ОписаниеХарактеристики.ЗначенияХарактеристик;
					Если ЗначенияХар <> Неопределено Тогда
						Попытка
							ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", ЗначенияХар.ПолноеИмя());
						Исключение
							ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", Строка(ЗначенияХар));
						КонецПопытки;
					КонецЕсли;
				Исключение
				КонецПопытки;

				// ЗначениеОтбораВидов — произвольный тип
				Попытка
					ЗначениеОтбора = ОписаниеХарактеристики.ЗначениеОтбораВидов;
					Если ЗначениеОтбора <> Неопределено Тогда
						ЭлементХарактеристики.Вставить("ЗначениеОтбораВидов",
							БезопасноеЗначениеДляПередачи(ЗначениеОтбора));
					КонецЕсли;
				Исключение
				КонецПопытки;

				// Поля (строковые свойства) — через Вычислить с безопасным доступом
				ПоляСтроковые = Новый Структура;
				ПоляСтроковые.Вставить("ПолеВида",                                "ПолеВида");
				ПоляСтроковые.Вставить("ПолеЗначения",                            "ПолеЗначения");
				ПоляСтроковые.Вставить("ПолеИспользованияМножественныхЗначений",  "ПолеИспользованияМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеКлюча",                               "ПолеКлюча");
				ПоляСтроковые.Вставить("ПолеКлючаМножественныхЗначений",          "ПолеКлючаМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеОбъекта",                             "ПолеОбъекта");
				ПоляСтроковые.Вставить("ПолеОтбораВидов",                         "ПолеОтбораВидов");
				ПоляСтроковые.Вставить("ПолеПорядкаМножественныхЗначений",        "ПолеПорядкаМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеПутиКДанным",                         "ПолеПутиКДанным");

				Для Каждого КлючЗначение Из ПоляСтроковые Цикл
					Попытка
						ЗначениеПоля = Вычислить("ОписаниеХарактеристики." + КлючЗначение.Значение);
						Если ЗначениеПоля <> Неопределено И Не ПустаяСтрока(Строка(ЗначениеПоля)) Тогда
							ЭлементХарактеристики.Вставить(КлючЗначение.Ключ, Строка(ЗначениеПоля));
						КонецЕсли;
					Исключение
					КонецПопытки;
				КонецЦикла;

				// Пропускаем пустые элементы (все поля = Неопределено/пустые)
				Если ЭлементХарактеристики.Количество() > 0 Тогда
					МассивХарактеристик.Добавить(ЭлементХарактеристики);
				КонецЕсли;
			КонецЦикла;

			Если МассивХарактеристик.Количество() > 0 Тогда
				ИнформацияОбОбъекте.Вставить("characteristics", МассивХарактеристик);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, ИнформацияОбОбъекте);

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеЭлемента(ОбъектМетаданных, ПолноеИмяМД, Секции)

	ИнформацияОбЭлементе = Новый Структура;
	ИнформацияОбЭлементе.Вставить("ПолноеИмя", ПолноеИмяМД);
	ИнформацияОбЭлементе.Вставить("Имя", ОбъектМетаданных.Имя);

	Попытка
		ИнформацияОбЭлементе.Вставить("Синоним", ОбъектМетаданных.Синоним);
	Исключение
	КонецПопытки;

	// Тип (описание типов) — есть у реквизитов, измерений, ресурсов
	Попытка
		ИнформацияОбЭлементе.Вставить("Тип",
			ПолучитьСтроковоеПредставлениеОписанияТипов(ОбъектМетаданных.Тип));
	Исключение
		// У некоторых элементов (ТабличнаяЧасть) нет свойства Тип
	КонецПопытки;

	// Для табличных частей — вернуть список реквизитов
	Попытка
		РеквизитыТЧ = Новый Массив;
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;

			РеквизитыТЧ.Добавить(СтрокаРеквизита);
		КонецЦикла;
		ИнформацияОбЭлементе.Вставить("Реквизиты", РеквизитыТЧ);
	Исключение
		// Нет коллекции реквизитов (не ТабличнаяЧасть)
	КонецПопытки;

	// Extension marks
	МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ОбъектМетаданных);
	Если МеткиРасширений <> Неопределено Тогда
		ИнформацияОбЭлементе.Вставить("extension_marks", МеткиРасширений);
	КонецЕсли;

	// Properties — расширенные свойства элемента
	Если СекцияЗапрошена(Секции, "properties") Тогда
		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты);

		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
			КонецПопытки;
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;

		ИнформацияОбЭлементе.Вставить("properties", Свойства);
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, ИнформацияОбЭлементе);

КонецФункции

&НаСервереБезКонтекста
Функция НайтиЭлементВКоллекцииОбъекта(ОбъектМД, ОстатокПути)
	// ОстатокПути = "Реквизит.ИНН" или "ТабличнаяЧасть.Товары.Реквизит.Номенклатура"
	// Сегменты в единственном числе — формат ПолноеИмя() платформы
	Части = РазделитьСтрокуПоРазделителю(ОстатокПути, ".");

	Если Части.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Маппинг: единственное число из ПолноеИмя() → имя свойства объекта метаданных
	ИмяСегмента = Части[0];
	Если ИмяСегмента = "Реквизит" Тогда
		ИмяКоллекции = "Реквизиты";
	ИначеЕсли ИмяСегмента = "СтандартныйРеквизит" Тогда
		ИмяКоллекции = "СтандартныеРеквизиты";
	ИначеЕсли ИмяСегмента = "Измерение" Тогда
		ИмяКоллекции = "Измерения";
	ИначеЕсли ИмяСегмента = "Ресурс" Тогда
		ИмяКоллекции = "Ресурсы";
	ИначеЕсли ИмяСегмента = "РеквизитАдресации" Тогда
		ИмяКоллекции = "РеквизитыАдресации";
	ИначеЕсли ИмяСегмента = "ТабличнаяЧасть" Тогда
		ИмяКоллекции = "ТабличныеЧасти";
	Иначе
		ИмяКоллекции = ИмяСегмента;
	КонецЕсли;

	ИмяЭлемента = Части[1];

	// Получаем коллекцию
	Коллекция = Неопределено;
	Попытка
		Коллекция = Вычислить("ОбъектМД." + ИмяКоллекции);
	Исключение
		Возврат Неопределено;
	КонецПопытки;

	// Ищем элемент по имени
	Для Каждого Элемент Из Коллекция Цикл
		Если Элемент.Имя = ИмяЭлемента Тогда
			// Для вложенного пути (ТабличнаяЧасть.Товары.Реквизит.Номенклатура)
			Если Части.Количество() > 2 Тогда
				ВложенныйОстаток = "";
				Для Инд = 2 По Части.Количество() - 1 Цикл
					ВложенныйОстаток = ВложенныйОстаток
						+ ?(ВложенныйОстаток = "", "", ".") + Части[Инд];
				КонецЦикла;
				Возврат НайтиЭлементВКоллекцииОбъекта(Элемент, ВложенныйОстаток);
			КонецЕсли;
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ЖУРНАЛ РЕГИСТРАЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьЖурналРегистрации(ДатаНачала, ДатаОкончания, Уровни, СобытияЖурнала, Лимит,
	ДанныеОбъекта = Неопределено, ТипыМетаданных = Неопределено, Пользователи = Неопределено,
	Сеансы = Неопределено, Приложения = Неопределено, Компьютер = Неопределено,
	ПодстрокаКомментария = Неопределено, СтатусТранзакцииСтрока = Неопределено, СмещениеВСекунде = 0)
	
	Попытка
		// Формируем отбор
		Отбор = Новый Структура;
		
		Если ЗначениеЗаполнено(ДатаНачала) Тогда
			Отбор.Вставить("ДатаНачала", ДатаНачала);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ДатаОкончания) Тогда
			Отбор.Вставить("ДатаОкончания", ДатаОкончания);
		КонецЕсли;
		
		// Уровни важности
		Если Уровни <> Неопределено И ЭтоКоллекция(Уровни) Тогда
			МассивУровней = Новый Массив;
			Для Каждого УровеньСтрока Из Уровни Цикл
				Если ВРег(УровеньСтрока) = "INFORMATION" Или ВРег(УровеньСтрока) = "ИНФОРМАЦИЯ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
				ИначеЕсли ВРег(УровеньСтрока) = "WARNING" Или ВРег(УровеньСтрока) = "ПРЕДУПРЕЖДЕНИЕ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
				ИначеЕсли ВРег(УровеньСтрока) = "ERROR" Или ВРег(УровеньСтрока) = "ОШИБКА" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
				ИначеЕсли ВРег(УровеньСтрока) = "NOTE" Или ВРег(УровеньСтрока) = "ПРИМЕЧАНИЕ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
				КонецЕсли;
			КонецЦикла;
			Если МассивУровней.Количество() > 0 Тогда
				Отбор.Вставить("Уровень", МассивУровней);
			КонецЕсли;
		КонецЕсли;
		
		// События
		Если СобытияЖурнала <> Неопределено И ЭтоКоллекция(СобытияЖурнала) Тогда
			Отбор.Вставить("Событие", СобытияЖурнала);
		КонецЕсли;
		
		// Фильтр по объекту данных (навигационная ссылка)
		Если ЗначениеЗаполнено(ДанныеОбъекта) Тогда
			СсылкаОбъекта = ПолучитьСсылкуИзСтроки(ДанныеОбъекта);
			Если СсылкаОбъекта = Неопределено Тогда
				// Возвращаем явную ошибку при невозможности применить фильтр по объекту
				Возврат Новый Структура("success, error", Ложь,
					"Не удалось применить фильтр по объекту: некорректная ссылка / Failed to apply object filter: invalid reference");
			КонецЕсли;
			Отбор.Вставить("Данные", СсылкаОбъекта);
		КонецЕсли;
		
		// Фильтр по типу метаданных
		Если ТипыМетаданных <> Неопределено И ЭтоКоллекция(ТипыМетаданных) Тогда
			МассивМетаданных = Новый Массив;
			Для Каждого ИмяМетаданных Из ТипыМетаданных Цикл
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяМетаданных);
				Если ОбъектМетаданных <> Неопределено Тогда
					МассивМетаданных.Добавить(ОбъектМетаданных);
				КонецЕсли;
			КонецЦикла;
			Если МассивМетаданных.Количество() > 0 Тогда
				Отбор.Вставить("Метаданные", МассивМетаданных);
			КонецЕсли;
		КонецЕсли;
		
		// Фильтр по пользователю
		Если Пользователи <> Неопределено И ЭтоКоллекция(Пользователи) Тогда
			МассивПользователей = Новый Массив;
			Для Каждого ИмяПользователя Из Пользователи Цикл
				ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ИмяПользователя);
				Если ПользовательИБ <> Неопределено Тогда
					МассивПользователей.Добавить(ПользовательИБ);
				КонецЕсли;
			КонецЦикла;
			Если МассивПользователей.Количество() > 0 Тогда
				Отбор.Вставить("Пользователь", МассивПользователей);
			КонецЕсли;
		КонецЕсли;
		
		// Фильтр по сеансу
		Если Сеансы <> Неопределено И ЭтоКоллекция(Сеансы) Тогда
			Отбор.Вставить("Сеанс", Сеансы);
		КонецЕсли;
		
		// Фильтр по приложению
		Если Приложения <> Неопределено И ЭтоКоллекция(Приложения) Тогда
			Отбор.Вставить("ИмяПриложения", Приложения);
		КонецЕсли;
		
		// Фильтр по компьютеру
		Если ЗначениеЗаполнено(Компьютер) Тогда
			Отбор.Вставить("Компьютер", Компьютер);
		КонецЕсли;
		
		// Статус транзакции - будет постфильтрация (тип недоступен в режиме совместимости 8.2.13)
		ФильтрСтатусТранзакции = Неопределено;
		Если ЗначениеЗаполнено(СтатусТранзакцииСтрока) Тогда
			ФильтрСтатусТранзакции = ПолучитьСтатусТранзакции(СтатусТранзакцииСтрока);
		КонецЕсли;
		
		// Вычисляем лимит выгрузки с учётом смещения и постфильтров
		// Формула: Лимит + СмещениеВСекунде + 1 (для определения has_more)
		// При постфильтрах: (Лимит * 10) + СмещениеВСекунде + 1
		ЕстьПостфильтры = ЗначениеЗаполнено(ПодстрокаКомментария) Или ЗначениеЗаполнено(ФильтрСтатусТранзакции);
		Если ЕстьПостфильтры Тогда
			ЛимитВыгрузки = (Лимит * 10) + СмещениеВСекунде + 1;
		Иначе
			ЛимитВыгрузки = Лимит + СмещениеВСекунде + 1;
		КонецЕсли;
		
		// Выгружаем журнал
		ТаблицаЖурнала = Новый ТаблицаЗначений;
		ВыгрузитьЖурналРегистрации(ТаблицаЖурнала, Отбор, , , ЛимитВыгрузки);
		
		// Постфильтрация по комментарию (платформа не поддерживает поиск по подстроке)
		Если ЗначениеЗаполнено(ПодстрокаКомментария) Тогда
			ПодстрокаВерхнийРегистр = ВРег(ПодстрокаКомментария);
			СтрокиДляУдаления = Новый Массив;
			Для Каждого СтрокаТаблицы Из ТаблицаЖурнала Цикл
				Если Найти(ВРег(СтрокаТаблицы.Комментарий), ПодстрокаВерхнийРегистр) = 0 Тогда
					СтрокиДляУдаления.Добавить(СтрокаТаблицы);
				КонецЕсли;
			КонецЦикла;
			Для Каждого СтрокаДляУдаления Из СтрокиДляУдаления Цикл
				ТаблицаЖурнала.Удалить(СтрокаДляУдаления);
			КонецЦикла;
		КонецЕсли;
		
		// Постфильтрация по статусу транзакции (тип недоступен в режиме совместимости 8.2.13)
		Если ЗначениеЗаполнено(ФильтрСтатусТранзакции) Тогда
			СтрокиДляУдаления = Новый Массив;
			Для Каждого СтрокаТаблицы Из ТаблицаЖурнала Цикл
				СтатусСтрока = Строка(СтрокаТаблицы.СтатусТранзакции);
				Если Найти(СтатусСтрока, ФильтрСтатусТранзакции) = 0 Тогда
					СтрокиДляУдаления.Добавить(СтрокаТаблицы);
				КонецЕсли;
			КонецЦикла;
			Для Каждого СтрокаДляУдаления Из СтрокиДляУдаления Цикл
				ТаблицаЖурнала.Удалить(СтрокаДляУдаления);
			КонецЦикла;
		КонецЕсли;

		// КУРСОРНАЯ ПАГИНАЦИЯ: Явная сортировка с tie-breakers для стабильного порядка
		// Гарантирует детерминированный порядок записей с одинаковой секундой
		ТаблицаЖурнала.Сортировать("Дата, Сеанс, Событие, Пользователь, Метаданные, ПредставлениеДанных");

		// Вычисляем ключ секунды для start_date (для корректного сравнения)
		// В 1С дата может содержать доли секунды — сравнение = может не работать
		КлючСекундыНачала = "";
		Если ЗначениеЗаполнено(ДатаНачала) Тогда
			КлючСекундыНачала = Формат(ДатаНачала, "ДФ=yyyy-MM-ddTHH:mm:ss");
		КонецЕсли;

		// Преобразуем в массив для JSON с логикой курсорной пагинации
		Результат = Новый Массив;
		Счетчик = 0;
		ПропущеноВСекунде = 0;
		КлючПоследнейСекунды = "";
		КоличествоВПоследнейСекунде = 0;

		Для Каждого СтрокаТаблицы Из ТаблицаЖурнала Цикл
			// Ключ секунды текущей строки
			КлючСекундыСтроки = Формат(СтрокаТаблицы.Дата, "ДФ=yyyy-MM-ddTHH:mm:ss");

			// Пропускаем записи с начальной секундой если задан offset
			Если КлючСекундыНачала <> ""
			   И КлючСекундыСтроки = КлючСекундыНачала
			   И ПропущеноВСекунде < СмещениеВСекунде Тогда
				ПропущеноВСекунде = ПропущеноВСекунде + 1;
				Продолжить;
			КонецЕсли;

			Если Счетчик >= Лимит Тогда
				Прервать;
			КонецЕсли;

			ЗаписьЖурнала = Новый Структура;
			ЗаписьЖурнала.Вставить("date", КлючСекундыСтроки);
			ЗаписьЖурнала.Вставить("level", ПолучитьИмяУровня(СтрокаТаблицы.Уровень));
			ЗаписьЖурнала.Вставить("event", СтрокаТаблицы.Событие);
			ЗаписьЖурнала.Вставить("comment", СтрокаТаблицы.Комментарий);
			ЗаписьЖурнала.Вставить("user", Строка(СтрокаТаблицы.Пользователь));
			ЗаписьЖурнала.Вставить("metadata", Строка(СтрокаТаблицы.Метаданные));
			ЗаписьЖурнала.Вставить("data_presentation", СтрокаТаблицы.ПредставлениеДанных);
			ЗаписьЖурнала.Вставить("session", СтрокаТаблицы.Сеанс);
			ЗаписьЖурнала.Вставить("application", СтрокаТаблицы.ИмяПриложения);
			ЗаписьЖурнала.Вставить("computer", СтрокаТаблицы.Компьютер);
			ЗаписьЖурнала.Вставить("transaction_status", ПолучитьИмяСтатусаТранзакции(СтрокаТаблицы.СтатусТранзакции));
			Результат.Добавить(ЗаписьЖурнала);

			// Отслеживаем для курсора (накопительный счётчик) — по ключу секунды
			Если КлючПоследнейСекунды = КлючСекундыСтроки Тогда
				КоличествоВПоследнейСекунде = КоличествоВПоследнейСекунде + 1;
			Иначе
				КлючПоследнейСекунды = КлючСекундыСтроки;
				КоличествоВПоследнейСекунде = 1;
			КонецЕсли;

			Счетчик = Счетчик + 1;
		КонецЦикла;

		// Формируем ответ
		ОтветСтруктура = Новый Структура("success,data,count", Истина, Результат, Результат.Количество());

		// Курсорная пагинация - только если указаны даты
		ЕстьФильтрПоДате = ЗначениеЗаполнено(ДатаНачала) Или ЗначениеЗаполнено(ДатаОкончания);

		Если ЕстьФильтрПоДате И КлючПоследнейСекунды <> "" Тогда
			ОтветСтруктура.Вставить("last_date", КлючПоследнейСекунды);

			// КРИТИЧНО: возвращаем НАКОПИТЕЛЬНЫЙ offset для следующей страницы
			// Сравниваем по КЛЮЧУ СЕКУНДЫ, а не по Date-объектам
			Если КлючПоследнейСекунды = КлючСекундыНачала Тогда
				// Та же секунда что и на входе — накапливаем
				СледующийOffset = СмещениеВСекунде + КоличествоВПоследнейСекунде;
			Иначе
				// Новая секунда — offset только от записей с этой секундой
				СледующийOffset = КоличествоВПоследнейСекунде;
			КонецЕсли;
			ОтветСтруктура.Вставить("next_same_second_offset", СледующийOffset);

			// has_more: осталось больше записей чем limit после пропуска?
			ОсталосьЗаписей = ТаблицаЖурнала.Количество() - ПропущеноВСекунде;
			ЕстьЕще = ОсталосьЗаписей > Лимит;
			ОтветСтруктура.Вставить("has_more", ЕстьЕще);
		КонецЕсли;

		Возврат ОтветСтруктура;
		
	Исключение
		Возврат Новый Структура("success,error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСсылкуИзСтроки(СтрокаСсылки)
	
	Если Не ЗначениеЗаполнено(СтрокаСсылки) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		// Пробуем как навигационную ссылку (e1cib/data/...)
		Если Найти(НРег(СтрокаСсылки), "e1cib") > 0 Тогда
			Возврат НайтиОбъектВручную(СтрокаСсылки);
		КонецЕсли;
		
		// Пробуем как UUID (8-4-4-4-12 формат)
		Если СтрДлина(СтрокаСсылки) = 36 И Найти(СтрокаСсылки, "-") > 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Неопределено;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСтатусТранзакции(СтатусСтрока)
	
	// В режиме совместимости 8.2.13 тип СтатусТранзакцииЖурналаРегистрации недоступен
	// Возвращаем строку для постфильтрации
	Если Не ЗначениеЗаполнено(СтатусСтрока) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтатусВерхний = ВРег(СтатусСтрока);
	
	// Возвращаем русское название для сравнения со строковым представлением
	Если СтатусВерхний = "COMMITTED" Тогда
		Возврат "Зафиксирована";
	ИначеЕсли СтатусВерхний = "ROLLEDBACK" Тогда
		Возврат "Отменена";
	ИначеЕсли СтатусВерхний = "NOTAPPLICABLE" Тогда
		Возврат "НеПрименимо";
	ИначеЕсли СтатусВерхний = "UNFINISHED" Тогда
		Возврат "НеЗавершена";
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяСтатусаТранзакции(Статус)
	
	Если Не ЗначениеЗаполнено(Статус) Тогда
		Возврат "";
	КонецЕсли;
	
	// Безопасное преобразование статуса в строку
	Попытка
		СтатусСтрока = XMLСтрока(Статус);
	Исключение
		// Если XMLСтрока не работает, пробуем через Строка()
		СтатусСтрока = Строка(Статус);
	КонецПопытки;
	
	Если Найти(СтатусСтрока, "Зафиксирована") > 0 Тогда
		Возврат "Committed";
	ИначеЕсли Найти(СтатусСтрока, "Отменена") > 0 Тогда
		Возврат "RolledBack";
	ИначеЕсли Найти(СтатусСтрока, "НеПрименимо") > 0 Тогда
		Возврат "NotApplicable";
	ИначеЕсли Найти(СтатусСтрока, "НеЗавершена") > 0 Тогда
		Возврат "Unfinished";
	Иначе
		Возврат "";
	КонецЕсли;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяУровня(Уровень)
	
	Если Уровень = УровеньЖурналаРегистрации.Информация Тогда
		Возврат "Information";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда
		Возврат "Warning";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Ошибка Тогда
		Возврат "Error";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Примечание Тогда
		Возврат "Note";
	Иначе
		Возврат Строка(Уровень);
	КонецЕсли;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПрочитатьДатуИзISO(СтрокаДаты)
	
	Если Не ЗначениеЗаполнено(СтрокаДаты) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		// Формат ISO 8601: YYYY-MM-DDTHH:MM:SS
		// Убираем возможный суффикс Z
		СтрокаДаты = СтрЗаменить(СтрокаДаты, "Z", "");
		
		Год = Число(Лев(СтрокаДаты, 4));
		Месяц = Число(Сред(СтрокаДаты, 6, 2));
		День = Число(Сред(СтрокаДаты, 9, 2));
		
		Час = 0;
		Минута = 0;
		Секунда = 0;
		
		Если СтрДлина(СтрокаДаты) >= 19 Тогда
			Час = Число(Сред(СтрокаДаты, 12, 2));
			Минута = Число(Сред(СтрокаДаты, 15, 2));
			Секунда = Число(Сред(СтрокаДаты, 18, 2));
		КонецЕсли;
		
		Возврат Дата(Год, Месяц, День, Час, Минута, Секунда);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// СОХРАНЕНИЕ И ЗАГРУЗКА НАСТРОЕК
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервере
Процедура ЗагрузитьНастройки()
	
	// Загрузка адреса сервера из хранилища настроек
	Попытка
		СохраненныйАдрес = ХранилищеОбщихНастроек.Загрузить("MCPToolkitКлиент", "АдресСервера");
		Если СохраненныйАдрес <> Неопределено И Не ПустаяСтрока(СохраненныйАдрес) Тогда
			АдресСервера = СохраненныйАдрес;
		КонецЕсли;
	Исключение
		// Настройки не найдены или ошибка загрузки
	КонецПопытки;
	
	// Загрузка идентификатора канала из хранилища настроек
	Попытка
		СохранённыйКанал = ХранилищеОбщихНастроек.Загрузить("MCPToolkitКлиент", "ИдентификаторКанала");
		Если СохранённыйКанал <> Неопределено Тогда
			ИдентификаторКанала = СохранённыйКанал;
		КонецЕсли;
	Исключение
		// Настройки не найдены или ошибка загрузки
	КонецПопытки;
	
КонецПроцедуры

&НаСервереБезКонтекста
Процедура СохранитьНастройкиНаСервере(Адрес)
	
	// Сохранение адреса сервера в хранилище настроек
	Попытка
		ХранилищеОбщихНастроек.Сохранить("MCPToolkitКлиент", "АдресСервера", Адрес);
	Исключение
		// Ошибка сохранения настроек
	КонецПопытки;
	
КонецПроцедуры

&НаСервереБезКонтекста
Процедура СохранитьИдентификаторКаналаНаСервере(Канал)
	
	// Сохранение идентификатора канала в хранилище настроек
	Попытка
		ХранилищеОбщихНастроек.Сохранить("MCPToolkitКлиент", "ИдентификаторКанала", Канал);
	Исключение
		// Ошибка сохранения настроек
	КонецПопытки;
	
КонецПроцедуры

&НаКлиенте
Процедура ИдентификаторКаналаПриИзменении(Элемент)
	
	// Сохраняем при изменении
	СохранитьИдентификаторКаналаНаСервере(ИдентификаторКанала);
	
КонецПроцедуры

&НаКлиенте
Процедура СгенерироватьИдентификаторКанала(Команда)
	
	// Генерация нового UUID для идентификатора канала
	ИдентификаторКанала = Строка(Новый УникальныйИдентификатор());
	СохранитьИдентификаторКаналаНаСервере(ИдентификаторКанала);
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

// Соединяет элементы массива в строку через разделитель
// Замена СтрСоединить() для совместимости с 8.2.13
&НаКлиентеНаСервереБезКонтекста
Функция СоединитьМассив(Массив, Разделитель = ", ")
	
	Если Массив = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	// Проверяем, является ли значение коллекцией
	Попытка
		Количество = Массив.Количество();
	Исключение
		// Если не коллекция, возвращаем как строку
		Возврат Строка(Массив);
	КонецПопытки;
	
	Если Количество = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	Первый = Истина;
	Для Каждого Элемент Из Массив Цикл
		Если Первый Тогда
			Первый = Ложь;
		Иначе
			Результат = Результат + Разделитель;
		КонецЕсли;
		Результат = Результат + Строка(Элемент);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, является ли значение коллекцией (массив, фиксированный массив и т.п.)
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоКоллекция(Значение)
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Количество = Значение.Количество();
		Возврат Количество > 0;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Процедура УстановитьСтатус(НовыйСтатус, НовоеСостояниеПодключения)
	
	Статус = НовыйСтатус;
	Подключено = НовоеСостояниеПодключения;
	
КонецПроцедуры

&НаКлиенте
Процедура ДобавитьВЛог(Сообщение)
	
	ВремяСообщения = Формат(ТекущаяДата(), "ДФ='HH:mm:ss'");
	НоваяСтрока = ВремяСообщения + " " + Сообщение;
	
	Если ПустаяСтрока(Лог) Тогда
		Лог = НоваяСтрока;
	Иначе
		Лог = НоваяСтрока + Символы.ПС + Лог;
	КонецЕсли;
	
	// Ограничение размера лога
	Если СтрДлина(Лог) > 10000 Тогда
		Лог = Лев(Лог, 10000);
	КонецЕсли;
	
КонецПроцедуры


// ─────────────────────────────────────────────────────────────────────────────────
// НАВИГАЦИОННЫЕ ССЫЛКИ
// ─────────────────────────────────────────────────────────────────────────────────

// Разбирает навигационную ссылку 1С и извлекает её компоненты
// Формат ссылки: e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
// Пример: e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка для разбора
//
// Возвращаемое значение:
//   Структура - с полями:
//     * ТипОбъекта - Строка - тип объекта (например, "Справочник", "Документ")
//     * ИмяОбъекта - Строка - имя объекта (например, "Контрагенты")
//     * HexGUID - Строка - шестнадцатеричный идентификатор (32 символа)
//
// Исключения:
//   Вызывает исключение с описательным сообщением при ошибке парсинга
//
&НаСервереБезКонтекста
Функция РазобратьНавигационнуюСсылку(НавигационнаяСсылка)
	
	// Проверка на пустую строку
	Если Не ЗначениеЗаполнено(НавигационнаяСсылка) Тогда
		ВызватьИсключение "Навигационная ссылка не может быть пустой / Navigation link cannot be empty";
	КонецЕсли;
	
	// Удаление пробелов по краям
	НавигационнаяСсылка = СокрЛП(НавигационнаяСсылка);
	
	// Проверка префикса e1cib/data/
	Префикс = "e1cib/data/";
	Если НРег(Лев(НавигационнаяСсылка, СтрДлина(Префикс))) <> НРег(Префикс) Тогда
		ВызватьИсключение "Неверный формат ссылки: должна начинаться с 'e1cib/data/' / Invalid link format: must start with 'e1cib/data/'";
	КонецЕсли;
	
	// Извлечение части после префикса
	ЧастьДанных = Сред(НавигационнаяСсылка, СтрДлина(Префикс) + 1);
	
	// Поиск параметра ref
	ПозицияВопроса = Найти(ЧастьДанных, "?");
	Если ПозицияВопроса = 0 Тогда
		ВызватьИсключение "Неверный формат ссылки: отсутствует параметр '?ref=' / Invalid link format: missing '?ref=' parameter";
	КонецЕсли;
	
	// Извлечение полного имени объекта (ТипОбъекта.ИмяОбъекта)
	ПолноеИмяОбъекта = Лев(ЧастьДанных, ПозицияВопроса - 1);
	
	// Проверка наличия точки в имени объекта
	ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
	Если ПозицияТочки = 0 Тогда
		ВызватьИсключение "Неверный формат имени объекта: ожидается 'ТипОбъекта.ИмяОбъекта', получено '" + ПолноеИмяОбъекта + "' / Invalid object name format: expected 'ObjectType.ObjectName', got '" + ПолноеИмяОбъекта + "'";
	КонецЕсли;
	
	// Извлечение типа и имени объекта
	ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки - 1);
	ИмяОбъекта = Сред(ПолноеИмяОбъекта, ПозицияТочки + 1);
	
	// Проверка что тип и имя не пустые
	Если Не ЗначениеЗаполнено(ТипОбъекта) Тогда
		ВызватьИсключение "Тип объекта не может быть пустым / Object type cannot be empty";
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИмяОбъекта) Тогда
		ВызватьИсключение "Имя объекта не может быть пустым / Object name cannot be empty";
	КонецЕсли;
	
	// Извлечение параметров после ?
	ЧастьПараметров = Сред(ЧастьДанных, ПозицияВопроса + 1);
	
	// Поиск параметра ref=
	ПозицияRef = Найти(НРег(ЧастьПараметров), "ref=");
	Если ПозицияRef = 0 Тогда
		ВызватьИсключение "Неверный формат ссылки: отсутствует параметр 'ref=' / Invalid link format: missing 'ref=' parameter";
	КонецЕсли;
	
	// Извлечение HexGUID
	HexGUID = Сред(ЧастьПараметров, ПозицияRef + 4);
	
	// Удаление возможных дополнительных параметров после &
	ПозицияАмперсанда = Найти(HexGUID, "&");
	Если ПозицияАмперсанда > 0 Тогда
		HexGUID = Лев(HexGUID, ПозицияАмперсанда - 1);
	КонецЕсли;
	
	// Удаление пробелов
	HexGUID = СокрЛП(HexGUID);
	
	// Проверка длины HexGUID (должно быть 32 символа)
	Если СтрДлина(HexGUID) <> 32 Тогда
		ВызватьИсключение "Неверная длина HexGUID: ожидается 32 символа, получено " + СтрДлина(HexGUID) + " / Invalid HexGUID length: expected 32 characters, got " + СтрДлина(HexGUID);
	КонецЕсли;
	
	// Проверка что HexGUID содержит только шестнадцатеричные символы
	ДопустимыеСимволы = "0123456789abcdefABCDEF";
	Для Позиция = 1 По 32 Цикл
		Символ = Сред(HexGUID, Позиция, 1);
		Если Найти(ДопустимыеСимволы, Символ) = 0 Тогда
			ВызватьИсключение "HexGUID содержит недопустимый символ '" + Символ + "' в позиции " + Позиция + ". Допускаются только шестнадцатеричные символы (0-9, a-f, A-F) / HexGUID contains invalid character '" + Символ + "' at position " + Позиция + ". Only hexadecimal characters (0-9, a-f, A-F) are allowed";
		КонецЕсли;
	КонецЦикла;
	
	// Формирование результата
	Результат = Новый Структура;
	Результат.Вставить("ТипОбъекта", ТипОбъекта);
	Результат.Вставить("ИмяОбъекта", ИмяОбъекта);
	Результат.Вставить("HexGUID", НРег(HexGUID)); // Приводим к нижнему регистру для единообразия
	
	Возврат Результат;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КонвертироватьHexGUIDвUUID
// Преобразует 32-символьный HexGUID в стандартный формат UUID (8-4-4-4-12)
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   HexGUID - Строка - шестнадцатеричный идентификатор без дефисов (32 символа)
//                      Пример: "80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   Строка - UUID в формате 8-4-4-4-12 с дефисами
//            Пример: "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5"
//
// Исключения:
//   Вызывает исключение если длина HexGUID не равна 32 символам
//
&НаСервереБезКонтекста
Функция КонвертироватьHexGUIDвUUID(HexGUID)
	
	// Валидация длины входной строки
	Если СтрДлина(HexGUID) <> 32 Тогда
		ВызватьИсключение "Неверная длина HexGUID: ожидается 32 символа, получено " + СтрДлина(HexGUID) + " / Invalid HexGUID length: expected 32 characters, got " + СтрДлина(HexGUID);
	КонецЕсли;
	
	// HexGUID в навигационной ссылке 1С имеет особый порядок байтов!
	// Входной HexGUID: 80c6cc1a7e58902811ebcda8cb07c0f5
	// Нужно переставить байты для получения правильного UUID
	//
	// Формат HexGUID в ссылке: AABBCCDD EEFF GGHH IIJJ KKLLMMNNOOPP
	// Формат UUID в 1С:        DDCCBBAA FFEE HHGG IIJJ KKLLMMNNOOPP
	//
	// Первые 4 байта (8 символов) - reverse
	// Следующие 2 байта (4 символа) - reverse  
	// Следующие 2 байта (4 символа) - reverse
	// Остальные 8 байт (16 символов) - без изменений
	
	Часть1 = Сред(HexGUID, 7, 2) + Сред(HexGUID, 5, 2) + Сред(HexGUID, 3, 2) + Сред(HexGUID, 1, 2);
	Часть2 = Сред(HexGUID, 11, 2) + Сред(HexGUID, 9, 2);
	Часть3 = Сред(HexGUID, 15, 2) + Сред(HexGUID, 13, 2);
	Часть4 = Сред(HexGUID, 17, 4);
	Часть5 = Сред(HexGUID, 21, 12);
	
	UUID = Часть1 + "-" + Часть2 + "-" + Часть3 + "-" + Часть4 + "-" + Часть5;
	
	Возврат UUID;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КонвертироватьUUIDвHexGUID
// Преобразует UUID в формате 8-4-4-4-12 в 32-символьный HexGUID для навигационной ссылки
// Обратная операция к КонвертироватьHexGUIDвUUID
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   UUID - Строка - уникальный идентификатор в формате 8-4-4-4-12 с дефисами
//                   Пример: "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5"
//
// Возвращаемое значение:
//   Строка - HexGUID без дефисов (32 символа) для использования в навигационной ссылке
//            Пример: "1acc6c80589028e711ebcda8cb07c0f5"
//
// Примечание:
//   HexGUID в навигационной ссылке 1С имеет особый порядок байтов (обратный к UUID)
//
&НаСервереБезКонтекста
Функция КонвертироватьUUIDвHexGUID(UUID)
	
	// Удаляем дефисы из UUID
	УникальныйИдентификатор = СтрЗаменить(UUID, "-", "");
	
	// Валидация длины
	Если СтрДлина(УникальныйИдентификатор) <> 32 Тогда
		ВызватьИсключение "Неверная длина UUID: ожидается 32 символа без дефисов, получено " + СтрДлина(УникальныйИдентификатор);
	КонецЕсли;
	
	// Обратная операция к КонвертироватьHexGUIDвUUID
	// UUID формат:     AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE
	// HexGUID формат:  DDDDEEEEEEEEEEEE CCCC BBBB AAAAAAAA
	//
	// Переставляем части в обратном порядке
	
	Часть1 = Сред(УникальныйИдентификатор, 1, 8);   // AAAAAAAA
	Часть2 = Сред(УникальныйИдентификатор, 9, 4);   // BBBB
	Часть3 = Сред(УникальныйИдентификатор, 13, 4);  // CCCC
	Часть4 = Сред(УникальныйИдентификатор, 17, 4);  // DDDD
	Часть5 = Сред(УникальныйИдентификатор, 21, 12); // EEEEEEEEEEEE
	
	// HexGUID = DDDD + EEEEEEEEEEEE + CCCC + BBBB + AAAAAAAA
	HexGUID = Часть4 + Часть5 + Часть3 + Часть2 + Часть1;
	
	Возврат НРег(HexGUID); // Приводим к нижнему регистру для единообразия
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// СформироватьНавигационнуюСсылку
// Формирует навигационную ссылку 1С по описанию объекта
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ОписаниеОбъекта - Структура - описание объекта с полями:
//     * _objectRef - Булево - признак описания объекта (должен быть true)
//     * УникальныйИдентификатор - Строка - UUID объекта
//     * ТипОбъекта - Строка - тип объекта (например, "СправочникСсылка.Контрагенты")
//
// Возвращаемое значение:
//   Строка - навигационная ссылка в формате e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//            Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Исключения:
//   Вызывает исключение если описание объекта некорректно
//
&НаСервереБезКонтекста
Функция СформироватьНавигационнуюСсылку(ОписаниеОбъекта)
	
	// Проверка что это описание объекта
	Если ТипЗнч(ОписаниеОбъекта) <> Тип("Структура") Тогда
		ВызватьИсключение "ОписаниеОбъекта должно быть структурой / objectDescription must be a structure";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("_objectRef") Или ОписаниеОбъекта._objectRef <> Истина Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует _objectRef = true / Invalid object description: missing _objectRef = true";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("УникальныйИдентификатор") Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует УникальныйИдентификатор / Invalid object description: missing УникальныйИдентификатор";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("ТипОбъекта") Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует ТипОбъекта / Invalid object description: missing ТипОбъекта";
	КонецЕсли;
	
	// Преобразуем тип объекта из формата "СправочникСсылка.Контрагенты" в "Справочник.Контрагенты"
	ТипОбъекта = ОписаниеОбъекта.ТипОбъекта;
	
	// Убираем "Ссылка" из типа
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "СправочникСсылка.", "Справочник.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ДокументСсылка.", "Документ.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПеречислениеСсылка.", "Перечисление.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланВидовХарактеристикСсылка.", "ПланВидовХарактеристик.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланСчетовСсылка.", "ПланСчетов.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланВидовРасчетаСсылка.", "ПланВидовРасчета.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "БизнесПроцессСсылка.", "БизнесПроцесс.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ЗадачаСсылка.", "Задача.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланОбменаСсылка.", "ПланОбмена.");
	
	// Конвертируем UUID в HexGUID
	HexGUID = КонвертироватьUUIDвHexGUID(ОписаниеОбъекта.УникальныйИдентификатор);
	
	// Формируем навигационную ссылку
	НавигационнаяСсылка = "e1cib/data/" + ТипОбъекта + "?ref=" + HexGUID;
	
	Возврат НавигационнаяСсылка;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьНавигационнуюСсылкуПоОписанию
// Обёртка для формирования навигационной ссылки с обработкой ошибок
// Используется в MCP-инструменте get_link_of_object
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ОписаниеОбъекта - Структура - описание объекта из результатов execute_query
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * link    - Строка - навигационная ссылка (при success = Истина)
//     * error   - Строка - описание ошибки (при success = Ложь)
//
&НаСервереБезКонтекста
Функция ПолучитьНавигационнуюСсылкуПоОписанию(ОписаниеОбъекта)
	
	Попытка
		
		НавигационнаяСсылка = СформироватьНавигационнуюСсылку(ОписаниеОбъекта);
		
		Возврат Новый Структура("success, data", Истина, НавигационнаяСсылка);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ВерсияПлатформыНеМеньше
// Проверяет, что версия текущей платформы не меньше указанной минимальной версии
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   МинимальнаяВерсия - Строка - минимальная требуемая версия платформы
//                                Пример: "8.3.3" или "8.2.13"
//
// Возвращаемое значение:
//   Булево - Истина, если текущая версия платформы >= минимальной версии
//            Ложь, если текущая версия платформы < минимальной версии
//
// Примечание:
//   Сравнение выполняется покомпонентно (8.3.25.1374 -> [8, 3, 25, 1374])
//   Не использует СтрРазделить для совместимости с 8.2.13
//
&НаСервереБезКонтекста
Функция ВерсияПлатформыНеМеньше(МинимальнаяВерсия)
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ВерсияПлатформы = СистемнаяИнформация.ВерсияПриложения;
	
	// Разбор версий в массивы компонентов
	// Не используем СтрРазделить для совместимости с 8.2.13
	ЧастиТекущей = РазделитьСтрокуПоРазделителю(ВерсияПлатформы, ".");
	ЧастиМинимальной = РазделитьСтрокуПоРазделителю(МинимальнаяВерсия, ".");
	
	// Определяем минимальное количество компонентов для сравнения
	КоличествоТекущей = ЧастиТекущей.Количество();
	КоличествоМинимальной = ЧастиМинимальной.Количество();
	
	Если КоличествоТекущей < КоличествоМинимальной Тогда
		МинимальноеКоличество = КоличествоТекущей;
	Иначе
		МинимальноеКоличество = КоличествоМинимальной;
	КонецЕсли;
	
	// Сравнение версий по компонентам
	Для Индекс = 0 По МинимальноеКоличество - 1 Цикл
		ТекущаяЧасть = Число(ЧастиТекущей[Индекс]);
		МинимальнаяЧасть = Число(ЧастиМинимальной[Индекс]);
		
		Если ТекущаяЧасть > МинимальнаяЧасть Тогда
			Возврат Истина;
		ИначеЕсли ТекущаяЧасть < МинимальнаяЧасть Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	// Все сравниваемые компоненты равны
	Возврат Истина;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// РазделитьСтрокуПоРазделителю
// Разделяет строку на массив подстрок по указанному разделителю
// Совместимость: 1С:Предприятие 8.2.13+ (замена СтрРазделить)
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Строка - Строка - исходная строка для разделения
//   Разделитель - Строка - символ-разделитель
//
// Возвращаемое значение:
//   Массив - массив подстрок
//
&НаСервереБезКонтекста
Функция РазделитьСтрокуПоРазделителю(Строка, Разделитель)
	
	Результат = Новый Массив;
	ОстатокСтроки = Строка;
	
	ПозицияРазделителя = Найти(ОстатокСтроки, Разделитель);
	
	Пока ПозицияРазделителя > 0 Цикл
		Часть = Лев(ОстатокСтроки, ПозицияРазделителя - 1);
		Результат.Добавить(Часть);
		ОстатокСтроки = Сред(ОстатокСтроки, ПозицияРазделителя + СтрДлина(Разделитель));
		ПозицияРазделителя = Найти(ОстатокСтроки, Разделитель);
	КонецЦикла;
	
	// Добавляем последнюю часть (или всю строку, если разделитель не найден)
	Результат.Добавить(ОстатокСтроки);
	
	Возврат Результат;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// НайтиОбъектВручную
// Находит объект 1С по навигационной ссылке без использования встроенного метода
// НайтиПоНавигационнойСсылке (для платформ < 8.3.3)
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка в формате
//                                  e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//                                  Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   СправочникСсылка, ДокументСсылка и т.д. - ссылка на найденный объект
//   Неопределено - если объект не найден
//
// Исключения:
//   Вызывает исключение при неверном формате ссылки или неподдерживаемом типе объекта
//
// Требования: 4.2
//
&НаСервереБезКонтекста
Функция НайтиОбъектВручную(НавигационнаяСсылка)

	// Парсинг навигационной ссылки с использованием существующей функции
	// Возвращает структуру с полями: ТипОбъекта, ИмяОбъекта, HexGUID
	РезультатПарсинга = РазобратьНавигационнуюСсылку(НавигационнаяСсылка);

	ТипОбъекта = РезультатПарсинга.ТипОбъекта;
	ИмяОбъекта = РезультатПарсинга.ИмяОбъекта;
	HexGUID = РезультатПарсинга.HexGUID;

	// Формируем полное имя типа для получения пустой ссылки
	ПолноеИмяТипа = ТипОбъекта + "." + ИмяОбъекта;

	// Получаем пустую ссылку нужного типа через предопределённое значение
	ПустаяСсылка = ПредопределенноеЗначение(ПолноеИмяТипа + ".ПустаяСсылка");

	// Преобразуем пустую ссылку во внутреннее строковое представление
	// Шаблон содержит строку с 32 нулями вместо GUID
	Шаблон = ЗначениеВСтрокуВнутр(ПустаяСсылка);

	// Заменяем нули на HexGUID из навигационной ссылки
	Значение = СтрЗаменить(Шаблон, "00000000000000000000000000000000", HexGUID);

	// Преобразуем обратно в ссылку 1С
	Возврат ЗначениеИзСтрокиВнутр(Значение);

КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьСсылкуПоТипуИUUID
// Получает ссылку на объект 1С по типу объекта, имени и UUID
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ТипОбъекта - Строка - тип объекта метаданных (Справочник, Документ и т.д.)
//                         Поддерживаются русские и английские имена типов
//   ИмяОбъекта - Строка - имя объекта метаданных (например, "Контрагенты")
//   UUID       - Строка - уникальный идентификатор в формате 8-4-4-4-12
//
// Возвращаемое значение:
//   СправочникСсылка, ДокументСсылка и т.д. - ссылка на объект
//
// Поддерживаемые типы объектов:
//   Русские: Справочник, Документ, ПланВидовХарактеристик, ПланСчетов,
//            ПланВидовРасчета, ПланОбмена, БизнесПроцесс, Задача
//   Английские: Catalog, Document, ChartOfCharacteristicTypes, ChartOfAccounts,
//               ChartOfCalculationTypes, ExchangePlan, BusinessProcess, Task
//
// Исключения:
//   Вызывает исключение при неподдерживаемом типе объекта
//
// Требования: 4.3, 6.2
//
&НаСервереБезКонтекста
Функция ПолучитьСсылкуПоТипуИUUID(ТипОбъекта, ИмяОбъекта, UUID)
	
	УникальныйИдентификатор = Новый УникальныйИдентификатор(UUID);
	
	Если ТипОбъекта = "Справочник" Или ТипОбъекта = "Catalog" Тогда
		Возврат Справочники[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "Документ" Или ТипОбъекта = "Document" Тогда
		Возврат Документы[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланВидовХарактеристик" Или ТипОбъекта = "ChartOfCharacteristicTypes" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланСчетов" Или ТипОбъекта = "ChartOfAccounts" Тогда
		Возврат ПланыСчетов[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланВидовРасчета" Или ТипОбъекта = "ChartOfCalculationTypes" Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "БизнесПроцесс" Или ТипОбъекта = "BusinessProcess" Тогда
		Возврат БизнесПроцессы[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "Задача" Или ТипОбъекта = "Task" Тогда
		Возврат Задачи[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланОбмена" Или ТипОбъекта = "ExchangePlan" Тогда
		Возврат ПланыОбмена[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	Иначе
		ВызватьИсключение "Неподдерживаемый тип объекта: " + ТипОбъекта + ". "
			+ "Поддерживаемые типы: Справочник (Catalog), Документ (Document), "
			+ "ПланВидовХарактеристик (ChartOfCharacteristicTypes), ПланСчетов (ChartOfAccounts), "
			+ "ПланВидовРасчета (ChartOfCalculationTypes), ПланОбмена (ExchangePlan), "
			+ "БизнесПроцесс (BusinessProcess), Задача (Task)";
	КонецЕсли;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьДанныеОбъекта
// Получает все данные объекта 1С (реквизиты и табличные части) по ссылке
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Ссылка - СправочникСсылка, ДокументСсылка и т.д. - ссылка на объект 1С
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * data    - Структура - данные объекта (при success = Истина):
//       * _type         - Строка - полное имя типа объекта (например, "Справочник.Контрагенты")
//       * _presentation - Строка - строковое представление ссылки
//       * Код           - Строка - код объекта (если есть)
//       * Наименование  - Строка - наименование объекта (если есть)
//       * Дата          - Дата - дата документа (если есть)
//       * Номер         - Строка - номер документа (если есть)
//       * <Реквизит>    - Произвольный - значения пользовательских реквизитов
//       * <ТабличнаяЧасть> - Массив - строки табличных частей
//     * error   - Строка - описание ошибки (при success = Ложь)
//
// Требования: 5.1, 5.2, 5.3, 5.4, 5.5
//
&НаСервереБезКонтекста
Функция ПолучитьДанныеОбъекта(Ссылка)
	
	Попытка
		Объект = Ссылка.ПолучитьОбъект();
		
		Если Объект = Неопределено Тогда
			// Отладка: показываем информацию о ссылке
			Возврат Новый Структура("success, error, debug", Ложь, 
				"Объект не найден или недостаточно прав доступа / Object not found or insufficient access rights",
				Новый Структура("СсылкаСтрока, СсылкаПустая", Строка(Ссылка), Ссылка.Пустая()));
		КонецЕсли;
		
		ДанныеОбъекта = Новый Структура;
		МетаданныеОбъекта = Ссылка.Метаданные();
		
		// Базовая информация
		ДанныеОбъекта.Вставить("_type", МетаданныеОбъекта.ПолноеИмя());
		ДанныеОбъекта.Вставить("_presentation", Строка(Ссылка));
		
		// Стандартные реквизиты (Код, Наименование, Дата, Номер)
		// Используем Попытка/Исключение, т.к. не все объекты имеют эти реквизиты
		Попытка
			ДанныеОбъекта.Вставить("Код", Объект.Код);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Наименование", Объект.Наименование);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Дата", Объект.Дата);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Номер", Объект.Номер);
		Исключение
		КонецПопытки;
		
		// Пользовательские реквизиты из метаданных
		Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
			Значение = Объект[Реквизит.Имя];
			ДанныеОбъекта.Вставить(Реквизит.Имя, ПреобразоватьЗначениеДляJSON(Значение));
		КонецЦикла;
		
		// Табличные части
		Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
			МассивСтрок = Новый Массив;
			
			Для Каждого СтрокаТЧ Из Объект[ТабличнаяЧасть.Имя] Цикл
				ДанныеСтроки = Новый Структура;
				ДанныеСтроки.Вставить("НомерСтроки", СтрокаТЧ.НомерСтроки);
				
				Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
					Значение = СтрокаТЧ[Реквизит.Имя];
					ДанныеСтроки.Вставить(Реквизит.Имя, ПреобразоватьЗначениеДляJSON(Значение));
				КонецЦикла;
				
				МассивСтрок.Добавить(ДанныеСтроки);
			КонецЦикла;
			
			ДанныеОбъекта.Вставить(ТабличнаяЧасть.Имя, МассивСтрок);
		КонецЦикла;
		
		Возврат Новый Структура("success, data", Истина, ДанныеОбъекта);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПреобразоватьЗначениеДляJSON
// Преобразует значение 1С в формат, совместимый с JSON
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Значение - Произвольный - значение для преобразования
//
// Возвращаемое значение:
//   Произвольный - преобразованное значение:
//     * Ссылки (СправочникСсылка, ДокументСсылка и т.д.) -> Строка (представление)
//     * Дата -> Дата (без изменений, JSON сериализатор обработает)
//     * Строка, Число, Булево -> без изменений
//     * Неопределено -> Неопределено (JSON сериализатор преобразует в null)
//     * Прочие типы -> Строка (строковое представление)
//
// Требования: 5.4
//
&НаСервереБезКонтекста
Функция ПреобразоватьЗначениеДляJSON(Значение)
	
	// Неопределено -> оставляем как есть (JSON сериализатор преобразует в null)
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	// Примитивные типы - оставляем без изменений
	Если ТипЗначения = Тип("Строка") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		// Дата - оставляем как есть, JSON сериализатор обработает
		Возврат Значение;
	КонецЕсли;
	
	// Проверка на ссылочные типы
	// Ссылки имеют метод Пустая() и Метаданные()
	Попытка
		Если Значение.Пустая() Тогда
			// Пустая ссылка - возвращаем пустую строку
			Возврат "";
		КонецЕсли;
		// Непустая ссылка - возвращаем строковое представление
		Возврат Строка(Значение);
	Исключение
		// Не ссылочный тип - продолжаем проверку
	КонецПопытки;
	
	// Перечисления - преобразуем в строку
	ОписаниеТипа = Строка(ТипЗначения);
	Если Найти(ОписаниеТипа, "ПеречислениеСсылка") > 0 Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
	// ФиксированныйМассив - преобразуем в обычный Массив
	Если ТипЗначения = Тип("ФиксированныйМассив") Тогда
		РезультатМассив = Новый Массив;
		Для Каждого Элемент Из Значение Цикл
			РезультатМассив.Добавить(ПреобразоватьЗначениеДляJSON(Элемент));
		КонецЦикла;
		Возврат РезультатМассив;
	КонецЕсли;
	
	// ОписаниеЗащитыОтОпасныхДействий (UnsafeOperationProtectionDescription) -> Булево
	// Возвращаем флаг ПредупреждатьОбОпасныхДействиях, чтобы в JSON было true/false
	Если ОписаниеТипа = "ОписаниеЗащитыОтОпасныхДействий" Тогда
		Попытка
			Возврат Значение.ПредупреждатьОбОпасныхДействиях;
		Исключение
			Возврат Строка(Значение);
		КонецПопытки;
	КонецЕсли;
	
	// Все остальные типы - преобразуем в строку
	Возврат Строка(Значение);
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьОбъектПоНавигационнойСсылке
// Главная функция для получения данных объекта 1С по навигационной ссылке
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка в формате
//                                  e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//                                  Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * data    - Структура - данные объекта (при success = Истина):
//       * _type         - Строка - полное имя типа объекта
//       * _presentation - Строка - строковое представление ссылки
//       * <Реквизиты>   - Произвольный - значения реквизитов объекта
//       * <ТабличныеЧасти> - Массив - строки табличных частей
//     * error   - Строка - описание ошибки (при success = Ложь)
//
// Алгоритм работы:
//   1. Использует ручной парсинг через НайтиОбъектВручную (универсальный метод)
//   2. Получает данные объекта через ПолучитьДанныеОбъекта
//   3. Обрабатывает ошибки и возвращает результат в стандартном формате
//
// Примечание:
//   Встроенный метод НайтиПоНавигационнойСсылке недоступен в контексте
//   &НаСервереБезКонтекста, поэтому используется универсальный ручной парсинг,
//   который работает на всех версиях платформы и во всех контекстах.
//
// Требования: 3.2, 3.3, 6.3, 6.4
//
&НаСервереБезКонтекста
Функция ПолучитьОбъектПоНавигационнойСсылке(НавигационнаяСсылка)
	
	Попытка
		// Парсинг ссылки для отладки
		РезультатПарсинга = РазобратьНавигационнуюСсылку(НавигационнаяСсылка);
		ТипОбъекта = РезультатПарсинга.ТипОбъекта;
		ИмяОбъекта = РезультатПарсинга.ИмяОбъекта;
		HexGUID = РезультатПарсинга.HexGUID;

		// Используем метод через внутреннее представление ссылки
		Ссылка = НайтиОбъектВручную(НавигационнаяСсылка);

		// Проверка результата поиска
		Если Ссылка = Неопределено Тогда
			Возврат Новый Структура("success, error, debug", Ложь,
				"Объект не найден по указанной ссылке / Object not found by specified link",
				Новый Структура("ТипОбъекта, ИмяОбъекта, HexGUID", ТипОбъекта, ИмяОбъекта, HexGUID));
		КонецЕсли;

		// Проверка на пустую ссылку
		Попытка
			Если Ссылка.Пустая() Тогда
				Возврат Новый Структура("success, error, debug", Ложь,
					"Ссылка пустая / Reference is empty",
					Новый Структура("ТипОбъекта, ИмяОбъекта, HexGUID", ТипОбъекта, ИмяОбъекта, HexGUID));
			КонецЕсли;
		Исключение
			// Если метод Пустая() недоступен, продолжаем
		КонецПопытки;

		// Получение данных объекта
		Возврат ПолучитьДанныеОбъекта(Ссылка);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции


// ═══════════════════════════════════════════════════════════════════════════════
// JSON ПАРСЕР И СЕРИАЛИЗАТОР
// Встроенный модуль для совместимости с режимом 8.2.13
// Основан на модуле Александра Переверзева (MIT License)
// ═══════════════════════════════════════════════════════════════════════════════

// JSON парсер
&НаКлиентеНаСервереБезКонтекста
Функция ПрочитатьJSON2(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь)
	
	Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции

// JSON сериализатор
&НаКлиентеНаСервереБезКонтекста
Функция ЗаписатьJSON2(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь)
	
	Возврат jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// НАСТРОЙКИ JSON
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()
	Возврат Истина;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаПолноеМаскированиеСимволов()
	Возврат Истина;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаМаскированиеКириллицы()
	Возврат Ложь;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()
	Возврат Ложь;
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// JSON ПАРСЕР
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	Альтернативный = (Стандарт = Неопределено) Или (Не Стандарт);
	Стандарт = (Стандарт = Неопределено) Или Стандарт;
	ПредставленияСсылок = (ПредставленияСсылок = Неопределено) Или ПредставленияСсылок;
	
	// Схема подстановок шестнадцатиричной системы
	СхемаПодстановок = Новый Соответствие;
	ШестнадцатиричнаяСистема = "0123456789abcdef";
	ДесятичноеЧисло = 0;
	Для ВторойРазряд = 1 По 16 Цикл
		Для ПервыйРазряд = 1 По 16 Цикл
			СхемаПодстановок.Вставить(Сред(ШестнадцатиричнаяСистема, ВторойРазряд, 1) + Сред(ШестнадцатиричнаяСистема, ПервыйРазряд, 1), ДесятичноеЧисло);
			ДесятичноеЧисло = ДесятичноеЧисло + 1;
		КонецЦикла;
	КонецЦикла;
	
	ВспомогательныеДанные = Новый Структура("ТипСтроки,СхемаПодстановок,АвтоматическиПриводитьКСтруктуре",
		Тип("Строка"),
		СхемаПодстановок,
		(НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре() = Истина));
	
	Индекс = 1;
	Длина = СтрДлина(Значение);
	СимволыФорматирования = " " + Символы.ВК + Символы.ПС + Символы.Таб;
	
	Если Стандарт Тогда
		jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
	КонецЕсли;
	
	Если (Индекс > Длина) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Истина);
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования)
	Пока (Индекс <= Длина) И Найти(СимволыФорматирования, Сред(Значение, Индекс, 1)) Цикл
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры


&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, ПервыйУровень)
	
	Символ = Сред(Значение, Индекс, 1);
	
	Если (Символ = """") Или (Символ = "'") Тогда
		// Строка
		Начало = Индекс;
		Пока Истина Цикл
			Подстрока = Сред(Значение, Индекс + 1, 384);
			Позиция = Найти(Подстрока, Символ);
			
			Если (Позиция > 0) Тогда
				Индекс = Индекс + Позиция;
				Откат = Индекс - 1;
				Маскировка = Ложь;
				Пока (Сред(Значение, Откат, 1) = "\") И Откат Цикл
					Маскировка = Не Маскировка;
					Откат = Откат - 1;
				КонецЦикла;
				Если НЕ Маскировка Тогда
					Прервать;
				КонецЕсли;
			Иначе
				Индекс = Индекс + 384;
				Если Индекс >= Длина Тогда
					Возврат Неопределено;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Результат = jsonПрочитатьСтроку(Сред(Значение, Начало + 1, Индекс - Начало - 1), Стандарт, Начало, ВспомогательныеДанные.СхемаПодстановок, (Символ = "'"));
		Индекс = Индекс + 1;
		
	ИначеЕсли (Символ = "[") Тогда
		// Массив
		Результат = Новый Массив;
		Индекс = Индекс + 1;
		Если Стандарт Тогда
			jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
		КонецЕсли;
		
		Символ = Сред(Значение, Индекс, 1);
		Если (Символ = "]") Тогда
			Индекс = Индекс + 1;
		Иначе
			Пока (Индекс <= Длина) Цикл
				Результат.Добавить(jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь));
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "]") Тогда
					Индекс = Индекс + 1;
					Прервать;
				ИначеЕсли (Символ = ",") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	ИначеЕсли (Символ = "{") Тогда
		// Объект
		Индекс = Индекс + 1;
		Если Стандарт Тогда
			jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
		КонецЕсли;
		
		Символ = Сред(Значение, Индекс, 1);
		Если (Символ = "}") Тогда
			Индекс = Индекс + 1;
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				Результат = Новый Структура;
			Иначе
				Результат = Новый Соответствие;
			КонецЕсли;
		Иначе
			Результат = Новый Соответствие;
			ТипСтроки = ВспомогательныеДанные.ТипСтроки;
			
			Пока (Индекс <= Длина) Цикл
				КлючЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = ":") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
				
				ЗначениеЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				Результат.Вставить(КлючЭлемента, ЗначениеЭлемента);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "}") Тогда
					Индекс = Индекс + 1;
					Прервать;
				ИначеЕсли (Символ = ",") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			// Преобразование в структуру
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				РезультатСтруктура = Новый Структура;
				Для Каждого Элемент Из Результат Цикл
					Попытка
						РезультатСтруктура.Вставить(Элемент.Ключ, Элемент.Значение);
					Исключение
						РезультатСтруктура = Результат;
						Прервать;
					КонецПопытки;
				КонецЦикла;
				Результат = РезультатСтруктура;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		// Примитивные типы
		Если (Символ = "n") Тогда
			Если (Сред(Значение, Индекс, 4) = "null") Тогда
				Индекс = Индекс + 4;
				Результат = Null;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли (Символ = "t") Тогда
			Если (Сред(Значение, Индекс, 4) = "true") Тогда
				Индекс = Индекс + 4;
				Результат = Истина;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли (Символ = "f") Тогда
			Если (Сред(Значение, Индекс, 5) = "false") Тогда
				Индекс = Индекс + 5;
				Результат = Ложь;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		Иначе
			// Число
			Начало = Индекс;
			Пока Найти("-+0123456789.eE", Символ) И (Индекс <= Длина) Цикл
				Индекс = Индекс + 1;
				Символ = Сред(Значение, Индекс, 1);
			КонецЦикла;
			
			Попытка
				Результат = Число(Сред(Значение, Начало, Индекс - Начало));
			Исключение
				Результат = 0;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Если Стандарт Тогда
		jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитатьСтроку(Значение, Стандарт, Индекс, СхемаПодстановок, ОдинарнаяКавычка)
	
	ПоследоавтельностьПеремаскировки = "\" + Символ(65535);
	
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение,
		"\\", ПоследоавтельностьПеремаскировки),
		"\/", "/"),
		"\b", Символ(008)),
		"\t", Символы.Таб),
		"\n", Символы.ПС),
		"\f", Символы.ПФ),
		"\r", Символы.ВК),
		"\""", """");
	
	// Демаскирование Юникод символов
	Позиция = Найти(Результат, "\u");
	Пока Позиция Цикл
		СтаршийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 2, 2))];
		МладшийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 4, 2))];
		Если (СтаршийБайт = Неопределено) Или (МладшийБайт = Неопределено) Тогда
			Прервать;
		КонецЕсли;
		Результат = СтрЗаменить(Результат, Сред(Результат, Позиция, 6), Символ(256 * СтаршийБайт + МладшийБайт));
		Позиция = Найти(Результат, "\u");
	КонецЦикла;
	
	Если ОдинарнаяКавычка Тогда
		Результат = СтрЗаменить(Результат, "\'", "'");
	КонецЕсли;
	
	Возврат СтрЗаменить(Результат, ПоследоавтельностьПеремаскировки, "\");
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// JSON СЕРИАЛИЗАТОР
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	ВспомогательныеДанные = Новый Структура("ПримитивныеТипы,Массивы,Структуры,Соответсвия,ТипДопустимыхКлючей",
		Новый ОписаниеТипов("Null,Булево,Число,Дата,УникальныйИдентификатор"),
		Новый ОписаниеТипов("Массив,ФиксированныйМассив"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),
		Новый ОписаниеТипов("Строка"));
	
	Если Стандарт Тогда
		Смещение = "";
		Отступ = " ";
		Табуляция = "    ";
		ПереносСтроки = Символы.ПС;
	Иначе
		Смещение = "";
		Отступ = "";
		Табуляция = "";
		ПереносСтроки = "";
	КонецЕсли;
	
	Возврат jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, (НастройкаПолноеМаскированиеСимволов() = Истина), (НастройкаМаскированиеКириллицы() = Истина));
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	Тип = ТипЗнч(Значение);
	
	// Строка
	Если (Тип = Тип("Строка")) Тогда
		Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	КонецЕсли;
	
	// Неопределено и примитивные типы
	Если ВспомогательныеДанные.ПримитивныеТипы.СодержитТип(Тип) Тогда
		Если (Значение = Null) Или (Значение = Неопределено) Тогда
			Возврат "null";
		ИначеЕсли (Тип = Тип("Дата")) Тогда
			Возврат """" + Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss; ДП=") + "Z""";
		ИначеЕсли (Тип = Тип("УникальныйИдентификатор")) Тогда
			Возврат """" + Значение + """";
		Иначе
			Возврат Формат(Значение, "ЧРД=.; ЧН=; ЧГ=; БЛ=false; БИ=true");
		КонецЕсли;
	КонецЕсли;
	
	// Структуры
	Если ВспомогательныеДанные.Структуры.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
		Иначе
			Возврат "{}";
		КонецЕсли;
	КонецЕсли;
	
	// Соответствия
	Если ВспомогательныеДанные.Соответсвия.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			ТипДопустимыхКлючей = ВспомогательныеДанные.ТипДопустимыхКлючей;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Ключ = Элемент.Ключ;
				Если ТипДопустимыхКлючей.СодержитТип(ТипЗнч(Ключ)) Тогда
					Ключ = jsonЗаписатьСтроку(Строка(Ключ), ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				Иначе
					Ключ = """" + Ключ + """";
				КонецЕсли;
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
		Иначе
			Возврат "{}";
		КонецЕсли;
	КонецЕсли;
	
	// Массивы
	Если ВспомогательныеДанные.Массивы.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		Иначе
			Возврат "[]";
		КонецЕсли;
	КонецЕсли;
	
	// Неподдерживаемые типы - преобразование в строку
	Возврат jsonЗаписатьСтроку(Строка(Значение), ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Маскирование служебных символов
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение,
		"\", "\\"),
		Символ(008), "\b"),
		Символы.Таб, "\t"),
		Символы.ПС, "\n"),
		Символы.ПФ, "\f"),
		Символы.ВК, "\r"),
		"""", "\""");
	
	// Маскирование специальных символов
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат,
		Символ(00), "\u0000"),
		Символ(01), "\u0001"),
		Символ(02), "\u0002"),
		Символ(03), "\u0003"),
		Символ(04), "\u0004"),
		Символ(05), "\u0005"),
		Символ(06), "\u0006"),
		Символ(07), "\u0007"),
		Символ(11), "\u000b"),
		Символ(14), "\u000e"),
		Символ(15), "\u000f"),
		Символ(16), "\u0010"),
		Символ(17), "\u0011"),
		Символ(18), "\u0012"),
		Символ(19), "\u0013"),
		Символ(20), "\u0014"),
		Символ(21), "\u0015"),
		Символ(22), "\u0016"),
		Символ(23), "\u0017"),
		Символ(24), "\u0018"),
		Символ(25), "\u0019"),
		Символ(26), "\u001a"),
		Символ(27), "\u001b"),
		Символ(28), "\u001c"),
		Символ(29), "\u001d"),
		Символ(30), "\u001e"),
		Символ(31), "\u001f");
	
	Возврат """" + Результат + """";
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КОНВЕРТАЦИЯ ССЫЛОЧНЫХ ТИПОВ
// ─────────────────────────────────────────────────────────────────────────────────

// Проверяет, является ли тип ссылочным типом данных
//
// Параметры:
//  ПроверяемыйТип - Тип - тип для проверки
//
// Возвращаемое значение:
//  Булево - Истина, если это ссылочный тип
//
&НаСервереБезКонтекста
Функция ЭтоСсылка(ПроверяемыйТип)
	
	Если ПроверяемыйТип = Тип("Неопределено") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Документы.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Задачи.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(ПроверяемыйТип);
	
КонецФункции

// Возвращает строковое представление типа ссылки
//
// Параметры:
//  Тип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - строковое представление типа (например, "СправочникСсылка.Контрагенты")
//
&НаСервереБезКонтекста
Функция СтроковоеПредставлениеТипа(Тип)
	
	Если Не ЭтоСсылка(Тип) Тогда
		Возврат Строка(Тип);
	КонецЕсли;
	
	ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
	ЧастиИмени = РазделитьСтрокуПоРазделителю(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() < 2 Тогда
		Возврат Строка(Тип);
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[1];
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "СправочникСсылка." + ИмяОбъекта;
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ДокументСсылка." + ИмяОбъекта;
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПеречислениеСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристикСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетовСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчетаСсылка." + ИмяОбъекта;
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцессСсылка." + ИмяОбъекта;
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ЗадачаСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбменаСсылка." + ИмяОбъекта;
	Иначе
		Возврат Строка(Тип);
	КонецЕсли;
	
КонецФункции

// Возвращает программное имя типа прикладного объекта/менеджера (если возможно),
// например: "СправочникОбъект.Организации" или "СправочникМенеджер.Организации".
// Для примитивных типов и неподдерживаемых типов возвращает Строка(ПроверяемыйТип).
//
// Параметры:
//  ПроверяемыйТип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - программное имя или строковое представление платформы
//
&НаСервереБезКонтекста
Функция СтроковоеПредставлениеПрикладногоТипа(ПроверяемыйТип)
	
	Если ПроверяемыйТип = Тип("Неопределено") Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	ПолноеИмя = "";
	Попытка
		ПолноеИмя = Метаданные.НайтиПоТипу(ПроверяемыйТип).ПолноеИмя();
	Исключение
		ПолноеИмя = "";
	КонецПопытки;
	
	Если ПустаяСтрока(ПолноеИмя) Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	ЧастиИмени = РазделитьСтрокуПоРазделителю(ПолноеИмя, ".");
	Если ЧастиИмени.Количество() < 2 Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	Префикс = ЧастиИмени[0];
	ИмяОбъекта = ЧастиИмени[1];
	
	ИмяТипаОбъекта = Префикс + "Объект." + ИмяОбъекта;
	Попытка
		Если Тип(ИмяТипаОбъекта) = ПроверяемыйТип Тогда
			Возврат ИмяТипаОбъекта;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	ИмяТипаМенеджера = Префикс + "Менеджер." + ИмяОбъекта;
	Попытка
		Если Тип(ИмяТипаМенеджера) = ПроверяемыйТип Тогда
			Возврат ИмяТипаМенеджера;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Возврат Строка(ПроверяемыйТип);
	
КонецФункции

// Возвращает полное строковое представление ОписанияТипов реквизита
// с учётом квалификаторов и программных имён ссылочных типов
//
// Параметры:
//  ОписаниеТипов - ОписаниеТипов - описание типов реквизита (.Тип)
//
// Возвращаемое значение:
//  Строка - строковое представление типов, например:
//    "Число(15, 3)", "Строка(100)", "Дата(ДатаВремя)", "Булево",
//    "СправочникСсылка.Номенклатура",
//    "Число(10, 0), СправочникСсылка.Номенклатура, ДокументСсылка.Заказ"
//
&НаСервереБезКонтекста
Функция ПолучитьСтроковоеПредставлениеОписанияТипов(ОписаниеТипов)

	МассивТипов = ОписаниеТипов.Типы();

	Если МассивТипов.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;

	МассивПредставлений = Новый Массив;

	Для Каждого ТекущийТип Из МассивТипов Цикл

		Если ТекущийТип = Тип("Число") Тогда
			КвЧисла = ОписаниеТипов.КвалификаторыЧисла;
			ПредставлениеЧисла = "Число(" + КвЧисла.Разрядность + ", " + КвЧисла.РазрядностьДробнойЧасти;
			Если КвЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
				ПредставлениеЧисла = ПредставлениеЧисла + ", Неотрицательный";
			КонецЕсли;
			МассивПредставлений.Добавить(ПредставлениеЧисла + ")");

		ИначеЕсли ТекущийТип = Тип("Строка") Тогда
			КвСтроки = ОписаниеТипов.КвалификаторыСтроки;
			Если КвСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
				ВидДлины = "Фиксированная";
			Иначе
				ВидДлины = "Переменная";
			КонецЕсли;
			МассивПредставлений.Добавить("Строка(" + КвСтроки.Длина + ", " + ВидДлины + ")");

		ИначеЕсли ТекущийТип = Тип("Дата") Тогда
			КвДаты = ОписаниеТипов.КвалификаторыДаты;
			Если КвДаты.ЧастиДаты = ЧастиДаты.Время Тогда
				МассивПредставлений.Добавить("Дата(Время)");
			ИначеЕсли КвДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
				МассивПредставлений.Добавить("Дата(Дата)");
			Иначе
				МассивПредставлений.Добавить("Дата(ДатаВремя)");
			КонецЕсли;

		ИначеЕсли ЭтоСсылка(ТекущийТип) Тогда
			МассивПредставлений.Добавить(СтроковоеПредставлениеТипа(ТекущийТип));

		Иначе
			МассивПредставлений.Добавить(СтроковоеПредставлениеПрикладногоТипа(ТекущийТип));

		КонецЕсли;

	КонецЦикла;

	Возврат СоединитьМассив(МассивПредставлений, ", ");

КонецФункции

// Преобразует ссылку на объект в описание объекта для передачи через MCP
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - ссылка на объект информационной базы
//
// Возвращаемое значение:
//  Структура - описание объекта с полями:
//    * _objectRef - Булево - признак описания объекта (всегда Истина)
//    * УникальныйИдентификатор - Строка - уникальный идентификатор объекта
//    * ТипОбъекта - Строка - строковое представление типа
//    * Представление - Строка - строковое представление объекта
//
&НаСервереБезКонтекста
Функция ОписаниеОбъектаПоСсылке(СсылкаНаОбъект)
	
	УникальныйИдентификатор = XMLСтрока(СсылкаНаОбъект);
	ТипОбъекта = СтроковоеПредставлениеТипа(ТипЗнч(СсылкаНаОбъект));
	Представление = Строка(СсылкаНаОбъект);
	
	ОписаниеОбъекта = Новый Структура;
	ОписаниеОбъекта.Вставить("_objectRef", Истина);
	ОписаниеОбъекта.Вставить("УникальныйИдентификатор", УникальныйИдентификатор);
	ОписаниеОбъекта.Вставить("ТипОбъекта", ТипОбъекта);
	ОписаниеОбъекта.Вставить("Представление", Представление);
	
	Возврат ОписаниеОбъекта;
	
КонецФункции

// Возвращает менеджер объекта по ссылке
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на объект
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер и т.д. - менеджер объекта
//
&НаСервереБезКонтекста
Функция МенеджерОбъектаПоСсылке(Ссылка)
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Преобразует описание объекта обратно в ссылку на объект информационной базы
//
// Параметры:
//  ОписаниеОбъекта - Структура, Произвольный - описание объекта или любое другое значение
//
// Возвращаемое значение:
//  ЛюбаяСсылка, Произвольный - ссылка на объект или исходное значение, если это не описание объекта
//
&НаСервереБезКонтекста
Функция ОбъектИнформационнойБазыПоОписанию(ОписаниеОбъекта)
	
	// Если это не структура - возвращаем как есть
	Если ТипЗнч(ОписаниеОбъекта) <> Тип("Структура") Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	// Проверяем, что это описание объекта
	Если Не ОписаниеОбъекта.Свойство("_objectRef") 
		Или ОписаниеОбъекта._objectRef <> Истина Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	// Проверяем наличие обязательных полей
	Если Не ОписаниеОбъекта.Свойство("УникальныйИдентификатор") 
		Или Не ОписаниеОбъекта.Свойство("ТипОбъекта") Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	Попытка
		// Создаём описание типа и получаем пустое значение нужного типа
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеОбъекта.ТипОбъекта);
		ПустоеЗначение = ОписаниеТипа.ПривестиЗначение();
		
		// Получаем менеджер объекта
		МенеджерОбъекта = МенеджерОбъектаПоСсылке(ПустоеЗначение);
		
		Если МенеджерОбъекта = Неопределено Тогда
			Возврат ОписаниеОбъекта;
		КонецЕсли;
		
		// Получаем ссылку по уникальному идентификатору
		Ссылка = МенеджерОбъекта.ПолучитьСсылку(
			Новый УникальныйИдентификатор(ОписаниеОбъекта.УникальныйИдентификатор)
		);
		
		Возврат Ссылка;
		
	Исключение
		// Если не удалось преобразовать - возвращаем исходное значение
		Возврат ОписаниеОбъекта;
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПОИСК ССЫЛОК НА ОБЪЕКТ (find_references_to_object)
// ─────────────────────────────────────────────────────────────────────────────────

// Главный обработчик инструмента find_references_to_object
//
// Параметры:
//  ОписаниеЦелевогоОбъекта - Структура - описание целевого объекта (_objectRef, УникальныйИдентификатор, ТипОбъекта)
//  ОбластиПоиска - Массив - массив строк: "documents", "catalogs", "information_registers" и т.д.
//  ФильтрМетаданных - Структура, Неопределено - {names?: Массив, name_mask?: Строка}
//  ЛимитНайденных - Число - максимум находок
//  ЛимитНаМетуОбъект - Число - максимум находок на один объект метаданных
//  БюджетВремениСек - Число - бюджет времени в секундах
//
// Возвращаемое значение:
//  Структура - результат с полями success, data или error
//
&НаСервереБезКонтекста
Функция НайтиСсылкиНаОбъект(ОписаниеЦелевогоОбъекта, ОбластиПоиска, ФильтрМетаданных,
	ЛимитНайденных, ЛимитНаМетуОбъект, БюджетВремениСек)

	// Валидация входных параметров
	Если ОписаниеЦелевогоОбъекта = Неопределено Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указан целевой объект (target_object_description) / Target object description is required");
	КонецЕсли;

	Если ОбластиПоиска = Неопределено Или ОбластиПоиска.Количество() = 0 Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указаны области поиска (search_scope) / Search scope is required");
	КонецЕсли;

	// Конвертация описания объекта в ссылку
	ЦелеваяСсылка = ОбъектИнформационнойБазыПоОписанию(ОписаниеЦелевогоОбъекта);

	// Проверка, что удалось конвертировать
	Если ТипЗнч(ЦелеваяСсылка) = Тип("Структура") Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не удалось определить объект по описанию / Could not resolve object from description");
	КонецЕсли;

	// Проверка, что это ссылочный тип
	ТипЦелевойСсылки = ТипЗнч(ЦелеваяСсылка);
	Если Не ЭтоСсылка(ТипЦелевойСсылки) Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Объект не является ссылочным типом / Object is not a reference type");
	КонецЕсли;

	// Этап 1 — поиск кандидатов (полей, которые могут содержать ссылку нужного типа)
	ПропущенныеИмена = Новый Массив;
	Кандидаты = НайтиКандидатовПолей(ТипЦелевойСсылки, ОбластиПоиска, ФильтрМетаданных, ПропущенныеИмена);

	// Этап 2 — выполнение запросов по кандидатам
	Находки = Новый Массив;
	КандидатовПроверено = 0;
	ТаймаутПревышен = Ложь;
	ВремяНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
	БюджетМиллисекунд = БюджетВремениСек * 1000;

	Для Каждого Кандидат Из Кандидаты Цикл

		// Проверка таймаута
		Если (ТекущаяУниверсальнаяДатаВМиллисекундах() - ВремяНачала) >= БюджетМиллисекунд Тогда
			ТаймаутПревышен = Истина;
			Прервать;
		КонецЕсли;

		// Проверка общего лимита
		Если Находки.Количество() >= ЛимитНайденных Тогда
			Прервать;
		КонецЕсли;

		// Оставшийся лимит для этого кандидата
		ОстатокОбщий = ЛимитНайденных - Находки.Количество();
		ЛимитДляКандидата = Мин(ЛимитНаМетуОбъект, ОстатокОбщий);

		// Запрос ссылок в кандидате
		НовыеНаходки = ЗапроситьСсылкиВКандидате(ЦелеваяСсылка, Кандидат, ЛимитДляКандидата);

		Для Каждого Находка Из НовыеНаходки Цикл
			Если Находки.Количество() >= ЛимитНайденных Тогда
				Прервать;
			КонецЕсли;
			Находки.Добавить(Находка);
		КонецЦикла;

		КандидатовПроверено = КандидатовПроверено + 1;

	КонецЦикла;

	// Формирование результата
	Данные = Новый Структура;
	Данные.Вставить("hits", Находки);
	Данные.Вставить("total_hits", Находки.Количество());
	Данные.Вставить("candidates_checked", КандидатовПроверено);
	Данные.Вставить("timeout_exceeded", ТаймаутПревышен);
	Данные.Вставить("skipped_names", ПропущенныеИмена);

	Возврат Новый Структура("success, data", Истина, Данные);

КонецФункции

// Этап 1 — обход метаданных и поиск полей-кандидатов, содержащих нужный тип ссылки
//
// Параметры:
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ОбластиПоиска - Массив - массив строк областей поиска
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных {names, name_mask}
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён {name, reason}
//
// Возвращаемое значение:
//  Массив - массив структур-кандидатов {meta_name, field_name, field_kind, tabular_section, has_ref}
//
&НаСервереБезКонтекста
Функция НайтиКандидатовПолей(ТипЦелевойСсылки, ОбластиПоиска, ФильтрМетаданных, ПропущенныеИмена)

	Кандидаты = Новый Массив;

	// Формирование соответствия scope → коллекция метаданных
	Для Каждого Область Из ОбластиПоиска Цикл

		Если Область = "documents" Тогда
			ПроверитьКоллекциюМетаданных(Метаданные.Документы, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты, Истина);

		ИначеЕсли Область = "catalogs" Тогда
			ПроверитьКоллекциюМетаданных(Метаданные.Справочники, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты, Истина);

		ИначеЕсли Область = "information_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыСведений, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "accumulation_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыНакопления, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "accounting_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыБухгалтерии, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "calculation_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыРасчета, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);
		КонецЕсли;

	КонецЦикла;

	// Проверка skipped_names: какие имена из meta_filter.names не найдены или не соответствуют scope
	Если ФильтрМетаданных <> Неопределено
		И ТипЗнч(ФильтрМетаданных) = Тип("Структура")
		И ФильтрМетаданных.Свойство("names")
		И ФильтрМетаданных.names <> Неопределено
		И ТипЗнч(ФильтрМетаданных.names) = Тип("Массив")
		И ФильтрМетаданных.names.Количество() > 0 Тогда

		// Соответствие типов метаданных областям поиска
		СоответствиеТиповОбластям = Новый Соответствие;
		СоответствиеТиповОбластям.Вставить("Документ", "documents");
		СоответствиеТиповОбластям.Вставить("Справочник", "catalogs");
		СоответствиеТиповОбластям.Вставить("РегистрСведений", "information_registers");
		СоответствиеТиповОбластям.Вставить("РегистрНакопления", "accumulation_registers");
		СоответствиеТиповОбластям.Вставить("РегистрБухгалтерии", "accounting_registers");
		СоответствиеТиповОбластям.Вставить("РегистрРасчета", "calculation_registers");

		// Множество запрошенных областей для быстрой проверки
		МножествоОбластей = Новый Соответствие;
		Для Каждого Область Из ОбластиПоиска Цикл
			МножествоОбластей.Вставить(Область, Истина);
		КонецЦикла;

		Для Каждого ИмяФильтра Из ФильтрМетаданных.names Цикл
			// Проверяем существование объекта в метаданных
			НайденныйОбъект = Метаданные.НайтиПоПолномуИмени(ИмяФильтра);

			Если НайденныйОбъект = Неопределено Тогда
				Пропуск = Новый Структура("name, reason", ИмяФильтра,
					"не найден в метаданных / not found in metadata");
				ПропущенныеИмена.Добавить(Пропуск);
				Продолжить;
			КонецЕсли;

			// Проверяем соответствие типа метаданных областям поиска
			ЧастиИмени = РазделитьСтрокуПоРазделителю(ИмяФильтра, ".");
			Если ЧастиИмени.Количество() >= 1 Тогда
				ПрефиксТипа = ЧастиИмени[0];
				ОбластьДляТипа = СоответствиеТиповОбластям.Получить(ПрефиксТипа);

				Если ОбластьДляТипа <> Неопределено
					И МножествоОбластей.Получить(ОбластьДляТипа) = Неопределено Тогда
					Пропуск = Новый Структура("name, reason", ИмяФильтра,
						"не соответствует области поиска (search_scope) / does not match search_scope");
					ПропущенныеИмена.Добавить(Пропуск);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат Кандидаты;

КонецФункции

// Проверяет коллекцию метаданных документов/справочников на наличие полей с нужным типом ссылки
//
// Параметры:
//  КоллекцияМетаданных - КоллекцияОбъектовМетаданных - коллекция (Метаданные.Документы и т.п.)
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён
//  Кандидаты - Массив - (выходной) массив найденных кандидатов
//  ЕстьСсылка - Булево - имеет ли объект поле Ссылка
//
&НаСервереБезКонтекста
Процедура ПроверитьКоллекциюМетаданных(КоллекцияМетаданных, ТипЦелевойСсылки,
	ФильтрМетаданных, ПропущенныеИмена, Кандидаты, ЕстьСсылка)

	Для Каждого ОбъектМетаданных Из КоллекцияМетаданных Цикл

		// Проверка фильтра метаданных
		Если Не ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена) Тогда
			Продолжить;
		КонецЕсли;

		ПолноеИмяМета = ОбъектМетаданных.ПолноеИмя();

		// Проверка реквизитов шапки
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Реквизит.Имя, "attribute", "", ЕстьСсылка));
			КонецЕсли;
		КонецЦикла;

		// Проверка табличных частей
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
					Кандидаты.Добавить(Новый Структура(
						"meta_name, field_name, field_kind, tabular_section, has_ref",
						ПолноеИмяМета, Реквизит.Имя, "tabular_section", ТабличнаяЧасть.Имя, ЕстьСсылка));
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

// Проверяет коллекцию метаданных регистров на наличие полей с нужным типом ссылки
//
// Параметры:
//  КоллекцияМетаданных - КоллекцияОбъектовМетаданных - коллекция регистров
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён
//  Кандидаты - Массив - (выходной) массив найденных кандидатов
//
&НаСервереБезКонтекста
Процедура ПроверитьКоллекциюРегистров(КоллекцияМетаданных, ТипЦелевойСсылки,
	ФильтрМетаданных, ПропущенныеИмена, Кандидаты)

	Для Каждого ОбъектМетаданных Из КоллекцияМетаданных Цикл

		// Проверка фильтра метаданных
		Если Не ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена) Тогда
			Продолжить;
		КонецЕсли;

		ПолноеИмяМета = ОбъектМетаданных.ПолноеИмя();

		// Проверка измерений
		Для Каждого Измерение Из ОбъектМетаданных.Измерения Цикл
			Если Измерение.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Измерение.Имя, "dimension", "", Ложь));
			КонецЕсли;
		КонецЦикла;

		// Проверка ресурсов
		Для Каждого Ресурс Из ОбъектМетаданных.Ресурсы Цикл
			Если Ресурс.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Ресурс.Имя, "resource", "", Ложь));
			КонецЕсли;
		КонецЦикла;

		// Проверка реквизитов регистра
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Реквизит.Имя, "requisite", "", Ложь));
			КонецЕсли;
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

// Проверяет, проходит ли объект метаданных фильтр поиска (meta_filter)
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - проверяемый объект метаданных
//  ФильтрМетаданных - Структура, Неопределено - фильтр {names?: Массив, name_mask?: Строка}
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён (не используется при маске)
//
// Возвращаемое значение:
//  Булево - Истина, если объект прошёл фильтр
//
&НаСервереБезКонтекста
Функция ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена)

	// Если фильтр не задан — проходит всё
	Если ФильтрМетаданных = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Если ТипЗнч(ФильтрМетаданных) <> Тип("Структура") Тогда
		Возврат Истина;
	КонецЕсли;

	ПолноеИмяОбъекта = ОбъектМетаданных.ПолноеИмя();

	// Приоритет 1: names (точное совпадение, регистронезависимо)
	Если ФильтрМетаданных.Свойство("names") И ФильтрМетаданных.names <> Неопределено
		И ТипЗнч(ФильтрМетаданных.names) = Тип("Массив") И ФильтрМетаданных.names.Количество() > 0 Тогда

		ПолноеИмяВерх = ВРег(ПолноеИмяОбъекта);

		Для Каждого ИмяФильтра Из ФильтрМетаданных.names Цикл
			Если ВРег(ИмяФильтра) = ПолноеИмяВерх Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;

		// Не найдено в списке имён
		Возврат Ложь;
	КонецЕсли;

	// Приоритет 2: name_mask (подстрока в имени или синониме)
	Если ФильтрМетаданных.Свойство("name_mask") И ЗначениеЗаполнено(ФильтрМетаданных.name_mask) Тогда
		МаскаВерхнийРегистр = ВРег(ФильтрМетаданных.name_mask);
		Возврат ПрошелФильтрПоМаске(ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним, МаскаВерхнийРегистр);
	КонецЕсли;

	// Ни names, ни name_mask не заданы — проходит всё
	Возврат Истина;

КонецФункции

// Этап 2 — выполнение запроса для одного кандидата и формирование находок
//
// Параметры:
//  ЦелеваяСсылка - ЛюбаяСсылка - ссылка на целевой объект
//  Кандидат - Структура - описание кандидата {meta_name, field_name, field_kind, tabular_section, has_ref}
//  Лимит - Число - максимальное количество находок для этого кандидата
//
// Возвращаемое значение:
//  Массив - массив структур-находок
//
&НаСервереБезКонтекста
Функция ЗапроситьСсылкиВКандидате(ЦелеваяСсылка, Кандидат, Лимит)

	Находки = Новый Массив;

	Попытка

		ИмяМета = Кандидат.meta_name;
		ИмяПоля = Кандидат.field_name;
		ВидПоля = Кандидат.field_kind;
		ТабличнаяЧасть = Кандидат.tabular_section;
		ЕстьСсылка = Кандидат.has_ref;
		ЛимитСтрока = Формат(Лимит, "ЧГ=");

		Если ВидПоля = "attribute" И ЕстьСсылка Тогда
			// Реквизит шапки документа/справочника
			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока
				+ " Т.Ссылка КАК Ссылка"
				+ " ИЗ " + ИмяМета + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл
				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", ОписаниеОбъектаПоСсылке(Выборка.Ссылка));
				Находка.Вставить("path", ИмяПоля);
				Находка.Вставить("match_kind", "attribute");
				Находка.Вставить("note", Строка(Выборка.Ссылка));
				Находки.Добавить(Находка);
			КонецЦикла;

		ИначеЕсли ВидПоля = "tabular_section" И ЕстьСсылка Тогда
			// Реквизит табличной части документа/справочника
			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока
				+ " РАЗЛИЧНЫЕ Т.Ссылка КАК Ссылка"
				+ " ИЗ " + ИмяМета + "." + ТабличнаяЧасть + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл
				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", ОписаниеОбъектаПоСсылке(Выборка.Ссылка));
				Находка.Вставить("path", ТабличнаяЧасть + "." + ИмяПоля);
				Находка.Вставить("match_kind", "tabular_section");
				Находка.Вставить("note", Строка(Выборка.Ссылка));
				Находки.Добавить(Находка);
			КонецЦикла;

		Иначе
			// Регистр (dimension, resource, requisite)
			// Определяем объект метаданных регистра для построения списка полей выборки
			ОбъектМетаданныхРегистра = Метаданные.НайтиПоПолномуИмени(ИмяМета);

			Если ОбъектМетаданныхРегистра = Неопределено Тогда
				Возврат Находки;
			КонецЕсли;

			// Формируем список полей для выборки: все измерения
			ПоляВыборки = Новый Массив;
			ИменаИзмерений = Новый Массив;

			Для Каждого Измерение Из ОбъектМетаданныхРегистра.Измерения Цикл
				ПоляВыборки.Добавить("Т." + Измерение.Имя + " КАК " + Измерение.Имя);
				ИменаИзмерений.Добавить(Измерение.Имя);
			КонецЦикла;

			// Определяем тип регистра
			ЕстьПериод = Ложь;
			ПолноеИмяЧасти = РазделитьСтрокуПоРазделителю(ИмяМета, ".");
			ТипРегистра = "";
			Если ПолноеИмяЧасти.Количество() >= 1 Тогда
				ТипРегистра = ПолноеИмяЧасти[0];
			КонецЕсли;

			// Период — для периодических регистров сведений
			Если ТипРегистра = "РегистрСведений" Тогда
				Попытка
					Если ОбъектМетаданныхРегистра.ПериодичностьРегистраСведений
						<> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
						ПоляВыборки.Добавить("Т.Период КАК Период");
						ЕстьПериод = Истина;
					КонецЕсли;
				Исключение
					// Не удалось определить периодичность — пропускаем Период
				КонецПопытки;

			// Период — для регистров накопления и бухгалтерии (всегда есть)
			ИначеЕсли ТипРегистра = "РегистрНакопления"
				Или ТипРегистра = "РегистрБухгалтерии" Тогда
				ПоляВыборки.Добавить("Т.Период КАК Период");
				ЕстьПериод = Истина;
			КонецЕсли;

			// Регистратор — для регистров накопления, бухгалтерии, расчёта
			ЕстьРегистратор = Ложь;
			Если ТипРегистра = "РегистрНакопления"
				Или ТипРегистра = "РегистрБухгалтерии"
				Или ТипРегистра = "РегистрРасчета" Тогда
				ПоляВыборки.Добавить("Т.Регистратор КАК Регистратор");
				ЕстьРегистратор = Истина;
			КонецЕсли;

			Если ПоляВыборки.Количество() = 0 Тогда
				Возврат Находки;
			КонецЕсли;

			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока + " "
				+ СоединитьМассив(ПоляВыборки, ", ")
				+ " ИЗ " + ИмяМета + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл

				// Формируем record_key
				КлючЗаписи = Новый Структура;
				ЧастиПримечания = Новый Массив;

				Для Каждого ИмяИзмерения Из ИменаИзмерений Цикл
					ЗначениеИзмерения = Выборка[ИмяИзмерения];
					ТипЗначенияИзм = ТипЗнч(ЗначениеИзмерения);

					Если ЭтоСсылка(ТипЗначенияИзм) И ЗначениеЗаполнено(ЗначениеИзмерения) Тогда
						КлючЗаписи.Вставить(ИмяИзмерения, ОписаниеОбъектаПоСсылке(ЗначениеИзмерения));
					Иначе
						КлючЗаписи.Вставить(ИмяИзмерения, БезопасноеЗначениеДляПередачи(ЗначениеИзмерения));
					КонецЕсли;

					ЧастиПримечания.Добавить(ИмяИзмерения + "=" + Строка(ЗначениеИзмерения));
				КонецЦикла;

				// Период
				Если ЕстьПериод Тогда
					ЗначениеПериода = Выборка.Период;
					КлючЗаписи.Вставить("Период", БезопасноеЗначениеДляПередачи(ЗначениеПериода));
					ЧастиПримечания.Добавить("Период=" + Строка(ЗначениеПериода));
				КонецЕсли;

				// Регистратор
				Если ЕстьРегистратор Тогда
					ЗначениеРегистратора = Выборка.Регистратор;
					Если ЗначениеЗаполнено(ЗначениеРегистратора) Тогда
						КлючЗаписи.Вставить("Регистратор", ОписаниеОбъектаПоСсылке(ЗначениеРегистратора));
					Иначе
						КлючЗаписи.Вставить("Регистратор", Неопределено);
					КонецЕсли;
					ЧастиПримечания.Добавить("Регистратор=" + Строка(ЗначениеРегистратора));
				КонецЕсли;

				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", Неопределено);
				Находка.Вставить("record_key", КлючЗаписи);
				Находка.Вставить("path", ИмяПоля);
				Находка.Вставить("match_kind", ВидПоля);
				Находка.Вставить("note", СоединитьМассив(ЧастиПримечания, "; "));
				Находки.Добавить(Находка);

			КонецЦикла;

		КонецЕсли;

	Исключение
		// Ошибка выполнения запроса — пропускаем этого кандидата
	КонецПопытки;

	Возврат Находки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПРАВА ДОСТУПА (get_access_rights)
// ─────────────────────────────────────────────────────────────────────────────────

// Главная функция инструмента get_access_rights
//
// Параметры:
//  ИмяОбъектаМетаданных - Строка - полное имя объекта метаданных (например, "Справочник.Контрагенты")
//  ИмяПользователяИБ - Строка, Неопределено - имя пользователя для эффективных прав
//  ФильтрПрав - Массив, Неопределено - список прав для отображения
//  ФильтрРолей - Массив, Неопределено - список ролей для отображения
//
// Возвращаемое значение:
//  Структура - результат с полями success, data или error
//
&НаСервереБезКонтекста
Функция ПолучитьПраваДоступа(ИмяОбъектаМетаданных, ИмяПользователяИБ, ФильтрПрав, ФильтрРолей)

	// 1. Проверка привилегированного режима
	Если ПривилегированныйРежим() Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Инструмент не работает в привилегированном режиме / Tool does not work in privileged mode");
	КонецЕсли;

	// 2. Валидация обязательных параметров
	Если Не ЗначениеЗаполнено(ИмяОбъектаМетаданных) Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указан объект метаданных (metadata_object) / Metadata object is required");
	КонецЕсли;

	// 3. Поиск объекта метаданных
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяОбъектаМетаданных);
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Объект метаданных не найден: " + ИмяОбъектаМетаданных +
			" / Metadata object not found: " + ИмяОбъектаМетаданных);
	КонецЕсли;

	// 4. Определение типа метаданных
	ТипМетаданных = ОпределитьТипМетаданных(ОбъектМетаданных);
	Если ТипМетаданных = "Unknown" Тогда
		// Для поддержки всех типов метаданных не заваливаемся ошибкой.
		// В этом случае возвращаем тип как префикс из metadata_object и используем права по умолчанию.
		ТипМетаданных = ПолучитьПрефиксМетаданныхИзИмени(ИмяОбъектаМетаданных);
		Если ТипМетаданных = "Unknown" Тогда
			ТипМетаданных = "Другое";
		КонецЕсли;
	КонецЕсли;

	// 5. Получение применимых прав
	ПрименимыеПрава = ПолучитьПраваПоТипам();
	ПраваПоТипу = ПрименимыеПрава.Получить(ТипМетаданных);
	Если ПраваПоТипу = Неопределено Тогда
		// Права не определены для этого типа — используем универсальный список по умолчанию
		ПраваПоТипу = ПолучитьПраваПоУмолчанию();
	КонецЕсли;

	// 6. Применение фильтра прав
	ПраваДляПроверки = Новый Массив;
	Если ФильтрПрав <> Неопределено И ЭтоКоллекция(ФильтрПрав) И ФильтрПрав.Количество() > 0 Тогда
		Для Каждого ПравоИзФильтра Из ФильтрПрав Цикл
			ПравоИзФильтра = СокрЛП(ПравоИзФильтра);
			Если ПравоИзФильтра <> "" Тогда
				ПраваДляПроверки.Добавить(ПравоИзФильтра);
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Используем дефолтный список по типу
		Для Каждого Право Из ПраваПоТипу Цикл
			ПраваДляПроверки.Добавить(Право);
		КонецЦикла;
	КонецЕсли;

	// 6.1 Предварительная проверка админ-прав
	//
	// Вызовы ПравоДоступа() с 3-м параметром (роль/пользователь) требуют административных прав.
	// Чтобы не "тихо" получить все false (из-за Исключение), проверяем это заранее на заведомо
	// корректном праве из дефолтного списка.
	ПроверочноеПраво = "";
	Если ПраваПоТипу <> Неопределено И ЭтоКоллекция(ПраваПоТипу) И ПраваПоТипу.Количество() > 0 Тогда
		ПроверочноеПраво = ПраваПоТипу[0];
	ИначеЕсли ПраваДляПроверки <> Неопределено И ПраваДляПроверки.Количество() > 0 Тогда
		ПроверочноеПраво = ПраваДляПроверки[0];
	КонецЕсли;

	Если ЗначениеЗаполнено(ПроверочноеПраво) Тогда
		ПерваяРоль = Неопределено;
		Для Каждого Роль0 Из Метаданные.Роли Цикл
			ПерваяРоль = Роль0;
			Прервать;
		КонецЦикла;

		Если ПерваяРоль <> Неопределено Тогда
			ПравоКорректно = Истина;
			Попытка
				// Без 3-го параметра исключений быть не должно (проверка на корректность права/объекта)
				ПравоДоступа(ПроверочноеПраво, ОбъектМетаданных);
			Исключение
				ПравоКорректно = Ложь;
			КонецПопытки;

			Если ПравоКорректно Тогда
				Попытка
					// Проверка наличия админ-прав (с 3-м параметром)
					ПравоДоступа(ПроверочноеПраво, ОбъектМетаданных, ПерваяРоль);
				Исключение
					Возврат Новый Структура("success, error", Ложь,
						"Требуются административные права / Admin rights required");
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// 7. Получение прав ролей
	МассивРолей = Новый Массив;
	ИспользованФильтрРолей = (ФильтрРолей <> Неопределено И ЭтоКоллекция(ФильтрРолей) И ФильтрРолей.Количество() > 0);
	ЕстьЯвноеЗначениеРолейФильтр = Ложь;

	Для Каждого РольМетаданных Из Метаданные.Роли Цикл
		ИмяРоли = РольМетаданных.Имя;

		// Применение фильтра ролей
		Если ИспользованФильтрРолей Тогда
			НайденоВФильтре = Ложь;
			Для Каждого ИмяИзФильтра Из ФильтрРолей Цикл
				Если ВРег(СокрЛП(ИмяИзФильтра)) = ВРег(ИмяРоли) Тогда
					НайденоВФильтре = Истина;
					ЕстьЯвноеЗначениеРолейФильтр = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не НайденоВФильтре Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Проверка прав роли на объект
		ПраваРоли = Новый Структура;
		ЕстьХотяБыОдноПраво = Ложь;
		РольИмеетПраваНаОбъект = Ложь;

		Для Каждого ИмяПрава Из ПраваДляПроверки Цикл
			ЕстьПравоНаМетаданные = Ложь;
			Попытка
				// Проверка права для роли (требует админ-прав!)
				ЕстьПравоНаМетаданные = ПравоДоступа(ИмяПрава, ОбъектМетаданных, РольМетаданных);
				ПраваРоли.Вставить(ИмяПрава, ЕстьПравоНаМетаданные);
				Если ЕстьПравоНаМетаданные Тогда
					ЕстьХотяБыОдноПраво = Истина;
					РольИмеетПраваНаОбъект = Истина;
				КонецЕсли;
			Исключение
				// Любая ошибка проверки конкретного права трактуется как отсутствие права
				// (в т.ч. неприменимое право или неизвестное имя права).
				ПраваРоли.Вставить(ИмяПрава, Ложь);
			КонецПопытки;
		КонецЦикла;

		// Добавление роли в результат
		// Без фильтра: только роли с правами
		// С фильтром: все роли из фильтра (даже если все false)
		Если ЕстьХотяБыОдноПраво Или (ИспользованФильтрРолей И ЕстьЯвноеЗначениеРолейФильтр) Тогда
			СтруктураРоли = Новый Структура;
			СтруктураРоли.Вставить("name", ИмяРоли);
			СтруктураРоли.Вставить("synonym", РольМетаданных.Синоним);
			СтруктураРоли.Вставить("rights", ПраваРоли);
			МассивРолей.Добавить(СтруктураРоли);
		КонецЕсли;
	КонецЦикла;

	// 8. Подсчёт статистики
	ВсегоРолей = МассивРолей.Количество();
	РолейСПравами = 0;
	Для Каждого ДанныеРоли Из МассивРолей Цикл
		Для Каждого КлючЗначение Из ДанныеРоли.rights Цикл
			Если КлючЗначение.Значение = Истина Тогда
				РолейСПравами = РолейСПравами + 1;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	// 9. Сортировка ролей по имени
	МассивРолей = СортироватьМассивСтруктурПоПолю(МассивРолей, "name");

	// 10. Формирование результата
	Данные = Новый Структура;
	Данные.Вставить("metadata_object", ИмяОбъектаМетаданных);
	Данные.Вставить("metadata_type", ТипМетаданных);
	// applicable_rights соответствует ключам в rights/effective_rights (с учётом rights_filter)
	Данные.Вставить("applicable_rights", ПраваДляПроверки);
	Данные.Вставить("roles", МассивРолей);
	Данные.Вставить("total_roles", ВсегоРолей);
	Данные.Вставить("roles_with_rights", РолейСПравами);

	// 11. Права пользователя (если указан)
	Если ЗначениеЗаполнено(ИмяПользователяИБ) Тогда
		ПользовательИБ = НайтиПользователяИБПоИмени(ИмяПользователяИБ);
		Если ПользовательИБ = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Пользователь не найден: " + ИмяПользователяИБ +
				" / User not found in infobase: " + ИмяПользователяИБ);
		КонецЕсли;

		// Роли пользователя
		РолиПользователя = Новый Массив;
		Для Каждого РольИБ Из ПользовательИБ.Роли Цикл
			РолиПользователя.Добавить(РольИБ.Имя);
		КонецЦикла;

		// Эффективные права через пользователя
		ЭффективныеПрава = Новый Структура;
		Для Каждого ИмяПрава Из ПраваДляПроверки Цикл
			Попытка
				// Проверка права для пользователя (требует админ-прав!)
				ЕстьПраво = ПравоДоступа(ИмяПрава, ОбъектМетаданных, ПользовательИБ);
				ЭффективныеПрава.Вставить(ИмяПрава, ЕстьПраво);
			Исключение
				ЭффективныеПрава.Вставить(ИмяПрава, Ложь);
			КонецПопытки;
		КонецЦикла;

		// Данные о пользователе
		ДанныеПользователя = Новый Структура;
		ДанныеПользователя.Вставить("name", ИмяПользователяИБ);

		// Полное имя (если доступно)
		ПолноеИмя = "";
		Попытка
			ПолноеИмя = ПользовательИБ.ПолноеИмя;
		Исключение
			// Полное имя может быть недоступно
		КонецПопытки;
		Если ЗначениеЗаполнено(ПолноеИмя) Тогда
			ДанныеПользователя.Вставить("full_name", ПолноеИмя);
		КонецЕсли;

		ДанныеПользователя.Вставить("roles", РолиПользователя);
		ДанныеПользователя.Вставить("effective_rights", ЭффективныеПрава);

		Данные.Вставить("user", ДанныеПользователя);
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, Данные);

КонецФункции

// Определение типа метаданных (на русском)
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект метаданных
//
// Возвращаемое значение:
//  Строка - тип метаданных на русском
//
&НаСервереБезКонтекста
Функция ОпределитьТипМетаданных(ОбъектМетаданных)

	Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат "Справочник";
	ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Документ";
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрСведений";
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрНакопления";
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрБухгалтерии";
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрРасчета";
	ИначеЕсли Метаданные.Обработки.Содержит(ОбъектМетаданных) Тогда
		Возврат "Обработка";
	ИначеЕсли Метаданные.Отчеты.Содержит(ОбъектМетаданных) Тогда
		Возврат "Отчет";
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланВидовХарактеристик";
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланСчетов";
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланВидовРасчета";
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланОбмена";
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат "БизнесПроцесс";
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат "Задача";
	ИначеЕсли Метаданные.ГруппыКоманд.Содержит(ОбъектМетаданных) Тогда
		Возврат "ГруппаКоманд";
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат "ЖурналДокументов";
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Константа";
	ИначеЕсли Метаданные.КритерииОтбора.Содержит(ОбъектМетаданных) Тогда
		Возврат "КритерийОтбора";
	ИначеЕсли Метаданные.Нумераторы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Нумератор";
	ИначеЕсли Метаданные.ОбщиеКоманды.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщаяКоманда";
	ИначеЕсли Метаданные.ОбщиеМодули.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщийМодуль";
	ИначеЕсли Метаданные.ОбщиеРеквизиты.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщийРеквизит";
	ИначеЕсли Метаданные.ОпределяемыеТипы.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОпределяемыйТип";
	ИначеЕсли Метаданные.ПараметрыФункциональныхОпций.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПараметрФункциональныхОпций";
	ИначеЕсли Метаданные.Подсистемы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Подсистема";
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат "Последовательность";
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегламентноеЗадание";
	ИначеЕсли Метаданные.ФункциональныеОпции.Содержит(ОбъектМетаданных) Тогда
		Возврат "ФункциональнаяОпция";
	ИначеЕсли Метаданные.HTTPСервисы.Содержит(ОбъектМетаданных) Тогда
		Возврат "HTTPСервис";
	Иначе
		Возврат "Unknown";
	КонецЕсли;

КонецФункции

// Получить префикс типа метаданных из полного имени объекта (часть до первой точки).
//
// Параметры:
//  ПолноеИмя - Строка - например "Справочник.Контрагенты"
//
// Возвращаемое значение:
//  Строка - префикс (например "Справочник") или "Unknown"
//
&НаСервереБезКонтекста
Функция ПолучитьПрефиксМетаданныхИзИмени(ПолноеИмя)

	Если Не ЗначениеЗаполнено(ПолноеИмя) Тогда
		Возврат "Unknown";
	КонецЕсли;

	ПолноеИмя = СокрЛП(ПолноеИмя);
	ПозицияТочки = Найти(ПолноеИмя, ".");
	Если ПозицияТочки <= 0 Тогда
		Возврат "Unknown";
	КонецЕсли;

	Префикс = Лев(ПолноеИмя, ПозицияТочки - 1);
	Префикс = СокрЛП(Префикс);
	Если Префикс = "" Тогда
		Возврат "Unknown";
	КонецЕсли;

	Возврат Префикс;

КонецФункции

// Универсальный список прав по умолчанию для типов метаданных,
// для которых нет специфического списка в ПолучитьПраваПоТипам().
//
// Возвращаемое значение:
//  Массив - список прав для проверки
//
&НаСервереБезКонтекста
Функция ПолучитьПраваПоУмолчанию()

	Права = Новый Массив;

	// Базовые права, которые чаще всего применимы к большинству объектов
	Права.Добавить("Чтение");
	Права.Добавить("Просмотр");
	Права.Добавить("Использование");
	Права.Добавить("Добавление");
	Права.Добавить("Изменение");
	Права.Добавить("Удаление");
	Права.Добавить("Редактирование");

	// Часто встречающиеся "служебные" права
	Права.Добавить("Получение");
	Права.Добавить("Установка");
	Права.Добавить("Вывод");
	Права.Добавить("ВводПоСтроке");
	Права.Добавить("СохранениеДанныхПользователя");
	Права.Добавить("ИзменениеСтандартнойАутентификации");

	// Документные права (для большинства типов будут просто false)
	Права.Добавить("Проведение");
	Права.Добавить("ОтменаПроведения");
	Права.Добавить("ИнтерактивноеПроведение");
	Права.Добавить("ИнтерактивноеПроведениеНеОперативное");
	Права.Добавить("ИнтерактивнаяОтменаПроведения");
	Права.Добавить("ИнтерактивноеИзменениеПроведенных");

	// Интерактивные права редактирования (для многих типов будут false)
	Права.Добавить("ИнтерактивноеДобавление");
	Права.Добавить("ИнтерактивноеУдаление");
	Права.Добавить("ИнтерактивнаяПометкаУдаления");
	Права.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	Права.Добавить("ИнтерактивноеУдалениеПомеченных");
	Права.Добавить("ИнтерактивноеУдалениеПредопределенныхДанных");
	Права.Добавить("ИнтерактивнаяПометкаУдаленияПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеОткрытиеВнешнихОбработок");
	Права.Добавить("ИнтерактивноеОткрытиеВнешнихОтчетов");

	// Права для отдельных подсистем (для большинства типов будут просто false)
	Права.Добавить("УправлениеИтогами");
	Права.Добавить("Администрирование");
	Права.Добавить("АдминистрированиеДанных");
	Права.Добавить("РежимВсеФункции");
	Права.Добавить("Старт");
	Права.Добавить("ИнтерактивныйСтарт");
	Права.Добавить("Выполнение");
	Права.Добавить("ИнтерактивноеВыполнение");

	Возврат Права;

КонецФункции

// Получить справочник прав по типам метаданных
//
// Возвращаемое значение:
//  Соответствие - тип метаданных -> массив прав
//
&НаСервереБезКонтекста
Функция ПолучитьПраваПоТипам()

	ПраваПоТипам = Новый Соответствие;

	// Справочники
	ПраваСправочника = Новый Массив;
	ПраваСправочника.Добавить("Чтение");
	ПраваСправочника.Добавить("Добавление");
	ПраваСправочника.Добавить("Изменение");
	ПраваСправочника.Добавить("Удаление");
	ПраваСправочника.Добавить("Просмотр");
	ПраваСправочника.Добавить("ИнтерактивноеДобавление");
	ПраваСправочника.Добавить("Редактирование");
	ПраваСправочника.Добавить("ИнтерактивноеУдаление");
	ПраваСправочника.Добавить("ИнтерактивнаяПометкаУдаления");
	ПраваСправочника.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПомеченных");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивнаяПометкаУдаленияПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	ПраваПоТипам.Вставить("Справочник", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланВидовХарактеристик", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланСчетов", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланВидовРасчета", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланОбмена", ПраваСправочника);

	// Документы
	ПраваДокумента = Новый Массив;
	Для Каждого Право Из ПраваСправочника Цикл
		ПраваДокумента.Добавить(Право);
	КонецЦикла;
	ПраваДокумента.Добавить("Проведение");
	ПраваДокумента.Добавить("ОтменаПроведения");
	ПраваДокумента.Добавить("ИнтерактивноеПроведение");
	ПраваДокумента.Добавить("ИнтерактивноеПроведениеНеОперативное");
	ПраваДокумента.Добавить("ИнтерактивнаяОтменаПроведения");
	ПраваДокумента.Добавить("ИнтерактивноеИзменениеПроведенных");
	ПраваДокумента.Добавить("ИнтерактивноеУдалениеПомеченных");
	ПраваПоТипам.Вставить("Документ", ПраваДокумента);

	// Бизнес-процессы: документные права + старт
	ПраваБизнесПроцесса = Новый Массив;
	Для Каждого ПравоБП Из ПраваДокумента Цикл
		ПраваБизнесПроцесса.Добавить(ПравоБП);
	КонецЦикла;
	ПраваБизнесПроцесса.Добавить("Старт");
	ПраваБизнесПроцесса.Добавить("ИнтерактивныйСтарт");
	ПраваПоТипам.Вставить("БизнесПроцесс", ПраваБизнесПроцесса);

	// Задачи: документные права + выполнение
	ПраваЗадачи = Новый Массив;
	Для Каждого ПравоЗад Из ПраваДокумента Цикл
		ПраваЗадачи.Добавить(ПравоЗад);
	КонецЦикла;
	ПраваЗадачи.Добавить("Выполнение");
	ПраваЗадачи.Добавить("ИнтерактивноеВыполнение");
	ПраваПоТипам.Вставить("Задача", ПраваЗадачи);

	// Регистры
	ПраваРегистраБазовые = Новый Массив;
	ПраваРегистраБазовые.Добавить("Чтение");
	ПраваРегистраБазовые.Добавить("Изменение");
	ПраваРегистраБазовые.Добавить("Просмотр");
	ПраваРегистраБазовые.Добавить("Редактирование");
	ПраваПоТипам.Вставить("РегистрСведений", ПраваРегистраБазовые);
	ПраваПоТипам.Вставить("РегистрРасчета", ПраваРегистраБазовые);

	// УправлениеИтогами применимо к регистрам накопления и бухгалтерии
	ПраваРегистраСИтогами = Новый Массив;
	Для Каждого ПравоРег Из ПраваРегистраБазовые Цикл
		ПраваРегистраСИтогами.Добавить(ПравоРег);
	КонецЦикла;
	ПраваРегистраСИтогами.Добавить("УправлениеИтогами");
	ПраваПоТипам.Вставить("РегистрНакопления", ПраваРегистраСИтогами);
	ПраваПоТипам.Вставить("РегистрБухгалтерии", ПраваРегистраСИтогами);

	// Обработки и отчёты
	ПраваОбработки = Новый Массив;
	ПраваОбработки.Добавить("Использование");
	ПраваОбработки.Добавить("Просмотр");
	ПраваПоТипам.Вставить("Обработка", ПраваОбработки);
	ПраваПоТипам.Вставить("Отчет", ПраваОбработки);

	Возврат ПраваПоТипам;

КонецФункции

// Найти пользователя ИБ по имени (с case-insensitive fallback)
//
// Параметры:
//  ИмяПользователя - Строка - имя пользователя для поиска
//
// Возвращаемое значение:
//  ПользовательИнформационнойБазы - пользователь или Неопределено
//
&НаСервереБезКонтекста
Функция НайтиПользователяИБПоИмени(ИмяПользователя)

	ИмяПользователя = СокрЛП(ИмяПользователя);
	Если Не ЗначениеЗаполнено(ИмяПользователя) Тогда
		Возврат Неопределено;
	КонецЕсли;

	// 1. Пытаемся найти через НайтиПоИмени (прямой поиск по имени пользователя ИБ)
	ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ИмяПользователя);
	Если ПользовательИБ <> Неопределено Тогда
		Возврат ПользовательИБ;
	КонецЕсли;

	// 2. Поиск через справочник Пользователи (переданное имя может быть наименованием из справочника)
	Если Метаданные.Справочники.Найти("Пользователи") <> Неопределено Тогда
		Попытка
			ЭлементСправочника = Справочники.Пользователи.НайтиПоНаименованию(ИмяПользователя, Истина);
			Если ЭлементСправочника <> Справочники.Пользователи.ПустаяСсылка() Тогда
				ИдПользователяИБ = ЭлементСправочника.ИдентификаторПользователяИБ;
				Если ТипЗнч(ИдПользователяИБ) = Тип("Строка") Тогда
					ИдПользователяИБ = Новый УникальныйИдентификатор(СокрЛП(ИдПользователяИБ));
				КонецЕсли;
				Если ЗначениеЗаполнено(ИдПользователяИБ) Тогда
					ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ИдПользователяИБ);
					Если ПользовательИБ <> Неопределено Тогда
						Возврат ПользовательИБ;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Исключение
			// Справочник Пользователи существует, но реквизит ИдентификаторПользователяИБ
			// может отсутствовать или быть недоступен — пропускаем этот шаг.
		КонецПопытки;
	КонецЕсли;

	// 3. Fallback: ручной перебор с case-insensitive сравнением
	ИмяПользователяВерх = ВРег(ИмяПользователя);
	// В некоторых режимах/версиях платфомы менеджер ПользователиИнформационнойБазы
	// не является итерируемой коллекцией (ошибка "Итератор для значения не определен").
	// Поэтому перебор делаем в Попытка/Исключение, чтобы не падать инструментом целиком.
	Попытка
		Для Каждого Пользователь Из ПользователиИнформационнойБазы Цикл
			Если ВРег(Пользователь.Имя) = ИмяПользователяВерх Тогда
				Возврат Пользователь;
			КонецЕсли;
		КонецЦикла;
	Исключение
		// Fallback перебора пользователей недоступен в текущем окружении.
		// Возвращаем Неопределено, чтобы вызывающий код вернул понятную ошибку "Пользователь не найден".
	КонецПопытки;

	Возврат Неопределено;

КонецФункции

// Сортировать массив структур по полю
//
// Параметры:
//  МассивСтруктур - Массив - массив структур для сортировки
//  ИмяПоля - Строка - имя поля для сортировки
//
// Возвращаемое значение:
//  Массив - отсортированный массив
//
&НаСервереБезКонтекста
Функция СортироватьМассивСтруктурПоПолю(МассивСтруктур, ИмяПоля)

	// Простой алгоритм сортировки пузырьком
	Результат = Новый Массив;
	Для Каждого Элемент Из МассивСтруктур Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;

	Если Результат.Количество() <= 1 Тогда
		Возврат Результат;
	КонецЕсли;

	Для н = 0 По Результат.Количество() - 2 Цикл
		Для м = 0 По Результат.Количество() - 2 - н Цикл
			Элемент1 = Результат[м];
			Элемент2 = Результат[м + 1];

			Значение1 = Неопределено;
			Значение2 = Неопределено;

			Если Элемент1.Свойство(ИмяПоля) Тогда
				Значение1 = Элемент1[ИмяПоля];
			КонецЕсли;
			Если Элемент2.Свойство(ИмяПоля) Тогда
				Значение2 = Элемент2[ИмяПоля];
			КонецЕсли;

			// Сравнение с учётом типа
			Сравнение = 0;
			Если ЗначениеЗаполнено(Значение1) И ЗначениеЗаполнено(Значение2) Тогда
				Строка1 = Строка(Значение1);
				Строка2 = Строка(Значение2);
				Если Строка1 > Строка2 Тогда
					Сравнение = 1;
				ИначеЕсли Строка1 < Строка2 Тогда
					Сравнение = -1;
				Иначе
					Сравнение = 0;
				КонецЕсли;
			ИначеЕсли Не ЗначениеЗаполнено(Значение1) И ЗначениеЗаполнено(Значение2) Тогда
				Сравнение = 1; // Пустые в конце
			ИначеЕсли ЗначениеЗаполнено(Значение1) И Не ЗначениеЗаполнено(Значение2) Тогда
				Сравнение = -1; // Пустые в конце
			КонецЕсли;

			Если Сравнение > 0 Тогда
				Результат.Установить(м, Элемент2);
				Результат.Установить(м + 1, Элемент1);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Результат;

КонецФункции
