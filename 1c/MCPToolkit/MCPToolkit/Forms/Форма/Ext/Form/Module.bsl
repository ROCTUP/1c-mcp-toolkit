// ═══════════════════════════════════════════════════════════════════════════════
// Модуль формы внешней обработки MCPToolkit
// Клиент для подключения к MCP прокси-серверу
// Совместимость: 1С:Предприятие 8.2.13+ / 8.3.25
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ПЕРЕМЕННЫЕ МОДУЛЯ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Перем ФлагПодключения;

&НаКлиенте
Перем ИнтервалОпроса;

&НаКлиенте
Перем МаксимальноеКоличествоПопытокПереподключения;

&НаКлиенте
Перем ТекущееКоличествоПопытокПереподключения;

&НаКлиенте
Перем КэшТокеновМетаданныхРасширений;

&НаКлиенте
Перем Компонента; // AddIn.MCPHttp.MCPHttpTransport

&НаКлиенте
Перем КомпонентаТун; // AddIn.ToonConv.ToonConverter

&НаКлиенте
Перем МСПСессии; // Соответствие: ИдСессии → АдресВоВременномХранилище

&НаКлиенте
Перем SSEПотоки; // Соответствие: ИдСессии → requestId

&НаКлиенте
Перем ОжидающиеПодтверждения; // Соответствие: requestId → структура {ДанныеЗапроса, ТелоJSON, Ид}

&НаКлиенте
Перем КэшСхемИнструментов; // Структура — кэш для ПолучитьСхемыИнструментов()

&НаКлиенте
Перем ЛегасиССЕПотоки; // Соответствие: transportSessionId → requestId (GET-потока)

&НаКлиенте
Перем ИспользоватьАсинхронноеПодключениеКомпонент; // Булево, инициализируется в ПриОткрытии

&НаКлиенте
Перем ЗапускСервераВПроцессе; // защита от повторного нажатия во время async-цепочки

// ─────────────────────────────────────────────────────────────────────────────────
// ОБРАБОТЧИКИ СОБЫТИЙ ФОРМЫ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	
	// Загрузка сохранённого адреса сервера
	ЗагрузитьНастройки();
	
	// Установка начального статуса
	Статус = "Отключено";
	Подключено = Ложь;
	
	// Значение по умолчанию для адреса сервера
	Если ПустаяСтрока(АдресСервера) Тогда
		АдресСервера = "http://localhost:6003";
	КонецЕсли;

	// Значение по умолчанию для порта встроенного сервера
	Если ПортВстроенногоСервера = 0 Тогда
		ПортВстроенногоСервера = 6003;
	КонецЕсли;

КонецПроцедуры

&НаКлиенте
Процедура ПриОткрытии(Отказ)

	ИспользоватьАсинхронноеПодключениеКомпонент = ПроверитьНужноАсинхронноеПодключениеКомпонент();
	ЗапускСервераВПроцессе = Ложь;

	// Инициализация переменных
	ФлагПодключения = Ложь;
	ИнтервалОпроса = 1; // секунды
	МаксимальноеКоличествоПопытокПереподключения = 5;
	ТекущееКоличествоПопытокПереподключения = 0;
	
	// Клиентский кэш токенов для расширений (адреса ВременногоХранилища)
	КэшТокеновМетаданныхРасширений = Новый Соответствие;

	// Инициализация переменных встроенного сервера
	МСПСессии = Новый Соответствие;
	SSEПотоки = Новый Соответствие;
	ОжидающиеПодтверждения = Новый Соответствие;
	КэшСхемИнструментов = Неопределено;

	// Инициализация видимости элементов по текущему режиму
	ПриИзмененииРежимаПодключения(Неопределено);

КонецПроцедуры

&НаКлиенте
Процедура ПриЗакрытии(Отказ)

	ЗапускСервераВПроцессе = Ложь; // колбэки async-цепочки получат Ложь и выйдут без ошибок

	// Отключение при закрытии формы
	Если ФлагПодключения Тогда
		ОтключитьсяОтСервера();
	КонецЕсли;

	// Остановка встроенного сервера
	Если ВстроенныйСерверЗапущен Тогда
		ОстановитьВстроенныйСервер();
	КонецЕсли;

КонецПроцедуры


// ─────────────────────────────────────────────────────────────────────────────────
// КОМАНДЫ ФОРМЫ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура Подключиться(Команда)

	Если РежимПодключения = 1 Тогда
		// Режим встроенного сервера — сначала отключиться от прокси
		Если ФлагПодключения Тогда
			ОтключитьсяОтСервера();
		КонецЕсли;
		ЗапуститьВстроенныйСервер();
		Возврат;
	КонецЕсли;

	// Режим прокси — сначала остановить встроенный сервер
	Если ВстроенныйСерверЗапущен Тогда
		ОстановитьВстроенныйСервер();
	КонецЕсли;

	Если ПустаяСтрока(АдресСервера) Тогда
		ПоказатьПредупреждение(, "Укажите адрес сервера");
		Возврат;
	КонецЕсли;

	// Сохранение адреса сервера
	СохранитьНастройкиНаСервере(АдресСервера);

	// Инициализация переменных если не были инициализированы
	Если ИнтервалОпроса = Неопределено Тогда
		ИнтервалОпроса = 1;
	КонецЕсли;

	// Запуск подключения
	ФлагПодключения = Истина;
	ТекущееКоличествоПопытокПереподключения = 0;

	УстановитьСтатус("Подключение...", Ложь);
	ДобавитьВЛог("Подключение к серверу: " + АдресСервера);

	// Запуск цикла опроса
	ПодключитьОбработчикОжидания("ЦиклОпроса", 1, Ложь);

КонецПроцедуры

&НаКлиенте
Процедура Отключиться(Команда)

	Если РежимПодключения = 1 Тогда
		ОстановитьВстроенныйСервер();
		Возврат;
	КонецЕсли;

	ОтключитьсяОтСервера();

КонецПроцедуры

&НаКлиенте
Процедура ОчиститьЖурнал(Команда)
	
	Лог = "";
	
КонецПроцедуры

&НаКлиенте
Процедура ОтключитьсяОтСервера()
	
	ФлагПодключения = Ложь;
	
	Попытка
		ОтключитьОбработчикОжидания("ЦиклОпроса");
	Исключение
		// Обработчик уже отключен
	КонецПопытки;
	
	УстановитьСтатус("Отключено", Ложь);
	ДобавитьВЛог("Отключено от сервера");
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ЦИКЛ ОПРОСА (LONG POLLING)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ЦиклОпроса()
	
	Если Не ФлагПодключения Тогда
		Возврат;
	КонецЕсли;
	
	// Получение команды с сервера
	РезультатЗапроса = ПолучитьКомандуССервера(АдресСервера);
	
	Если РезультатЗапроса.Успех Тогда
		
		// Сброс счётчика попыток при успешном подключении
		ТекущееКоличествоПопытокПереподключения = 0;
		
		Если Не Подключено Тогда
			УстановитьСтатус("Подключено", Истина);
			ДобавитьВЛог("Успешное подключение к серверу");
		КонецЕсли;
		
		Если РезультатЗапроса.ЕстьКоманда Тогда
			// Выполнение команды
			ОбработатьКоманду(РезультатЗапроса.Команда);
		КонецЕсли;
		
	Иначе
		// Ошибка подключения
		ОбработатьОшибкуПодключения(РезультатЗапроса.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры


&НаКлиенте
Процедура ОбработатьОшибкуПодключения(ОписаниеОшибки)
	
	// Инициализация если не были инициализированы
	Если ТекущееКоличествоПопытокПереподключения = Неопределено Тогда
		ТекущееКоличествоПопытокПереподключения = 0;
	КонецЕсли;
	Если МаксимальноеКоличествоПопытокПереподключения = Неопределено Тогда
		МаксимальноеКоличествоПопытокПереподключения = 5;
	КонецЕсли;
	
	ТекущееКоличествоПопытокПереподключения = ТекущееКоличествоПопытокПереподключения + 1;
	
	Если ТекущееКоличествоПопытокПереподключения >= МаксимальноеКоличествоПопытокПереподключения Тогда
		// Превышено количество попыток переподключения
		УстановитьСтатус("Ошибка: " + ОписаниеОшибки, Ложь);
		ДобавитьВЛог("Ошибка подключения: " + ОписаниеОшибки + ". Превышено количество попыток.");
		ОтключитьсяОтСервера();
	Иначе
		// Попытка переподключения
		УстановитьСтатус("Переподключение (" + ТекущееКоличествоПопытокПереподключения + "/" + МаксимальноеКоличествоПопытокПереподключения + ")...", Ложь);
		ДобавитьВЛог("Ошибка подключения: " + ОписаниеОшибки + ". Попытка переподключения...");
	КонецЕсли;
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// КЭШ ДЛЯ МЕТАДАННЫХ РАСШИРЕНИЙ (клиент хранит токены, сервер хранит данные во ВременномХранилище)
// Внешний API не меняется: токены не уходят наружу (в ОтправитьРезультатНаСервер есть whitelist полей).
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция ПолучитьКэшТокеновМетаданныхРасширений()
	Если КэшТокеновМетаданныхРасширений = Неопределено Тогда
		КэшТокеновМетаданныхРасширений = Новый Соответствие;
	КонецЕсли;
	Возврат КэшТокеновМетаданныхРасширений;
КонецФункции

&НаКлиенте
Функция СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции)
	Ключ = ?(Фильтр = Неопределено, "", Строка(Фильтр));
	
	Если Секции = Неопределено Тогда
		Возврат Ключ;
	КонецЕсли;
	
	Попытка
		Если ТипЗнч(Секции) = Тип("Массив") Тогда
			СтрСекции = "";
			Для Каждого Секция Из Секции Цикл
				Секция = СокрЛП(Строка(Секция));
				Если ПустаяСтрока(Секция) Тогда
					Продолжить;
				КонецЕсли;
				СтрСекции = СтрСекции + ?(ПустаяСтрока(СтрСекции), "", ",") + Секция;
			КонецЦикла;
			Если НЕ ПустаяСтрока(СтрСекции) Тогда
				Ключ = Ключ + "|" + СтрСекции;
			КонецЕсли;
		Иначе
			Ключ = Ключ + "|" + Строка(Секции);
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Возврат Ключ;
КонецФункции

&НаКлиенте
Функция ВыполнитьКомандуНаСервереСКэшированием(Команда)
	ИмяИнструмента = "";
	Попытка
		ИмяИнструмента = СокрЛП(Команда.tool);
	Исключение
		ИмяИнструмента = "";
	КонецПопытки;
	
	// Важно: Команда может быть фиксированной структурой (read-only), поэтому НЕ модифицируем ее.
	// Всегда работаем с копией params в обычной Структуре.
	ПараметрыИсходные = Неопределено;
	Если Команда.Свойство("params") Тогда
		ПараметрыИсходные = Команда.params;
	КонецЕсли;
	
	// ВАЖНО: имя "Параметры" в модуле формы может конфликтовать с одноименным
	// системным/форменным свойством (read-only). Используем уникальное имя.
	ПараметрыКоманды = Новый Структура;
	Если ПараметрыИсходные <> Неопределено Тогда
		Попытка
			Для Каждого Пара Из ПараметрыИсходные Цикл
				ПараметрыКоманды.Вставить(Пара.Ключ, Пара.Значение);
			КонецЦикла;
		Исключение
			// Если params не коллекция/не итерируется - оставляем пустыми
		КонецПопытки;
	КонецЕсли;
	
	ИмяРасширения = Неопределено;
	Фильтр = "";
	Секции = Неопределено;
	
	Если ИмяИнструмента = "get_metadata" И ПараметрыКоманды <> Неопределено Тогда
		Если ПараметрыКоманды.Свойство("extension_name") Тогда
			ИмяРасширения = ПараметрыКоманды.extension_name;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("filter") Тогда
			Фильтр = ПараметрыКоманды.filter;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("sections") Тогда
			Секции = ПараметрыКоманды.sections;
		КонецЕсли;
	КонецЕсли;
	
	КлючДеталей = "";
	
	// Добавляем токены кэша только для режима "объекты расширения" (extension_name="Имя")
	Если ИмяИнструмента = "get_metadata"
		И ИмяРасширения <> Неопределено
		И ТипЗнч(ИмяРасширения) = Тип("Строка")
		И НЕ ПустаяСтрока(ИмяРасширения) Тогда
		
		Кэш = ПолучитьКэшТокеновМетаданныхРасширений();
		Запись = Кэш.Получить(ИмяРасширения);
		
		Если Запись = Неопределено Тогда
			Запись = Новый Структура(
				"hash, data_token, index_token, details, details_order",
				"",
				Неопределено,
				Неопределено,
				Новый Соответствие,
				Новый Массив
			);
			Кэш.Вставить(ИмяРасширения, Запись);
		КонецЕсли;
		
		Если Запись.hash <> "" Тогда
			ПараметрыКоманды.Вставить("mcp_cache_hash", Запись.hash);
		КонецЕсли;
		Если Запись.data_token <> Неопределено Тогда
			ПараметрыКоманды.Вставить("mcp_cache_data_token", Запись.data_token);
		КонецЕсли;
		Если Запись.index_token <> Неопределено Тогда
			ПараметрыКоманды.Вставить("mcp_cache_index_token", Запись.index_token);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(Фильтр) Тогда
			КлючДеталей = СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции);
			ТокенДеталей = Запись.details.Получить(КлючДеталей);
			Если ТокенДеталей <> Неопределено Тогда
				ПараметрыКоманды.Вставить("mcp_cache_details_token", ТокенДеталей);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	// Передаем на сервер копию команды с измененными params (если добавили токены кэша)
	КомандаНаСервер = Новый Структура;
	Попытка
		Если Команда.Свойство("id") Тогда
			КомандаНаСервер.Вставить("id", Команда.id);
		КонецЕсли;
	Исключение
	КонецПопытки;
	КомандаНаСервер.Вставить("tool", ИмяИнструмента);
	КомандаНаСервер.Вставить("params", ПараметрыКоманды);
	
	Результат = ВыполнитьКомандуНаСервере(КомандаНаСервер);
	
	// Обновляем кэш по внутренним полям результата (они не уходят наружу из-за whitelist)
	Если ИмяИнструмента = "get_metadata"
		И ИмяРасширения <> Неопределено
		И ТипЗнч(ИмяРасширения) = Тип("Строка")
		И НЕ ПустаяСтрока(ИмяРасширения) Тогда
		
		Попытка
			Если Результат <> Неопределено
				И ТипЗнч(Результат) = Тип("Структура") Тогда
				
				Кэш = ПолучитьКэшТокеновМетаданныхРасширений();
				Запись = Кэш.Получить(ИмяРасширения);
				Если Запись = Неопределено Тогда
					Запись = Новый Структура(
						"hash, data_token, index_token, details, details_order",
						"",
						Неопределено,
						Неопределено,
						Новый Соответствие,
						Новый Массив
					);
				КонецЕсли;
				
				НовХеш = "";
				Если Результат.Свойство("mcp_cache_hash") Тогда
					НовХеш = Строка(Результат.mcp_cache_hash);
				КонецЕсли;
				
				Если НЕ ПустаяСтрока(НовХеш) И Запись.hash <> "" И Запись.hash <> НовХеш Тогда
					Запись.hash = НовХеш;
					Запись.data_token = Неопределено;
					Запись.index_token = Неопределено;
					Запись.details = Новый Соответствие;
					Запись.details_order = Новый Массив;
				ИначеЕсли НЕ ПустаяСтрока(НовХеш) Тогда
					Запись.hash = НовХеш;
				КонецЕсли;
				
				Если Результат.Свойство("mcp_cache_data_token") Тогда
					Запись.data_token = Результат.mcp_cache_data_token;
				КонецЕсли;
				Если Результат.Свойство("mcp_cache_index_token") Тогда
					Запись.index_token = Результат.mcp_cache_index_token;
				КонецЕсли;
				
				Если Результат.Свойство("mcp_cache_details_token") И НЕ ПустаяСтрока(Фильтр) Тогда
					Если ПустаяСтрока(КлючДеталей) Тогда
						КлючДеталей = СформироватьКлючКэшаДеталейРасширения(Фильтр, Секции);
					КонецЕсли;
					ТокенДеталей = Результат.mcp_cache_details_token;
					Если ТокенДеталей <> Неопределено Тогда
						Запись.details.Вставить(КлючДеталей, ТокенДеталей);
						Запись.details_order.Добавить(КлючДеталей);
						
						// Ограничиваем размер кэша деталей, чтобы не раздувать память/ВременноеХранилище бесконечно
						МаксДеталей = 50;
						Если Запись.details_order.Количество() > МаксДеталей Тогда
							СтарыйКлюч = Запись.details_order[0];
							Запись.details_order.Удалить(0);
							Попытка
								Запись.details.Удалить(СтарыйКлюч);
							Исключение
							КонецПопытки;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Кэш.Вставить(ИмяРасширения, Запись);
				
				// Не светим токены в текстовых логах формы
				Если Результат.Свойство("mcp_cache_hash") Тогда Результат.Удалить("mcp_cache_hash"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_data_token") Тогда Результат.Удалить("mcp_cache_data_token"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_index_token") Тогда Результат.Удалить("mcp_cache_index_token"); КонецЕсли;
				Если Результат.Свойство("mcp_cache_details_token") Тогда Результат.Удалить("mcp_cache_details_token"); КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Возврат Результат;
КонецФункции

&НаКлиенте
Процедура ОбработатьКоманду(Команда)
	
	// Формируем информативное сообщение о команде
	ТекстКоманды = ПолучитьТекстКоманды(Команда);
	ДобавитьВЛог("Получена команда: " + Команда.tool + Символы.ПС + ТекстКоманды);
	
	// Проверка необходимости подтверждения опасной операции
	Если Команда.Свойство("params") И Команда.params <> Неопределено Тогда
		ПараметрыКоманды = Команда.params;
		
		Если ПараметрыКоманды.Свойство("requires_approval") И ПараметрыКоманды.requires_approval = Истина Тогда
			
			// Получение массива опасных ключевых слов
			МассивОпасныхСлов = Новый Массив;
			ОпасныеСлова = "";
			Если ПараметрыКоманды.Свойство("dangerous_keywords") Тогда
				Для Каждого Слово Из ПараметрыКоманды.dangerous_keywords Цикл
					МассивОпасныхСлов.Добавить(Слово);
					ОпасныеСлова = ОпасныеСлова + ?(ПустаяСтрока(ОпасныеСлова), "", ", ") + Слово;
				КонецЦикла;
			КонецЕсли;
			
 			// Проверка автоматического разрешения
 			Если ВсеОперацииАвтоРазрешены(МассивОпасныхСлов) Тогда
 				ДобавитьВЛог("Операции автоматически разрешены: " + ОпасныеСлова);
				Попытка
					Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
				Исключение
					ТекстОшибки = ОписаниеОшибки();
					ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
					Результат = Новый Структура(
						"success, error",
						Ложь,
						"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
						+ " / Error executing command in 1C server: " + ТекстОшибки
					);
				КонецПопытки;
 				РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
 				
 				Если РезультатОтправки.Успех Тогда
 					ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
				Иначе
					ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
				КонецЕсли;
 				
				Возврат;
			КонецЕсли;

			// Получение кода
			Код = "";
			Если ПараметрыКоманды.Свойство("code") Тогда
				Код = ПараметрыКоманды.code;
			КонецЕсли;
			
			ДобавитьВЛог("Требуется подтверждение пользователя. Опасные слова: " + ОпасныеСлова);
			
			// Показ формы подтверждения
			ПараметрыФормы = Новый Структура;
			ПараметрыФормы.Вставить("ОпасныеСлова", ОпасныеСлова);
			ПараметрыФормы.Вставить("Код", Код);
			
			ОписаниеОповещения = Новый ОписаниеОповещения(
				"ОбработатьРезультатПодтверждения", 
				ЭтаФорма, 
				Новый Структура("Команда", Команда)
			);
			
			ОткрытьФорму(
				"ВнешняяОбработка.MCPToolkit.Форма.ФормаПодтверждения",
				ПараметрыФормы,
				ЭтаФорма,
				,
				,
				,
				ОписаниеОповещения,
				РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс
			);
			
			Возврат;
		КонецЕсли;
 	КонецЕсли;
 	
 	// Обычное выполнение без подтверждения
	Попытка
		Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
		Результат = Новый Структура(
			"success, error",
			Ложь,
			"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
			+ " / Error executing command in 1C server: " + ТекстОшибки
		);
	КонецПопытки;
 	
 	// Отправка результата на сервер
 	РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
	
	Если РезультатОтправки.Успех Тогда
		ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
	Иначе
		ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьРезультатПодтверждения(Разрешено, ДополнительныеПараметры) Экспорт
	
	Команда = ДополнительныеПараметры.Команда;
	
 	Если Разрешено = Истина Тогда
 		ДобавитьВЛог("Пользователь разрешил выполнение опасной операции");
		Попытка
			Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
		Исключение
			ТекстОшибки = ОписаниеОшибки();
			ДобавитьВЛог("Ошибка выполнения команды на сервере 1С: " + ТекстОшибки);
			Результат = Новый Структура(
				"success, error",
				Ложь,
				"Ошибка выполнения команды на сервере 1С: " + ТекстОшибки
				+ " / Error executing command in 1C server: " + ТекстОшибки
			);
		КонецПопытки;
 	Иначе
 		ДобавитьВЛог("Пользователь отклонил выполнение опасной операции");
		
		// Формирование списка опасных слов для сообщения
		ОпасныеСлова = "";
		Если Команда.Свойство("params") И Команда.params <> Неопределено Тогда
			ПараметрыКоманды = Команда.params;
			Если ПараметрыКоманды.Свойство("dangerous_keywords") Тогда
				Для Каждого Слово Из ПараметрыКоманды.dangerous_keywords Цикл
					ОпасныеСлова = ОпасныеСлова + ?(ПустаяСтрока(ОпасныеСлова), "", ", ") + Слово;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
		
		Результат = Новый Структура("success, error", Ложь, 
			"Операция отклонена пользователем. Код содержит опасные ключевые слова: " + ОпасныеСлова + 
			" / Operation rejected by user. Code contains dangerous keywords: " + ОпасныеСлова);
	КонецЕсли;
	
	// Отправка результата на сервер
	РезультатОтправки = ОтправитьРезультатНаСервер(АдресСервера, Команда.id, Результат);
	
	Если РезультатОтправки.Успех Тогда
		ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
	Иначе
		ДобавитьВЛог("Ошибка отправки результата: " + РезультатОтправки.ОписаниеОшибки);
	КонецЕсли;
	
КонецПроцедуры

&НаКлиенте
Функция ВсеОперацииАвтоРазрешены(МассивОпасныхСлов)
	
	// Соответствие ключевых слов и флагов автоматического разрешения
	СоответствиеФлагов = Новый Соответствие;
	СоответствиеФлагов.Вставить("ЗАПИСАТЬ", АвтоРазрешитьЗаписать);
	СоответствиеФлагов.Вставить("WRITE", АвтоРазрешитьЗаписать);
	СоответствиеФлагов.Вставить("УСТАНОВИТЬПРИВИЛЕГИРОВАННЫЙРЕЖИМ", АвтоРазрешитьПривилегированныйРежим);
	СоответствиеФлагов.Вставить("SETPRIVILEGEDMODE", АвтоРазрешитьПривилегированныйРежим);
	
	// Проверка каждого опасного слова
	Для Каждого Слово Из МассивОпасныхСлов Цикл
		СловоВерхнийРегистр = ВРег(Слово);
		ФлагРазрешения = СоответствиеФлагов.Получить(СловоВерхнийРегистр);
		
		Если ФлагРазрешения = Неопределено Или ФлагРазрешения = Ложь Тогда
			Возврат Ложь; // Есть неразрешённая операция
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина; // Все операции автоматически разрешены
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстКоманды(Команда)
	
	ТекстКоманды = "";
	Отступ = "    "; // 4 пробела
	
	Если Не Команда.Свойство("params") Или Команда.params = Неопределено Тогда
		Возврат Отступ + "(без параметров)";
	КонецЕсли;
	
	ПараметрыКоманды = Команда.params;
	
	Если Команда.tool = "execute_query" Тогда
		Если ПараметрыКоманды.Свойство("query") Тогда
			ТекстКоманды = ПараметрыКоманды.query;
		КонецЕсли;
	ИначеЕсли Команда.tool = "execute_code" Тогда
		Если ПараметрыКоманды.Свойство("code") Тогда
			ТекстКоманды = ПараметрыКоманды.code;
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_metadata" Тогда
		ЧастиТекста = Новый Массив;
		Если ПараметрыКоманды.Свойство("filter") И Не ПустаяСтрока(ПараметрыКоманды.filter) Тогда
			ЧастиТекста.Добавить("фильтр: " + ПараметрыКоманды.filter);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("meta_type") И Не ПустаяСтрока(ПараметрыКоманды.meta_type) Тогда
			ЧастиТекста.Добавить("тип: " + ПараметрыКоманды.meta_type);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("name_mask") И Не ПустаяСтрока(ПараметрыКоманды.name_mask) Тогда
			ЧастиТекста.Добавить("маска: " + ПараметрыКоманды.name_mask);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("extension_name") И ПараметрыКоманды.extension_name <> Неопределено Тогда
			ЧастиТекста.Добавить("расширение: " + ?(ПустаяСтрока(ПараметрыКоманды.extension_name), "(конфигурация)", ПараметрыКоманды.extension_name));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("limit") И ЗначениеЗаполнено(ПараметрыКоманды.limit) Тогда
			ЧастиТекста.Добавить("лимит: " + ПараметрыКоманды.limit);
		КонецЕсли;
		Если ЧастиТекста.Количество() = 0 Тогда
			ТекстКоманды = "(все метаданные)";
		Иначе
			ТекстКоманды = СоединитьМассив(ЧастиТекста, ", ");
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_event_log" Тогда
		ЧастиТекста = Новый Массив;
		Если ПараметрыКоманды.Свойство("start_date") И ЗначениеЗаполнено(ПараметрыКоманды.start_date) Тогда
			ЧастиТекста.Добавить("с " + ПараметрыКоманды.start_date);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("end_date") И ЗначениеЗаполнено(ПараметрыКоманды.end_date) Тогда
			ЧастиТекста.Добавить("по " + ПараметрыКоманды.end_date);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("levels") И ПараметрыКоманды.levels <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.levels) И ПараметрыКоманды.levels.Количество() > 0 Тогда
			ЧастиТекста.Добавить("уровни: " + СоединитьМассив(ПараметрыКоманды.levels, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("limit") И ЗначениеЗаполнено(ПараметрыКоманды.limit) Тогда
			ЧастиТекста.Добавить("лимит: " + ПараметрыКоманды.limit);
		КонецЕсли;
		// Фильтры по объекту (приоритет: object_description > link > data)
		Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.object_description.Свойство("Представление") Тогда
					ЧастиТекста.Добавить("объект: " + ПараметрыКоманды.object_description.Представление);
				ИначеЕсли ПараметрыКоманды.object_description.Свойство("ТипОбъекта") Тогда
					ЧастиТекста.Добавить("объект (тип): " + ПараметрыКоманды.object_description.ТипОбъекта);
				Иначе
					ЧастиТекста.Добавить("объект: (описание объекта)");
				КонецЕсли;
			Иначе
				ЧастиТекста.Добавить("объект: (некорректное описание)");
			КонецЕсли;
		ИначеЕсли ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
			ЧастиТекста.Добавить("ссылка: " + ПараметрыКоманды.link);
		ИначеЕсли ПараметрыКоманды.Свойство("data") И ЗначениеЗаполнено(ПараметрыКоманды.data) Тогда
			ЧастиТекста.Добавить("данные: " + ПараметрыКоманды.data);
		КонецЕсли;
		// Остальные фильтры
		Если ПараметрыКоманды.Свойство("metadata_type") И ПараметрыКоманды.metadata_type <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.metadata_type) И ПараметрыКоманды.metadata_type.Количество() > 0 Тогда
			ЧастиТекста.Добавить("метаданные: " + СоединитьМассив(ПараметрыКоманды.metadata_type, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("user") И ПараметрыКоманды.user <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.user) И ПараметрыКоманды.user.Количество() > 0 Тогда
			ЧастиТекста.Добавить("пользователи: " + СоединитьМассив(ПараметрыКоманды.user, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("session") И ПараметрыКоманды.session <> Неопределено Тогда
			Если ЭтоКоллекция(ПараметрыКоманды.session) И ПараметрыКоманды.session.Количество() > 0 Тогда
				МассивСеансов = Новый Массив;
				Для Каждого Сеанс Из ПараметрыКоманды.session Цикл
					МассивСеансов.Добавить(Строка(Сеанс));
				КонецЦикла;
				ЧастиТекста.Добавить("сеансы: " + СоединитьМассив(МассивСеансов, ", "));
			ИначеЕсли Не ЭтоКоллекция(ПараметрыКоманды.session) И ЗначениеЗаполнено(ПараметрыКоманды.session) Тогда
				ЧастиТекста.Добавить("сеанс: " + Строка(ПараметрыКоманды.session));
			КонецЕсли;
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("application") И ПараметрыКоманды.application <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.application) И ПараметрыКоманды.application.Количество() > 0 Тогда
			ЧастиТекста.Добавить("приложения: " + СоединитьМассив(ПараметрыКоманды.application, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("computer") И ЗначениеЗаполнено(ПараметрыКоманды.computer) Тогда
			ЧастиТекста.Добавить("компьютер: " + ПараметрыКоманды.computer);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("comment_contains") И ЗначениеЗаполнено(ПараметрыКоманды.comment_contains) Тогда
			ЧастиТекста.Добавить("комментарий содержит: " + ПараметрыКоманды.comment_contains);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("transaction_status") И ЗначениеЗаполнено(ПараметрыКоманды.transaction_status) Тогда
			ЧастиТекста.Добавить("статус транзакции: " + ПараметрыКоманды.transaction_status);
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			// Каждый параметр на новой строке с отступом в 4 пробела
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(журнал регистрации)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_object_by_link" Тогда
		Если ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
			ТекстКоманды = "ссылка: " + ПараметрыКоманды.link;
		Иначе
			ТекстКоманды = "(пустая ссылка)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_link_of_object" Тогда
		Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.object_description.Свойство("Представление") Тогда
					ТекстКоманды = "объект: " + ПараметрыКоманды.object_description.Представление;
				ИначеЕсли ПараметрыКоманды.object_description.Свойство("ТипОбъекта") Тогда
					ТекстКоманды = "тип: " + ПараметрыКоманды.object_description.ТипОбъекта;
				Иначе
					ТекстКоманды = "(описание объекта)";
				КонецЕсли;
			Иначе
				ТекстКоманды = "(некорректное описание)";
			КонецЕсли;
		Иначе
			ТекстКоманды = "(пустое описание)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "find_references_to_object" Тогда
		ЧастиТекста = Новый Массив;
		// Целевой объект
		Если ПараметрыКоманды.Свойство("target_object_description") И ПараметрыКоманды.target_object_description <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.target_object_description) = Тип("Структура") Тогда
				Если ПараметрыКоманды.target_object_description.Свойство("Представление") Тогда
					ЧастиТекста.Добавить("цель: " + ПараметрыКоманды.target_object_description.Представление);
				ИначеЕсли ПараметрыКоманды.target_object_description.Свойство("ТипОбъекта") Тогда
					ЧастиТекста.Добавить("цель (тип): " + ПараметрыКоманды.target_object_description.ТипОбъекта);
				Иначе
					ЧастиТекста.Добавить("цель: (описание объекта)");
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Области поиска
		Если ПараметрыКоманды.Свойство("search_scope") И ПараметрыКоманды.search_scope <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.search_scope) И ПараметрыКоманды.search_scope.Количество() > 0 Тогда
			ЧастиТекста.Добавить("области: " + СоединитьМассив(ПараметрыКоманды.search_scope, ", "));
		КонецЕсли;
		// Фильтр метаданных
		Если ПараметрыКоманды.Свойство("meta_filter") И ПараметрыКоманды.meta_filter <> Неопределено Тогда
			Если ТипЗнч(ПараметрыКоманды.meta_filter) = Тип("Структура") Тогда
				Если ПараметрыКоманды.meta_filter.Свойство("names") И ПараметрыКоманды.meta_filter.names <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.meta_filter.names) И ПараметрыКоманды.meta_filter.names.Количество() > 0 Тогда
					ЧастиТекста.Добавить("фильтр имён: " + СоединитьМассив(ПараметрыКоманды.meta_filter.names, ", "));
				ИначеЕсли ПараметрыКоманды.meta_filter.Свойство("name_mask") И ЗначениеЗаполнено(ПараметрыКоманды.meta_filter.name_mask) Тогда
					ЧастиТекста.Добавить("маска: " + ПараметрыКоманды.meta_filter.name_mask);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		// Лимиты
		Если ПараметрыКоманды.Свойство("limit_hits") И ЗначениеЗаполнено(ПараметрыКоманды.limit_hits) Тогда
			ЧастиТекста.Добавить("лимит: " + ПараметрыКоманды.limit_hits);
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(поиск ссылок на объект)";
		КонецЕсли;
	ИначеЕсли Команда.tool = "get_access_rights" Тогда
		ЧастиТекста = Новый Массив;
		Если ПараметрыКоманды.Свойство("metadata_object") И ЗначениеЗаполнено(ПараметрыКоманды.metadata_object) Тогда
			ЧастиТекста.Добавить("объект: " + ПараметрыКоманды.metadata_object);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("user_name") И ЗначениеЗаполнено(ПараметрыКоманды.user_name) Тогда
			ЧастиТекста.Добавить("пользователь: " + ПараметрыКоманды.user_name);
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("rights_filter") И ПараметрыКоманды.rights_filter <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.rights_filter) И ПараметрыКоманды.rights_filter.Количество() > 0 Тогда
			ЧастиТекста.Добавить("права: " + СоединитьМассив(ПараметрыКоманды.rights_filter, ", "));
		КонецЕсли;
		Если ПараметрыКоманды.Свойство("roles_filter") И ПараметрыКоманды.roles_filter <> Неопределено И ЭтоКоллекция(ПараметрыКоманды.roles_filter) И ПараметрыКоманды.roles_filter.Количество() > 0 Тогда
			ЧастиТекста.Добавить("роли: " + СоединитьМассив(ПараметрыКоманды.roles_filter, ", "));
		КонецЕсли;
		Если ЧастиТекста.Количество() > 0 Тогда
			ТекстКоманды = "    " + СоединитьМассив(ЧастиТекста, Символы.ПС + "    ");
		Иначе
			ТекстКоманды = "(права доступа)";
		КонецЕсли;
	Иначе
		ТекстКоманды = "(неизвестная команда)";
	КонецЕсли;
	
	// Преобразуем экранированные символы
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\r", "");
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\t", "    ");
	ТекстКоманды = СтрЗаменить(ТекстКоманды, "\n", Символы.ПС);
	
	// Добавляем отступ к каждой строке
	ТекстКоманды = Отступ + СтрЗаменить(ТекстКоманды, Символы.ПС, Символы.ПС + Отступ);
	
	Возврат ТекстКоманды;
	
КонецФункции

&НаКлиенте
Функция ПолучитьТекстРезультата(Результат)
	
	Отступ = "    "; // 4 пробела
	ТекстРезультата = "";
	
	Если Результат.Свойство("success") И Результат.success = Истина Тогда
		Если Результат.Свойство("data") Тогда
			ТекстРезультата = ЗаписатьJSON2(Результат.data);
		Иначе
			ТекстРезультата = "(нет данных)";
		КонецЕсли;
	Иначе
		Если Результат.Свойство("error") Тогда
			ТекстРезультата = "Ошибка: " + Результат.error;
		Иначе
			ТекстРезультата = "(неизвестная ошибка)";
		КонецЕсли;
	КонецЕсли;
	
	// Преобразуем экранированные символы
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\r", "");
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\t", "    ");
	ТекстРезультата = СтрЗаменить(ТекстРезультата, "\n", Символы.ПС);
	
	// Добавляем отступ к каждой строке
	ТекстРезультата = Отступ + СтрЗаменить(ТекстРезультата, Символы.ПС, Символы.ПС + Отступ);
	
	Возврат ТекстРезультата;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// HTTP-ЗАПРОСЫ К СЕРВЕРУ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция СформироватьПутьЗапроса(БазовыйПуть, ПараметрыЗапроса)
	
	// ПараметрыЗапроса - Структура с параметрами
	// Возвращает путь вида "/1c/poll?channel=abc&timeout=30"
	
	Если ПараметрыЗапроса.Количество() = 0 Тогда
		Возврат БазовыйПуть;
	КонецЕсли;
	
	ЧастиПараметров = Новый Массив;
	Для Каждого КлючЗначение Из ПараметрыЗапроса Цикл
		Если Не ПустаяСтрока(КлючЗначение.Значение) Тогда
			ЧастиПараметров.Добавить(КлючЗначение.Ключ + "=" + КлючЗначение.Значение);
		КонецЕсли;
	КонецЦикла;
	
	Если ЧастиПараметров.Количество() = 0 Тогда
		Возврат БазовыйПуть;
	КонецЕсли;
	
	Возврат БазовыйПуть + "?" + СоединитьМассив(ЧастиПараметров, "&");
	
КонецФункции

&НаКлиенте
Функция ПолучитьКомандуССервера(Адрес)
	
	Результат = Новый Структура("Успех, ЕстьКоманда, Команда, ОписаниеОшибки", Ложь, Ложь, Неопределено, "");
	
	Попытка
		
		// Разбор URL
		СтруктураURL = РазобратьURL(Адрес);
		
		// Создание HTTP-соединения
		Если СтруктураURL.Протокол = "https" Тогда
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30, Новый ЗащищенноеСоединениеOpenSSL());
		Иначе
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30);
		КонецЕсли;
		
		// Формирование параметров запроса с channel
		ПараметрыЗапроса = Новый Структура;
		Если Не ПустаяСтрока(ИдентификаторКанала) Тогда
			ПараметрыЗапроса.Вставить("channel", СокрЛП(ИдентификаторКанала));
		КонецЕсли;
		
		ПутьЗапроса = СформироватьПутьЗапроса(СтруктураURL.Путь + "/1c/poll", ПараметрыЗапроса);
		
		// Формирование запроса
		Запрос = Новый HTTPЗапрос(ПутьЗапроса);
		Запрос.Заголовки.Вставить("Accept", "application/json");
		
		// Выполнение запроса
		Ответ = Соединение.Получить(Запрос);
		
		Если Ответ.КодСостояния = 200 Тогда
			// Есть команда
			ТелоОтвета = Ответ.ПолучитьТелоКакСтроку("UTF-8");
			Если Не ПустаяСтрока(ТелоОтвета) Тогда
				Команда = ПрочитатьJSON2(ТелоОтвета);
				Результат.Успех = Истина;
				Результат.ЕстьКоманда = Истина;
				Результат.Команда = Команда;
			Иначе
				Результат.Успех = Истина;
				Результат.ЕстьКоманда = Ложь;
			КонецЕсли;
		ИначеЕсли Ответ.КодСостояния = 204 Тогда
			// Нет команд (таймаут long polling)
			Результат.Успех = Истина;
			Результат.ЕстьКоманда = Ложь;
		Иначе
			Результат.ОписаниеОшибки = "HTTP " + Ответ.КодСостояния;
		КонецЕсли;
		
	Исключение
		Результат.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции


&НаКлиенте
Функция ОтправитьРезультатНаСервер(Адрес, ИдКоманды, Результат)
	
	РезультатОтправки = Новый Структура("Успех, ОписаниеОшибки", Ложь, "");
	
	Попытка
		
		// Разбор URL
		СтруктураURL = РазобратьURL(Адрес);
		
		// Создание HTTP-соединения
		Если СтруктураURL.Протокол = "https" Тогда
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30, Новый ЗащищенноеСоединениеOpenSSL());
		Иначе
			Соединение = Новый HTTPСоединение(СтруктураURL.Хост, СтруктураURL.Порт, , , , 30);
		КонецЕсли;
		
		// Формирование тела запроса
		ТелоЗапроса = Новый Структура;
		ТелоЗапроса.Вставить("id", ИдКоманды);
		
		Если Результат.Свойство("success") И Результат.success Тогда
			ТелоЗапроса.Вставить("success", Истина);
			
			// Безопасное получение data - может отсутствовать при ошибке
			Если Результат.Свойство("data") Тогда
				ТелоЗапроса.Вставить("data", Результат.data);
			КонецЕсли;
			
			// Схема результата (опционально, для execute_query include_schema=true)
			Если Результат.Свойство("schema") Тогда
				ТелоЗапроса.Вставить("schema", Результат.schema);
			КонецЕсли;
			
			// Дополнительные (опциональные) мета-поля результата (например, для постраничного вывода get_metadata)
			// Важно: whitelist, чтобы не прокидывать на сервер произвольные поля/мусор.
			ДопПоля = Новый Массив;
			ДопПоля.Добавить("truncated");
			ДопПоля.Добавить("limit");
			ДопПоля.Добавить("returned");
			ДопПоля.Добавить("count");
			ДопПоля.Добавить("offset");
			ДопПоля.Добавить("has_more");
			ДопПоля.Добавить("next_offset");
			ДопПоля.Добавить("last_date");
			ДопПоля.Добавить("next_same_second_offset");
			ДопПоля.Добавить("configuration");
			ДопПоля.Добавить("extension");
			
			Для Каждого ИмяПоля Из ДопПоля Цикл
				Если Результат.Свойство(ИмяПоля) Тогда
					ЗначениеПоля = Результат[ИмяПоля];
					Если ЗначениеПоля <> Неопределено Тогда
						ТелоЗапроса.Вставить(ИмяПоля, ЗначениеПоля);
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		Иначе
			ТелоЗапроса.Вставить("success", Ложь);
			
			// Безопасное получение error
			Если Результат.Свойство("error") Тогда
				ТелоЗапроса.Вставить("error", Результат.error);
			Иначе
				ТелоЗапроса.Вставить("error", "Неизвестная ошибка");
			КонецЕсли;
		КонецЕсли;
		
		ТелоJSON = ЗаписатьJSON2(ТелоЗапроса);
		
		// Формирование параметров запроса с channel
		ПараметрыЗапроса = Новый Структура;
		Если Не ПустаяСтрока(ИдентификаторКанала) Тогда
			ПараметрыЗапроса.Вставить("channel", СокрЛП(ИдентификаторКанала));
		КонецЕсли;
		
		ПутьЗапроса = СформироватьПутьЗапроса(СтруктураURL.Путь + "/1c/result", ПараметрыЗапроса);
		
		// Формирование запроса
		Запрос = Новый HTTPЗапрос(ПутьЗапроса);
		Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");
		Запрос.УстановитьТелоИзСтроки(ТелоJSON, "UTF-8");
		
		// Выполнение запроса
		Ответ = Соединение.ОтправитьДляОбработки(Запрос);
		
		Если Ответ.КодСостояния = 200 Или Ответ.КодСостояния = 204 Тогда
			РезультатОтправки.Успех = Истина;
		Иначе
			РезультатОтправки.ОписаниеОшибки = "HTTP " + Ответ.КодСостояния;
		КонецЕсли;
		
	Исключение
		РезультатОтправки.ОписаниеОшибки = ОписаниеОшибки();
	КонецПопытки;
	
	Возврат РезультатОтправки;
	
КонецФункции

&НаКлиенте
Функция РазобратьURL(URL)
	
	Результат = Новый Структура("Протокол, Хост, Порт, Путь", "http", "", 80, "");
	
	АдресБезПротокола = URL;
	
	// Определение протокола
	Если НРег(Лев(URL, 8)) = "https://" Тогда
		Результат.Протокол = "https";
		Результат.Порт = 443;
		АдресБезПротокола = Сред(URL, 9);
	ИначеЕсли НРег(Лев(URL, 7)) = "http://" Тогда
		Результат.Протокол = "http";
		Результат.Порт = 80;
		АдресБезПротокола = Сред(URL, 8);
	КонецЕсли;
	
	// Разделение хоста и пути
	ПозицияСлеша = Найти(АдресБезПротокола, "/");
	Если ПозицияСлеша > 0 Тогда
		ХостСПортом = Лев(АдресБезПротокола, ПозицияСлеша - 1);
		Результат.Путь = Сред(АдресБезПротокола, ПозицияСлеша);
	Иначе
		ХостСПортом = АдресБезПротокола;
		Результат.Путь = "";
	КонецЕсли;
	
	// Разделение хоста и порта
	ПозицияДвоеточия = Найти(ХостСПортом, ":");
	Если ПозицияДвоеточия > 0 Тогда
		Результат.Хост = Лев(ХостСПортом, ПозицияДвоеточия - 1);
		Попытка
			Результат.Порт = Число(Сред(ХостСПортом, ПозицияДвоеточия + 1));
		Исключение
			// Оставляем порт по умолчанию
		КонецПопытки;
	Иначе
		Результат.Хост = ХостСПортом;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ДИСПЕТЧЕР КОМАНД
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ВыполнитьКомандуНаСервере(Команда)
	
	ИмяИнструмента = СокрЛП(Команда.tool);
	ПараметрыКоманды = Неопределено;
	
	Если Команда.Свойство("params") Тогда
		ПараметрыКоманды = Команда.params;
	КонецЕсли;
	
	// Диспетчеризация по имени инструмента
	Если ИмяИнструмента = "execute_query" Тогда
		
		ТекстЗапроса = "";
		ПараметрыЗапроса = Новый Соответствие;
		Лимит = 100;
		ВключитьСхему = Ложь;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("query") Тогда
				ТекстЗапроса = ПараметрыКоманды.query;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("params") Тогда
				ПараметрыЗапроса = ПараметрыКоманды.params;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit") Тогда
				Лимит = ПараметрыКоманды.limit;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("include_schema") Тогда
				ВключитьСхему = (ПараметрыКоманды.include_schema = Истина);
			КонецЕсли;
		КонецЕсли;
		
		Возврат ВыполнитьЗапрос(ТекстЗапроса, ПараметрыЗапроса, Лимит, ВключитьСхему);
		
	ИначеЕсли ИмяИнструмента = "execute_code" Тогда
		
		Код = "";
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("code") Тогда
			Код = ПараметрыКоманды.code;
		КонецЕсли;
		
		Возврат ВыполнитьКод(Код);
		
	ИначеЕсли ИмяИнструмента = "get_metadata" Тогда

		Фильтр = "";
		ТипМетаданных = "";
		МаскаИмени = "";
		Лимит = 100;
		Смещение = 0;
		Секции = Неопределено;
		ИмяРасширения = Неопределено;  // КРИТИЧНО: Неопределено, НЕ ""
		КэшПараметры = Неопределено;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("filter") Тогда
				Фильтр = ПараметрыКоманды.filter;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("meta_type") Тогда
				ТипМетаданных = НормализоватьМассивПараметра(ПараметрыКоманды.meta_type);
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("name_mask") Тогда
				МаскаИмени = ПараметрыКоманды.name_mask;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit") Тогда
				Лимит = ПараметрыКоманды.limit;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("offset") Тогда
				Смещение = ПараметрыКоманды.offset;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("sections") Тогда
				Секции = ПараметрыКоманды.sections;
			КонецЕсли;
			// extension_name: присваиваем ТОЛЬКО если свойство есть в JSON
			Если ПараметрыКоманды.Свойство("extension_name") Тогда
				ИмяРасширения = ПараметрыКоманды.extension_name;  // может быть "" (список расширений)
			КонецЕсли;
			
			// Внутренние параметры кэша (токены ВременногоХранилища), добавляются на клиенте.
			Если ПараметрыКоманды.Свойство("mcp_cache_hash")
				Или ПараметрыКоманды.Свойство("mcp_cache_data_token")
				Или ПараметрыКоманды.Свойство("mcp_cache_index_token")
				Или ПараметрыКоманды.Свойство("mcp_cache_details_token") Тогда
				
				КэшПараметры = Новый Структура(
					"hash, data_token, index_token, details_token",
					?(ПараметрыКоманды.Свойство("mcp_cache_hash"), ПараметрыКоманды.mcp_cache_hash, ""),
					?(ПараметрыКоманды.Свойство("mcp_cache_data_token"), ПараметрыКоманды.mcp_cache_data_token, Неопределено),
					?(ПараметрыКоманды.Свойство("mcp_cache_index_token"), ПараметрыКоманды.mcp_cache_index_token, Неопределено),
					?(ПараметрыКоманды.Свойство("mcp_cache_details_token"), ПараметрыКоманды.mcp_cache_details_token, Неопределено)
				);
			КонецЕсли;
		КонецЕсли;

		Возврат ПолучитьМетаданные(Фильтр, ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, ИмяРасширения, КэшПараметры);
		
	ИначеЕсли ИмяИнструмента = "get_event_log" Тогда
		
		// Парсим даты из ISO формата
		ДатаНачала = Неопределено;
		ДатаОкончания = Неопределено;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("start_date") И ЗначениеЗаполнено(ПараметрыКоманды.start_date) Тогда
				ДатаНачала = ПрочитатьДатуИзISO(ПараметрыКоманды.start_date);
			КонецЕсли;
			
			Если ПараметрыКоманды.Свойство("end_date") И ЗначениеЗаполнено(ПараметрыКоманды.end_date) Тогда
				ДатаОкончания = ПрочитатьДатуИзISO(ПараметрыКоманды.end_date);
			КонецЕсли;
		КонецЕсли;
		
		Уровни = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("levels") Тогда
			Уровни = НормализоватьМассивПараметра(ПараметрыКоманды.levels);
		КонецЕсли;

		События = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("events") Тогда
			События = НормализоватьМассивПараметра(ПараметрыКоманды.events);
		КонецЕсли;
		
		Лимит = 100;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("limit") Тогда
			Лимит = ПараметрыКоманды.limit;
		КонецЕсли;
		
		// Разрешение параметра фильтра по объекту (приоритет: object_description > link > data)
		ДанныеОбъекта = Неопределено;
		
		Если ПараметрыКоманды <> Неопределено Тогда
			// Приоритет 1: object_description
			Если ПараметрыКоманды.Свойство("object_description") И ПараметрыКоманды.object_description <> Неопределено Тогда
				Попытка
					ДанныеОбъекта = СформироватьНавигационнуюСсылку(ПараметрыКоманды.object_description);
				Исключение
					// Возвращаем явную ошибку при невозможности сформировать навигационную ссылку
					Возврат Новый Структура("success, error", Ложь, 
						"Ошибка формирования навигационной ссылки: " + ОписаниеОшибки() + 
						" / Error creating navigation link: " + ОписаниеОшибки());
				КонецПопытки;
			
			// Приоритет 2: link
			ИначеЕсли ПараметрыКоманды.Свойство("link") И ЗначениеЗаполнено(ПараметрыКоманды.link) Тогда
				ДанныеОбъекта = ПараметрыКоманды.link;
			
			// Приоритет 3: data (обратная совместимость)
			ИначеЕсли ПараметрыКоманды.Свойство("data") И ЗначениеЗаполнено(ПараметрыКоманды.data) Тогда
				ДанныеОбъекта = ПараметрыКоманды.data;
			КонецЕсли;
		КонецЕсли;
		
		ТипыМетаданных = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("metadata_type") Тогда
			ТипыМетаданных = НормализоватьМассивПараметра(ПараметрыКоманды.metadata_type);
		КонецЕсли;

		ФильтрПользователи = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("user") Тогда
			ФильтрПользователи = НормализоватьМассивПараметра(ПараметрыКоманды.user);
		КонецЕсли;

		Сеансы = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("session") Тогда
			Сеансы = НормализоватьМассивПараметра(ПараметрыКоманды.session);
		КонецЕсли;

		Приложения = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("application") Тогда
			Приложения = НормализоватьМассивПараметра(ПараметрыКоманды.application);
		КонецЕсли;
		
		Компьютер = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("computer") Тогда
			Компьютер = ПараметрыКоманды.computer;
		КонецЕсли;
		
		ПодстрокаКомментария = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("comment_contains") Тогда
			ПодстрокаКомментария = ПараметрыКоманды.comment_contains;
		КонецЕсли;
		
		СтатусТранзакции = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("transaction_status") Тогда
			СтатусТранзакции = ПараметрыКоманды.transaction_status;
		КонецЕсли;

		// Курсорная пагинация: смещение записей в пределах начальной секунды
		СмещениеВСекунде = 0;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("same_second_offset") И ЗначениеЗаполнено(ПараметрыКоманды.same_second_offset) Тогда
			СмещениеВСекунде = ПараметрыКоманды.same_second_offset;
		КонецЕсли;

		Возврат ПолучитьЖурналРегистрации(ДатаНачала, ДатаОкончания, Уровни, События, Лимит,
			ДанныеОбъекта, ТипыМетаданных, ФильтрПользователи, Сеансы, Приложения, Компьютер,
			ПодстрокаКомментария, СтатусТранзакции, СмещениеВСекунде);
		
	ИначеЕсли ИмяИнструмента = "get_object_by_link" Тогда
		
		Ссылка = "";
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("link") Тогда
			Ссылка = ПараметрыКоманды.link;
		КонецЕсли;
		
		Возврат ПолучитьОбъектПоНавигационнойСсылке(Ссылка);
		
	ИначеЕсли ИмяИнструмента = "get_link_of_object" Тогда

		ОписаниеОбъекта = Неопределено;
		Если ПараметрыКоманды <> Неопределено И ПараметрыКоманды.Свойство("object_description") Тогда
			ОписаниеОбъекта = ПараметрыКоманды.object_description;
		КонецЕсли;

		Возврат ПолучитьНавигационнуюСсылкуПоОписанию(ОписаниеОбъекта);

	ИначеЕсли ИмяИнструмента = "find_references_to_object" Тогда

		ОписаниеЦелевогоОбъекта = Неопределено;
		ОбластиПоиска = Неопределено;
		ФильтрМетаданных = Неопределено;
		ЛимитНайденных = 200;
		ЛимитНаМетуОбъект = 20;
		БюджетВремениСек = 30;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("target_object_description") Тогда
				ОписаниеЦелевогоОбъекта = ПараметрыКоманды.target_object_description;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("search_scope") Тогда
				ОбластиПоиска = НормализоватьМассивПараметра(ПараметрыКоманды.search_scope);
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("meta_filter") Тогда
				ФильтрМетаданных = НормализоватьМассивПараметра(ПараметрыКоманды.meta_filter);
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit_hits") Тогда
				ЛимитНайденных = ПараметрыКоманды.limit_hits;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("limit_per_meta") Тогда
				ЛимитНаМетуОбъект = ПараметрыКоманды.limit_per_meta;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("timeout_budget_sec") Тогда
				БюджетВремениСек = ПараметрыКоманды.timeout_budget_sec;
			КонецЕсли;
		КонецЕсли;

		Возврат НайтиСсылкиНаОбъект(ОписаниеЦелевогоОбъекта, ОбластиПоиска, ФильтрМетаданных,
			ЛимитНайденных, ЛимитНаМетуОбъект, БюджетВремениСек);

	ИначеЕсли ИмяИнструмента = "get_access_rights" Тогда

		ИмяОбъектаМетаданных = "";
		ИмяПользователяИБ = Неопределено;
		ФильтрПрав = Неопределено;
		ФильтрРолей = Неопределено;

		Если ПараметрыКоманды <> Неопределено Тогда
			Если ПараметрыКоманды.Свойство("metadata_object") Тогда
				ИмяОбъектаМетаданных = ПараметрыКоманды.metadata_object;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("user_name") Тогда
				ИмяПользователяИБ = ПараметрыКоманды.user_name;
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("rights_filter") Тогда
				ФильтрПрав = НормализоватьМассивПараметра(ПараметрыКоманды.rights_filter);
			КонецЕсли;
			Если ПараметрыКоманды.Свойство("roles_filter") Тогда
				ФильтрРолей = НормализоватьМассивПараметра(ПараметрыКоманды.roles_filter);
			КонецЕсли;
		КонецЕсли;

		Возврат ПолучитьПраваДоступа(ИмяОбъектаМетаданных, ИмяПользователяИБ, ФильтрПрав, ФильтрРолей);

	Иначе
		
		Возврат Новый Структура("success, error", Ложь, "Неизвестный инструмент: " + ИмяИнструмента);
		
	КонецЕсли;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ВЫПОЛНЕНИЕ ЗАПРОСОВ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция БезопасноеЗначениеДляПередачи(Значение, Глубина = 0)
	
	Если Глубина > 5 Тогда
		Возврат "<max_depth>";
	КонецЕсли;
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	Если ТипЗначения = Тип("Строка")
		Или ТипЗначения = Тип("Число")
		Или ТипЗначения = Тип("Булево")
		Или ТипЗначения = Тип("Дата") Тогда
		Возврат Значение;
	КонецЕсли;
	
	Если ТипЗначения = Тип("УникальныйИдентификатор") Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
	Если ЭтоСсылка(ТипЗначения) Тогда
		Если ЗначениеЗаполнено(Значение) Тогда
			Возврат ОписаниеОбъектаПоСсылке(Значение);
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Массив") Тогда
		Результат = Новый Массив;
		Для Каждого Элемент Из Значение Цикл
			Результат.Добавить(БезопасноеЗначениеДляПередачи(Элемент, Глубина + 1));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;

	// ФиксированныйМассив (FixedArray) - сериализуем как обычный массив
	Если ТипЗначения = Тип("ФиксированныйМассив") Тогда
		Результат = Новый Массив;
		Попытка
			Для Каждого Элемент Из Значение Цикл
				Результат.Добавить(БезопасноеЗначениеДляПередачи(Элемент, Глубина + 1));
			КонецЦикла;
		Исключение
			// Если по какой-то причине не итерируется - оставим пустой массив
		КонецПопытки;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Структура") Тогда
		Результат = Новый Структура;
		Для Каждого Пара Из Значение Цикл
			Результат.Вставить(Пара.Ключ, БезопасноеЗначениеДляПередачи(Пара.Значение, Глубина + 1));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("Соответствие") Тогда
		Результат = Новый Массив;
		Для Каждого Пара Из Значение Цикл
			Результат.Добавить(Новый Структура(
				"key, value",
				БезопасноеЗначениеДляПередачи(Пара.Ключ, Глубина + 1),
				БезопасноеЗначениеДляПередачи(Пара.Значение, Глубина + 1)
			));
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Результат = Новый Массив;
		Для Каждого СтрокаТаблицы Из Значение Цикл
			СтрокаРезультата = Новый Структура;
			Для Каждого Колонка Из Значение.Колонки Цикл
				СтрокаРезультата.Вставить(Колонка.Имя, БезопасноеЗначениеДляПередачи(СтрокаТаблицы[Колонка.Имя], Глубина + 1));
			КонецЦикла;
			Результат.Добавить(СтрокаРезультата);
		КонецЦикла;
		Возврат Результат;
	КонецЕсли;

	// ОписаниеТипов (TypeDescription) -> строковое перечисление типов
	// Строка(ТипЗнч(ОписаниеТипов)) возвращает "Описание типов" (не "ОписаниеТипов"), поэтому используем прямое сравнение типов
	Если ТипЗначения = Тип("ОписаниеТипов") Тогда
		Попытка
			Возврат ПолучитьСтроковоеПредставлениеОписанияТипов(Значение);
		Исключение
			// Если по какой-то причине не удалось - обработаем ниже как строку
		КонецПопытки;
	КонецЕсли;

	// СвязьПоТипу (TypeLink) -> объект {ПутьКДанным?, ЭлементСвязи?}
	// Важно: если связь не настроена, возвращаем пустой объект {}, чтобы ключ properties.СвязьПоТипу оставался,
	// но не превращался в неинформативную строку "СвязьПоТипу".
	Попытка
		Если ТипЗначения = Тип("СвязьПоТипу") Тогда
			Результат = Новый Структура;
			
			Попытка
				ПутьКДанным = Значение.ПутьКДанным;
				Если ПутьКДанным <> Неопределено И НЕ ПустаяСтрока(Строка(ПутьКДанным)) Тогда
					Результат.Вставить("ПутьКДанным", Строка(ПутьКДанным));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				ЭлементСвязи = Значение.ЭлементСвязи;
				Если ЭлементСвязи <> Неопределено И ЭлементСвязи <> 0 Тогда
					Результат.Вставить("ЭлементСвязи", ЭлементСвязи);
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;

	// СвязьПараметраВыбора (ChoiceParameterLink) -> объект {Имя?, ПутьКДанным?, ИзменениеЗначения?}
	// Используется в СвязиПараметровВыбора (ChoiceParameterLinks): ФиксированныйМассив элементов этого типа.
	Попытка
		Если ТипЗначения = Тип("СвязьПараметраВыбора") Тогда
			Результат = Новый Структура;
			
			Попытка
				ИмяСвязи = Значение.Имя;
				Если ИмяСвязи <> Неопределено И НЕ ПустаяСтрока(Строка(ИмяСвязи)) Тогда
					Результат.Вставить("Имя", Строка(ИмяСвязи));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				ПутьКДанным = Значение.ПутьКДанным;
				Если ПутьКДанным <> Неопределено И НЕ ПустаяСтрока(Строка(ПутьКДанным)) Тогда
					Результат.Вставить("ПутьКДанным", Строка(ПутьКДанным));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Попытка
				РежимИзменения = Значение.ИзменениеЗначения;
				Если РежимИзменения <> Неопределено Тогда
					Результат.Вставить("ИзменениеЗначения", Строка(РежимИзменения));
				КонецЕсли;
			Исключение
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставОбщегоРеквизита (CommonAttributeContent) -> массив элементов состава
	// Каждый элемент: {Метаданные, Использование, УсловноеРазделение}
	Попытка
		Если ТипЗначения = Тип("СоставОбщегоРеквизита") Тогда
			Результат = Новый Массив;
			
			// Добавляем поле УсловноеРазделение только если оно реально встречается хотя бы у одного элемента.
			// Если встречается - ключ должен присутствовать у всех строк (у остальных будет null), чтобы табличный вывод не "терял" колонку.
			НужноПолеУсловноеРазделение = Ложь;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					Попытка
						Если ЭлементСостава.УсловноеРазделение <> Неопределено Тогда
							НужноПолеУсловноеРазделение = Истина;
							Прервать;
						КонецЕсли;
					Исключение
					КонецПопытки;
				КонецЦикла;
			Исключение
			КонецПопытки;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Метаданные (MetadataObject) -> ПолноеИмя() если возможно
					Попытка
						Мета = ЭлементСостава.Метаданные;
						Если Мета <> Неопределено Тогда
							ПолноеИмяМета = ПолноеИмяМетаданныхЕслиВозможно(Мета);
							Если ПолноеИмяМета = Неопределено Тогда
								Попытка
									ПолноеИмяМета = Мета.ПолноеИмя();
								Исключение
									ПолноеИмяМета = Строка(Мета);
								КонецПопытки;
							КонецЕсли;
							ЭлементJSON.Вставить("Метаданные", ПолноеИмяМета);
						КонецЕсли;
					Исключение
					КонецПопытки;
					
					// Использование (CommonAttributeUse) -> строка значения перечисления
					Попытка
						ЭлементJSON.Вставить("Использование", Строка(ЭлементСостава.Использование));
					Исключение
					КонецПопытки;
					
					// УсловноеРазделение (ConditionalSeparation): Константа/Булево/реквизит и т.д.
					Если НужноПолеУсловноеРазделение Тогда
						УсловиеJSON = Неопределено;
						Попытка
							Условие = ЭлементСостава.УсловноеРазделение;
							Если Условие <> Неопределено Тогда
								УсловиеJSON = ПолноеИмяМетаданныхЕслиВозможно(Условие);
								Если УсловиеJSON = Неопределено Тогда
									УсловиеJSON = БезопасноеЗначениеДляПередачи(Условие, Глубина + 1);
								КонецЕсли;
							КонецЕсли;
						Исключение
						КонецПопытки;
						ЭлементJSON.Вставить("УсловноеРазделение", УсловиеJSON);
					КонецЕсли;
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставПланаОбмена (ExchangePlanContent) -> массив элементов состава
	// Каждый элемент: {Метаданные, АвтоРегистрация}
	Попытка
		Если ТипЗначения = Тип("СоставПланаОбмена") Тогда
			Результат = Новый Массив;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Метаданные (MetadataObject) -> ПолноеИмя() если возможно
					ПолноеИмяМета = Неопределено;
					Попытка
						Мета = ЭлементСостава.Метаданные;
						Если Мета <> Неопределено Тогда
							ПолноеИмяМета = ПолноеИмяМетаданныхЕслиВозможно(Мета);
							Если ПолноеИмяМета = Неопределено Тогда
								Попытка
									ПолноеИмяМета = Мета.ПолноеИмя();
								Исключение
									ПолноеИмяМета = Строка(Мета);
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("Метаданные", ПолноеИмяМета);
					
					// АвтоРегистрация (AutoChangeRecord) -> строка значения перечисления
					АвтоРегистрацияJSON = Неопределено;
					Попытка
						АвтоРегистрацияJSON = Строка(ЭлементСостава.АвтоРегистрация);
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("АвтоРегистрация", АвтоРегистрацияJSON);
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
	
	// СоставФункциональнойОпции (FunctionalOptionContent) -> массив элементов состава
	// Каждый элемент: {Объект}
	Попытка
		Если ТипЗначения = Тип("СоставФункциональнойОпции") Тогда
			Результат = Новый Массив;
			Попытка
				Для Каждого ЭлементСостава Из Значение Цикл
					ЭлементJSON = Новый Структура;
					
					// Объект (MetadataObject) -> ПолноеИмя() если возможно
					ПолноеИмяОбъекта = Неопределено;
					Попытка
						ОбъектМета = ЭлементСостава.Объект;
						Если ОбъектМета <> Неопределено Тогда
							ПолноеИмяОбъекта = ПолноеИмяМетаданныхЕслиВозможно(ОбъектМета);
							Если ПолноеИмяОбъекта = Неопределено Тогда
								Попытка
									ПолноеИмяОбъекта = ОбъектМета.ПолноеИмя();
								Исключение
									ПолноеИмяОбъекта = Строка(ОбъектМета);
								КонецПопытки;
							КонецЕсли;
						КонецЕсли;
					Исключение
					КонецПопытки;
					ЭлементJSON.Вставить("Объект", ПолноеИмяОбъекта);
					
					Если ЭлементJSON.Количество() > 0 Тогда
						Результат.Добавить(ЭлементJSON);
					КонецЕсли;
				КонецЦикла;
			Исключение
				// Если по какой-то причине не итерируется - оставим как пустой массив
			КонецПопытки;
			
			Возврат Результат;
		КонецЕсли;
	Исключение
		// Если тип недоступен в данной версии платформы - игнорируем
	КонецПопытки;
  	
	// ОписаниеЗащитыОтОпасныхДействий (UnsafeOperationProtectionDescription) -> Булево
	// Возвращаем флаг ПредупреждатьОбОпасныхДействиях, чтобы в JSON было true/false.
	Если Строка(ТипЗначения) = "ОписаниеЗащитыОтОпасныхДействий" Тогда
		Попытка
			Возврат (Значение.ПредупреждатьОбОпасныхДействиях = Истина);
		Исключение
			// Если свойство недоступно (например, платформа < 8.3.8) - вернём строковое представление
		КонецПопытки;
	КонецЕсли;
 	
	Попытка
		Возврат Строка(Значение);
	Исключение
		Возврат "<" + Строка(ТипЗначения) + ">";
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ВыполнитьЗапрос(ТекстЗапроса, ПараметрыЗапроса, Лимит, ВключитьСхему = Ложь)
	
	Попытка
		
		Запрос = Новый Запрос(ТекстЗапроса);
		
		// Установка параметров запроса
		Если ТипЗнч(ПараметрыЗапроса) = Тип("Соответствие") Тогда
			Для Каждого Параметр Из ПараметрыЗапроса Цикл
				ЗначениеПараметра = Параметр.Значение;
				// Конвертация описания объекта обратно в ссылку
				ЗначениеПараметра = ОбъектИнформационнойБазыПоОписанию(ЗначениеПараметра);
				Запрос.УстановитьПараметр(Параметр.Ключ, ЗначениеПараметра);
			КонецЦикла;
		ИначеЕсли ТипЗнч(ПараметрыЗапроса) = Тип("Структура") Тогда
			Для Каждого Параметр Из ПараметрыЗапроса Цикл
				ЗначениеПараметра = Параметр.Значение;
				// Конвертация описания объекта обратно в ссылку
				ЗначениеПараметра = ОбъектИнформационнойБазыПоОписанию(ЗначениеПараметра);
				Запрос.УстановитьПараметр(Параметр.Ключ, ЗначениеПараметра);
			КонецЦикла;
		КонецЕсли;
		
		РезультатЗапроса = Запрос.Выполнить();
		
		// Формирование схемы если запрошено
		Схема = Неопределено;
		Если ВключитьСхему Тогда
			Схема = СформироватьСхемуРезультата(РезультатЗапроса);
		КонецЕсли;
		
		Выборка = РезультатЗапроса.Выбрать();
		
		МассивРезультата = Новый Массив;
		Счетчик = 0;
		
		Пока Выборка.Следующий() И Счетчик < Лимит Цикл
			
			СтрокаРезультата = Новый Структура;
			
			Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
				Значение = Выборка[Колонка.Имя];
				СтрокаРезультата.Вставить(Колонка.Имя, БезопасноеЗначениеДляПередачи(Значение));
			КонецЦикла;
			
			МассивРезультата.Добавить(СтрокаРезультата);
			Счетчик = Счетчик + 1;
			
		КонецЦикла;
		
		// Возврат результата с учетом параметра ВключитьСхему
		Если ВключитьСхему Тогда
			Возврат Новый Структура("success, data, schema", Истина, МассивРезультата, Схема);
		Иначе
			Возврат Новый Структура("success, data", Истина, МассивРезультата);
		КонецЕсли;
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// Формирует схему результата запроса с информацией о типах колонок
//
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - результат выполнения запроса
//
// Возвращаемое значение:
//  Структура - схема с полем columns (массив описаний колонок)
//    * columns - Массив - массив структур с описанием колонок:
//      ** name - Строка - имя колонки
//      ** types - Массив - массив строковых представлений типов (отсортирован, без дублей)
//
&НаСервереБезКонтекста
Функция СформироватьСхемуРезультата(РезультатЗапроса)
	
	МассивКолонок = Новый Массив;
	
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		
		МассивТипов = Новый Массив;
		
		Для Каждого Тип Из Колонка.ТипЗначения.Типы() Цикл
			СтроковыйТип = ПолучитьСтроковоеПредставлениеТипаДляСхемы(Тип);
			МассивТипов.Добавить(СтроковыйТип);
		КонецЦикла;
		
		// Сортировка и удаление дублей
		МассивТипов = УдалитьДублиИСортировать(МассивТипов);
		
		ОписаниеКолонки = Новый Структура("name, types", Колонка.Имя, МассивТипов);
		МассивКолонок.Добавить(ОписаниеКолонки);
		
	КонецЦикла;
	
	Возврат Новый Структура("columns", МассивКолонок);
	
КонецФункции

// Получает строковое представление типа для схемы результата запроса
//
// Параметры:
//  Тип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - строковое представление типа
//
&НаСервереБезКонтекста
Функция ПолучитьСтроковоеПредставлениеТипаДляСхемы(Тип)
	
	// Используем существующую функцию ЭтоСсылка для проверки ссылочного типа
	// и существующую СтроковоеПредставлениеТипа для получения полного имени
	
	Если ЭтоСсылка(Тип) Тогда
		// Для ссылочных типов используем СтроковоеПредставлениеТипа
		// Возвращает полное имя: "СправочникСсылка.Контрагенты"
		Возврат СтроковоеПредставлениеТипа(Тип);
	Иначе
		// Для примитивных типов используем Строка(Тип)
		// Возвращает: "Строка", "Число", "Дата", "Булево"
		Возврат Строка(Тип);
	КонецЕсли;
	
КонецФункции

// Удаляет дубликаты из массива строк и сортирует его
//
// Параметры:
//  МассивСтрок - Массив - массив строк для обработки
//
// Возвращаемое значение:
//  Массив - отсортированный массив уникальных строк
//
&НаСервереБезКонтекста
Функция УдалитьДублиИСортировать(МассивСтрок)
	
	// Используем соответствие для удаления дублей
	Соответствие = Новый Соответствие;
	Для Каждого Строка Из МассивСтрок Цикл
		Соответствие.Вставить(Строка, Истина);
	КонецЦикла;
	
	// Собираем уникальные значения
	УникальныеЗначения = Новый Массив;
	Для Каждого КлючЗначение Из Соответствие Цикл
		УникальныеЗначения.Добавить(КлючЗначение.Ключ);
	КонецЦикла;
	
	// Сортировка через СписокЗначений
	СписокДляСортировки = Новый СписокЗначений;
	Для Каждого Значение Из УникальныеЗначения Цикл
		СписокДляСортировки.Добавить(Значение);
	КонецЦикла;
	СписокДляСортировки.СортироватьПоЗначению();
	
	// Результат
	Результат = Новый Массив;
	Для Каждого Элемент Из СписокДляСортировки Цикл
		Результат.Добавить(Элемент.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ВЫПОЛНЕНИЕ ПРОИЗВОЛЬНОГО КОДА
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ВыполнитьКод(Код)
	
	Попытка
		
		Результат = Неопределено;
		Выполнить(Код);
		
		Возврат Новый Структура("success, data", Истина, БезопасноеЗначениеДляПередачи(Результат));
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПОЛУЧЕНИЕ МЕТАДАННЫХ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьМетаданные(Фильтр, ТипМетаданных = "", МаскаИмени = "", Лимит = 100, Смещение = 0, Секции = Неопределено, ИмяРасширения = Неопределено, КэшПараметры = Неопределено)

	Попытка

		// Обработка расширений: ИмяРасширения <> Неопределено означает работу с расширениями
		Если ИмяРасширения <> Неопределено Тогда
			Если ПустаяСтрока(ИмяРасширения) Тогда
				// Пустая строка = запрос списка всех расширений
				Возврат ПолучитьСписокРасширений();
			Иначе
				// Конкретное имя = работа с метаданными внутри расширения
				Возврат ПолучитьМетаданныеРасширения(ИмяРасширения, Фильтр,
							ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, КэшПараметры);
			КонецЕсли;
		КонецЕсли;

		// Основная конфигурация (ИмяРасширения = Неопределено)
		Если ПустаяСтрока(Фильтр) Тогда
			// Новый контракт:
			// - без filter и без meta_type и без name_mask: сводка (configuration + roots)
			// - meta_type задан (или задан name_mask): список объектов данного типа (или "*" для полного списка)
			ТипТипМетаданных = ТипЗнч(ТипМетаданных);
			НетТипаМетаданных = (ТипМетаданных = Неопределено) Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных));

			Если НетТипаМетаданных И ПустаяСтрока(МаскаИмени) Тогда
				Возврат ПолучитьСводкуМетаданных();
			Иначе
				Если НетТипаМетаданных Тогда
					ТипМетаданных = "*";
				КонецЕсли;
				Возврат ПолучитьСписокМетаданных(ТипМетаданных, МаскаИмени, Лимит, Смещение);
			КонецЕсли;
		Иначе
			Возврат ПолучитьДетальныеМетаданные(Фильтр, Секции);
		КонецЕсли;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// РАБОТА С РАСШИРЕНИЯМИ КОНФИГУРАЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьКоллекциюИзРасширения(ОбъектРасширения, ИмяКоллекции)
	// Унифицированный доступ к коллекциям метаданных внутри объекта расширения.
	// В разных версиях/контекстах платформа может по-разному предоставлять доступ:
	// - через свойство (ОбъектРасширения.<Коллекция>)
	// - через индексатор (ОбъектРасширения[<Коллекция>])
	
	Коллекция = Неопределено;
	
	Попытка
		Коллекция = Вычислить("ОбъектРасширения." + ИмяКоллекции);
	Исключение
		Коллекция = Неопределено;
	КонецПопытки;
	
	Если Коллекция = Неопределено Тогда
		Попытка
			Коллекция = ОбъектРасширения[ИмяКоллекции];
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Возврат Коллекция;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокРасширений()
	// Возвращает список всех подключённых расширений конфигурации

	Попытка
		// Платформенный API для расширений находится в глобальном контексте:
		//   РасширенияКонфигурации (ConfigurationExtensionsManager)
		// В рантайм-метаданных (Метаданные.…) этого поля может не быть.
		МассивРасширений = Неопределено;
		Попытка
			МассивРасширений = РасширенияКонфигурации.Получить();
		Исключение
			МассивРасширений = Неопределено;
		КонецПопытки;

		Если МассивРасширений = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширения конфигурации недоступны в данной версии платформы");
		КонецЕсли;

		СписокРасширений = Новый Массив;

		Для Каждого ТекРасширение Из МассивРасширений Цикл
			ИнфоРасширения = Новый Структура;
			
			// Возвращаем свойства объекта РасширениеКонфигурации (ConfigurationExtension).
			// Количество объектов расширения намеренно НЕ возвращаем: это отдельная задача
			// и может зависеть от способа анализа данных расширения.
			СвойстваРасширения = Новый Массив;
			СвойстваРасширения.Добавить("Имя");
			СвойстваРасширения.Добавить("Синоним");
			СвойстваРасширения.Добавить("Версия");
			СвойстваРасширения.Добавить("Активно");
			СвойстваРасширения.Добавить("БезопасныйРежим");
			СвойстваРасширения.Добавить("ГлавныйУзел");
			СвойстваРасширения.Добавить("ЗащитаОтОпасныхДействий");
			СвойстваРасширения.Добавить("ИспользоватьОсновныеРолиДляВсехПользователей");
			СвойстваРасширения.Добавить("ИспользуетсяВРаспределеннойИнформационнойБазе");
			СвойстваРасширения.Добавить("Назначение");
			СвойстваРасширения.Добавить("ОбластьДействия");
			СвойстваРасширения.Добавить("ОсновныеРоли");
			СвойстваРасширения.Добавить("УникальныйИдентификатор");
			СвойстваРасширения.Добавить("ХешСумма");
			
			Для Каждого ИмяСвойства Из СвойстваРасширения Цикл
				ЗначениеСвойства = Неопределено;
				Попытка
					ЗначениеСвойства = Вычислить("ТекРасширение." + ИмяСвойства);
				Исключение
					ЗначениеСвойства = Неопределено;
				КонецПопытки;
				
				// Спец. обработка: ЗащитаОтОпасныхДействий.
				// По справке это не булево, а объект ОписаниеЗащитыОтОпасныхДействий,
				// но в API мы хотим возвращать простое true/false.
				Если ИмяСвойства = "ЗащитаОтОпасныхДействий" Тогда
					БулевоЗначение = Неопределено;
					Попытка
						Если ЗначениеСвойства <> Неопределено Тогда
							БулевоЗначение = (ЗначениеСвойства.ПредупреждатьОбОпасныхДействиях = Истина);
						КонецЕсли;
					Исключение
						БулевоЗначение = Неопределено;
					КонецПопытки;
					ЗначениеСвойства = БулевоЗначение;
				КонецЕсли;
				
				// Вставляем ключ всегда, даже если значение Неопределено (будет null в JSON).
				ИнфоРасширения.Вставить(ИмяСвойства, БезопасноеЗначениеДляПередачи(ЗначениеСвойства));
			КонецЦикла;

			СписокРасширений.Добавить(ИнфоРасширения);
		КонецЦикла;

		Возврат Новый Структура("success, data", Истина, СписокРасширений);

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КЭШ МЕТАДАННЫХ РАСШИРЕНИЙ (ОбъектМетаданныхКонфигурация)
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьКэшМетаданныхРасширений()
	// В модуле формы (особенно при проверке "Толстый клиент (обычное приложение)")
	// серверные модульные переменные недоступны/нестабильны для &НаСервереБезКонтекста.
	// Поэтому кэш здесь отключён: возвращаем новый контейнер, который не сохраняется между вызовами.
	Возврат Новый Соответствие;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьКлючКэшаРасширения(Расширение)
	Ключ = "";
	Попытка
		Если Расширение.УникальныйИдентификатор <> Неопределено Тогда
			Ключ = Строка(Расширение.УникальныйИдентификатор);
		КонецЕсли;
	Исключение
		Ключ = "";
	КонецПопытки;

	Если ПустаяСтрока(Ключ) Тогда
		Попытка
			Ключ = Расширение.Имя;
		Исключение
			Ключ = "";
		КонецПопытки;
	КонецЕсли;

	Возврат Ключ;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьХешРасширенияСтрокой(Расширение)
	Хеш = "";
	Попытка
		Хеш = Строка(Расширение.ХешСумма);
	Исключение
		Хеш = "";
	КонецПопытки;
	Возврат Хеш;
КонецФункции

&НаСервереБезКонтекста
Функция ПостроитьИндексМетаданныхРасширения(МетаданныеРасширения)
	// Возвращает ТаблицаЗначений со всеми объектами расширения (верхний уровень),
	// отсортированную по ПолноеИмя (через SortKey) для стабильной пагинации.
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Тип");
	Таблица.Колонки.Добавить("Имя");
	Таблица.Колонки.Добавить("Синоним");
	Таблица.Колонки.Добавить("ПолноеИмя");
	Таблица.Колонки.Добавить("SortKey");

	КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
	Для Каждого ОписаниеТипа Из КорневыеТипы Цикл

		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("МетаданныеРасширения." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;

		Если Коллекция = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Для Каждого ОбъектМетаданных Из Коллекция Цикл

			Имя = "";
			Синоним = "";
			ПолноеИмя = "";

			Попытка
				Имя = ОбъектМетаданных.Имя;
			Исключение
				Имя = "";
			КонецПопытки;

			Попытка
				Синоним = ОбъектМетаданных.Синоним;
			Исключение
				Синоним = "";
			КонецПопытки;

			Попытка
				ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
			Исключение
				ПолноеИмя = "";
			КонецПопытки;

			Если ПустаяСтрока(ПолноеИмя) Тогда
				Если НЕ ПустаяСтрока(Имя) Тогда
					ПолноеИмя = ОписаниеТипа.Тип + "." + Имя;
				Иначе
					ПолноеИмя = ОписаниеТипа.Тип;
				КонецЕсли;
			КонецЕсли;

			Стр = Таблица.Добавить();
			Стр.Тип = ОписаниеТипа.Тип;
			Стр.Имя = Имя;
			Стр.Синоним = Синоним;
			Стр.ПолноеИмя = ПолноеИмя;
			Стр.SortKey = ВРег(ПолноеИмя);

		КонецЦикла;
	КонецЦикла;

	Таблица.Сортировать("SortKey, ПолноеИмя");
	Возврат Таблица;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры = Неопределено)
	// Возвращает структуру:
	// - success: Булево
	// - metadata: ОбъектМетаданныхКонфигурация | Неопределено
	// - index: ТаблицаЗначений | Неопределено
	// - is_empty: Булево (Истина если расширение пустое: ПолучитьДанные() вернуло Неопределено без ошибки)
	// - error: Строка (если success=Ложь)
	// - hash: Строка (ХешСумма расширения)
	// - data_token: адрес ВременногоХранилища для ДвоичныхДанных (best effort)
	Рез = Новый Структура("success, metadata, index, is_empty, error, hash, data_token",
		Ложь, Неопределено, Неопределено, Ложь, "", "", Неопределено);

	Если Расширение = Неопределено Тогда
		Рез.error = "Расширение не задано";
		Возврат Рез;
	КонецЕсли;

	Хеш = ПолучитьХешРасширенияСтрокой(Расширение);
	Рез.hash = Хеш;

	// Получаем бинарные данные расширения
	Данные = Неопределено;
	ОшибкаДанных = "";
	
	// 1) Попытка использовать токен кэша (ВременноеХранилище) если хеш совпадает
	Если КэшПараметры <> Неопределено Тогда
		Попытка
			Если КэшПараметры.Свойство("hash")
				И КэшПараметры.hash = Хеш
				И КэшПараметры.Свойство("data_token")
				И КэшПараметры.data_token <> Неопределено Тогда
				
				ТокенДанных = КэшПараметры.data_token;
				Попытка
					Данные = ПолучитьИзВременногоХранилища(ТокенДанных);
					Рез.data_token = ТокенДанных;
				Исключение
					Данные = Неопределено;
					Рез.data_token = Неопределено;
				КонецПопытки;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	// 2) Если токена нет/протух, получаем данные через API расширения
	Попытка
		Если Данные = Неопределено Тогда
			Данные = Расширение.ПолучитьДанные();
		КонецЕсли;
	Исключение
		ОшибкаДанных = ОписаниеОшибки();
		Данные = Неопределено;
	КонецПопытки;

	Если Данные = Неопределено Тогда
		Если НЕ ПустаяСтрока(ОшибкаДанных) Тогда
			Рез.error = "Не удалось получить данные расширения: " + ОшибкаДанных;
			Возврат Рез;
		КонецЕсли;

		// Пустое расширение (GetData() вернуло Неопределено без ошибки)
		Рез.success = Истина;
		Рез.is_empty = Истина;

		Возврат Рез;
	КонецЕсли;
	
	// 3) Кладём ДвоичныеДанные во ВременноеХранилище (best effort), если ещё нет токена
	Если Рез.data_token = Неопределено Тогда
		Попытка
			Рез.data_token = ПоместитьВоВременноеХранилище(Данные);
		Исключение
			Рез.data_token = Неопределено;
		КонецПопытки;
	КонецЕсли;

	// Парсим метаданные расширения
	МетаданныеРасширения = Неопределено;
	ОшибкаПарсинга = "";
	Попытка
		МетаданныеРасширения = Новый ОбъектМетаданныхКонфигурация(Данные);
	Исключение
		ОшибкаПарсинга = ОписаниеОшибки();
		МетаданныеРасширения = Неопределено;
	КонецПопытки;

	Если МетаданныеРасширения = Неопределено Тогда
		Рез.error = "Не удалось прочитать метаданные расширения (ОбъектМетаданныхКонфигурация): " + ОшибкаПарсинга;
		Возврат Рез;
	КонецЕсли;

	Индекс = ПостроитьИндексМетаданныхРасширения(МетаданныеРасширения);

	Рез.success = Истина;
	Рез.metadata = МетаданныеРасширения;
	Рез.index = Индекс;

	Возврат Рез;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьМетаданныеРасширения(ИмяРасширения, Фильтр, ТипМетаданных, МаскаИмени, Лимит, Смещение, Секции, КэшПараметры = Неопределено)
	// Маршрутизатор для работы с метаданными конкретного расширения

	Попытка
		// 1. Проверяем доступность API расширений
		МассивРасширений = Неопределено;
		Попытка
			Отбор = Новый Структура("Имя", ИмяРасширения);
			МассивРасширений = РасширенияКонфигурации.Получить(Отбор);
		Исключение
			МассивРасширений = Неопределено;
		КонецПопытки;

		Если МассивРасширений = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширения конфигурации недоступны в данной версии платформы");
		КонецЕсли;

		// 2. Находим расширение по имени
		НайденноеРасширение = Неопределено;
		Если ТипЗнч(МассивРасширений) = Тип("Массив") И МассивРасширений.Количество() > 0 Тогда
			НайденноеРасширение = МассивРасширений[0];
		КонецЕсли;

		// 3. Обработка ошибки: расширение не найдено
		Если НайденноеРасширение = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Расширение не найдено: " + ИмяРасширения);
		КонецЕсли;

		// 4. Выбор режима: details или list
		Если НЕ ПустаяСтрока(Фильтр) Тогда
			Возврат ПолучитьДетальныеМетаданныеРасширения(НайденноеРасширение, Фильтр, Секции, КэшПараметры);
		Иначе
			// Новый контракт (симметрия с основной конфигурацией):
			// Если не задано filter/meta_type/name_mask — возвращаем summary по типам внутри расширения.
			ТипТипМетаданных = ТипЗнч(ТипМетаданных);
			НетТипаМетаданных = (ТипМетаданных = Неопределено)
				Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных));

			Если ТипТипМетаданных = Тип("Массив") Тогда
				Попытка
					Если ТипМетаданных.Количество() = 0 Тогда
						НетТипаМетаданных = Истина;
					КонецЕсли;
				Исключение
				КонецПопытки;
			КонецЕсли;

			Если НетТипаМетаданных И ПустаяСтрока(МаскаИмени) Тогда
				Возврат ПолучитьСводкуМетаданныхРасширения(НайденноеРасширение, КэшПараметры);
			КонецЕсли;

			Возврат ПолучитьСписокМетаданныхРасширения(НайденноеРасширение,
						ТипМетаданных, МаскаИмени, Лимит, Смещение, КэшПараметры);
		КонецЕсли;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСводкуМетаданныхРасширения(Расширение, КэшПараметры = Неопределено)
	// Возвращает summary по корневым типам ВНУТРИ расширения:
	// {success: true, data: [{Тип, Количество}...], configuration: {...}, extension: "ИмяРасширения"}

	Попытка
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		ТокенИндекса = Неопределено;
		Индекс = Неопределено;

		// 1) Попытка использовать кэш индекса (ВременноеХранилище) если хеш совпадает
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash")
					И КэшПараметры.hash = ТекущийХеш Тогда

					Если КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;

					Если КэшПараметры.Свойство("index_token")
						И КэшПараметры.index_token <> Неопределено Тогда

						ТокенИндекса = КэшПараметры.index_token;
						КэшИндекс = Неопределено;
						Попытка
							КэшИндекс = ПолучитьИзВременногоХранилища(ТокенИндекса);
						Исключение
							КэшИндекс = Неопределено;
						КонецПопытки;

						Если КэшИндекс <> Неопределено
							И ТипЗнч(КэшИндекс) = Тип("ТаблицаЗначений") Тогда
							Индекс = КэшИндекс;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// 2) Если индекса нет - строим/получаем заново (используя кэш ДвоичныхДанных, если он есть)
		Если Индекс = Неопределено Тогда
			РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
			Если НЕ РезМД.success Тогда
				Возврат Новый Структура("success, error", Ложь, РезМД.error);
			КонецЕсли;

			ТекущийХеш = РезМД.hash;
			ТокенДанных = РезМД.data_token;

			Если РезМД.is_empty Тогда
				// Пустое расширение: все типы по 0
				Счетчики = Новый Соответствие;
				Для Каждого ОписаниеТипа Из ПолучитьКорневыеТипыМетаданных() Цикл
					Счетчики.Вставить(ОписаниеТипа.Тип, 0);
				КонецЦикла;

				Сводка = Новый Массив;
				Для Каждого ОписаниеТипа Из ПолучитьКорневыеТипыМетаданных() Цикл
					Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, 0));
				КонецЦикла;

				ИнфоКонф = ПолучитьИнформациюОКонфигурации();
				Результат = Новый Структура("success, data, configuration, extension", Истина, Сводка, ИнфоКонф, Расширение.Имя);

				// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
				Результат.Вставить("mcp_cache_hash", ТекущийХеш);
				Если ТокенДанных <> Неопределено Тогда
					Результат.Вставить("mcp_cache_data_token", ТокенДанных);
				КонецЕсли;

				Возврат Результат;
			КонецЕсли;

			Индекс = РезМД.index;
			Если Индекс = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Не удалось построить индекс метаданных расширения");
			КонецЕсли;

			// Кэшируем индекс во ВременномХранилище (best effort)
			Попытка
				ТокенИндекса = ПоместитьВоВременноеХранилище(Индекс);
			Исключение
				ТокенИндекса = Неопределено;
			КонецПопытки;
		КонецЕсли;

		// 3) Подсчет по типам (одним проходом по индексу)
		Счетчики = Новый Соответствие;
		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Счетчики.Вставить(ОписаниеТипа.Тип, 0);
		КонецЦикла;

		Для Каждого СтрИндекса Из Индекс Цикл
			ТипСтроки = "";
			Попытка
				ТипСтроки = Строка(СтрИндекса.Тип);
			Исключение
				ТипСтроки = "";
			КонецПопытки;

			Если ПустаяСтрока(ТипСтроки) Тогда
				Продолжить;
			КонецЕсли;

			Текущее = Счетчики.Получить(ТипСтроки);
			Если Текущее = Неопределено Тогда
				Счетчики.Вставить(ТипСтроки, 1);
			Иначе
				Счетчики.Вставить(ТипСтроки, Текущее + 1);
			КонецЕсли;
		КонецЦикла;

		Сводка = Новый Массив;
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Кол = Счетчики.Получить(ОписаниеТипа.Тип);
			Если Кол = Неопределено Тогда
				Кол = 0;
			КонецЕсли;
			Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, Кол));
		КонецЦикла;

		ИнфоКонф = ПолучитьИнформациюОКонфигурации();
		Результат = Новый Структура("success, data, configuration, extension", Истина, Сводка, ИнфоКонф, Расширение.Имя);

		// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенИндекса <> Неопределено Тогда
			Результат.Вставить("mcp_cache_index_token", ТокенИндекса);
		КонецЕсли;

		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокМетаданныхРасширения(Расширение, ТипМетаданных, МаскаИмени, Лимит, Смещение, КэшПараметры = Неопределено)
	// Возвращает список объектов метаданных внутри расширения (list-режим с пагинацией)

	Попытка
		// list-режим расширения: используем кэш индекса (ТаблицаЗначений) во ВременномХранилище, если доступен.
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		ТокенИндекса = Неопределено;
		Индекс = Неопределено;
		
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash")
					И КэшПараметры.hash = ТекущийХеш
					И КэшПараметры.Свойство("index_token")
					И КэшПараметры.index_token <> Неопределено Тогда
					
					ТокенИндекса = КэшПараметры.index_token;
					Попытка
						КэшИндекс = ПолучитьИзВременногоХранилища(ТокенИндекса);
					Исключение
						КэшИндекс = Неопределено;
					КонецПопытки;
					
					Если КэшИндекс <> Неопределено И ТипЗнч(КэшИндекс) = Тип("ТаблицаЗначений") Тогда
						Индекс = КэшИндекс;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;
		
		// Если индекса нет в кэше - строим заново (используя кэш ДвоичныхДанных, если он есть)
		Если Индекс = Неопределено Тогда
			РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
			Если НЕ РезМД.success Тогда
				Возврат Новый Структура("success, error", Ложь, РезМД.error);
			КонецЕсли;
			
			ТекущийХеш = РезМД.hash;
			ТокенДанных = РезМД.data_token;
			
			// Пустое расширение: объектов нет
			Если РезМД.is_empty Тогда
				Результат = Новый Структура;
				Результат.Вставить("success", Истина);
				Результат.Вставить("data", Новый Массив);
				Результат.Вставить("extension", Расширение.Имя);
				Результат.Вставить("truncated", Ложь);
				Результат.Вставить("limit", Лимит);
				Результат.Вставить("returned", 0);
				Результат.Вставить("count", 0);
				Результат.Вставить("offset", Смещение);
				Результат.Вставить("has_more", Ложь);
				Результат.Вставить("next_offset", Смещение);
				Результат.Вставить("mcp_cache_hash", ТекущийХеш);
				Если ТокенДанных <> Неопределено Тогда
					Результат.Вставить("mcp_cache_data_token", ТокенДанных);
				КонецЕсли;
				Возврат Результат;
			КонецЕсли;
			
			Индекс = РезМД.index;
			Если Индекс = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Не удалось построить индекс метаданных расширения");
			КонецЕсли;
			
			// Кэшируем индекс во ВременномХранилище (best effort)
			Попытка
				ТокенИндекса = ПоместитьВоВременноеХранилище(Индекс);
			Исключение
				ТокенИндекса = Неопределено;
			КонецПопытки;
		Иначе
			// Индекс пришёл из кэша; попытаемся вернуть токен ДвоичныхДанных для обновления клиентского кэша (если передан)
			Если КэшПараметры <> Неопределено Тогда
				Попытка
					Если КэшПараметры.Свойство("hash") И КэшПараметры.hash = ТекущийХеш
						И КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;
				Исключение
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;

		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();

		// ТипМетаданных может быть строкой ("Документ", "*") или массивом строк
		ТипыДляОбработки = Новый Массив;
		ТипТипМетаданных = ТипЗнч(ТипМетаданных);
		
		Если ТипМетаданных = Неопределено Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных)) Тогда
			ТипМетаданных = "*";
			ТипТипМетаданных = Тип("Строка");
		КонецЕсли;
		
		Если ТипТипМетаданных = Тип("Строка") Тогда
			
			Если ТипМетаданных = "*" Тогда
				ТипыДляОбработки = КорневыеТипы;
			Иначе
				ОписаниеЗапрошенногоТипа = Неопределено;
				Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
					Если ОписаниеТипа.Тип = ТипМетаданных Тогда
						ОписаниеЗапрошенногоТипа = ОписаниеТипа;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
					Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ТипМетаданных);
				КонецЕсли;
				
				ТипыДляОбработки.Добавить(ОписаниеЗапрошенногоТипа);
			КонецЕсли;
			
		ИначеЕсли ТипТипМетаданных = Тип("Массив") Тогда
			
			ЗапрошеныВсеТипы = Ложь;
			Уникальные = Новый Соответствие;
			
			Попытка
				Для Каждого ИмяТипа Из ТипМетаданных Цикл
					ИмяТипа = СокрЛП(Строка(ИмяТипа));
					Если ПустаяСтрока(ИмяТипа) Тогда
						Продолжить;
					КонецЕсли;
					Если ИмяТипа = "*" Тогда
						ЗапрошеныВсеТипы = Истина;
						Прервать;
					КонецЕсли;
					Уникальные.Вставить(ИмяТипа, Истина);
				КонецЦикла;
			Исключение
				Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
			КонецПопытки;
			
			Если ЗапрошеныВсеТипы Тогда
				ТипыДляОбработки = КорневыеТипы;
			Иначе
				Для Каждого Пара Из Уникальные Цикл
					ИмяТипа = Пара.Ключ;
					ОписаниеЗапрошенногоТипа = Неопределено;
					Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
						Если ОписаниеТипа.Тип = ИмяТипа Тогда
							ОписаниеЗапрошенногоТипа = ОписаниеТипа;
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
					Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
						Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ИмяТипа);
					КонецЕсли;
					
					ТипыДляОбработки.Добавить(ОписаниеЗапрошенногоТипа);
				КонецЦикла;
			КонецЕсли;
			
		Иначе
			Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
		КонецЕсли;

		// Быстрый фильтр по типам (если не "*")
		РазрешенныеТипы = Неопределено;
		Если НЕ (ТипТипМетаданных = Тип("Строка") И ТипМетаданных = "*") Тогда
			РазрешенныеТипы = Новый Соответствие;
			Для Каждого ОписаниеТипа Из ТипыДляОбработки Цикл
				РазрешенныеТипы.Вставить(ОписаниеТипа.Тип, Истина);
			КонецЦикла;
		КонецЕсли;

		Если Смещение < 0 Тогда
			Смещение = 0;
		КонецЕсли;

		МаскаВерхнийРегистр = "";
		Если МаскаИмени <> Неопределено Тогда
			Попытка
				МаскаВерхнийРегистр = ВРег(МаскаИмени);
			Исключение
				МаскаВерхнийРегистр = "";
			КонецПопытки;
		КонецЕсли;

		РезультатСписок = Новый Массив;
		ВсегоПодходящих = 0;
		Возвращено = 0;
		ЕстьЕще = Ложь;

		Для Каждого СтрИндекса Из Индекс Цикл
			Если РазрешенныеТипы <> Неопределено Тогда
				Если РазрешенныеТипы.Получить(СтрИндекса.Тип) = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;

			Если НЕ ПрошелФильтрПоМаске(СтрИндекса.Имя, СтрИндекса.Синоним, МаскаВерхнийРегистр) Тогда
				Продолжить;
			КонецЕсли;

			// ВАЖНО: count должен быть точным, поэтому не прерываем обход после набора страницы.
			// После достижения лимита перестаём добавлять элементы в data, но продолжаем считать ВсегоПодходящих.
			Если ВсегоПодходящих >= Смещение И Возвращено < Лимит Тогда
				РезультатСписок.Добавить(Новый Структура("ПолноеИмя, Синоним", СтрИндекса.ПолноеИмя, СтрИндекса.Синоним));
				Возвращено = Возвращено + 1;
			КонецЕсли;

			ВсегоПодходящих = ВсегоПодходящих + 1;
		КонецЦикла;

		ЕстьЕще = (Смещение + Возвращено) < ВсегоПодходящих;
		Обрезано = ЕстьЕще;
		СледующееСмещение = Смещение + Возвращено;

		Результат = Новый Структура;
		Результат.Вставить("success", Истина);
		Результат.Вставить("data", РезультатСписок);
		Результат.Вставить("extension", Расширение.Имя);
		Результат.Вставить("truncated", Обрезано);
		Результат.Вставить("limit", Лимит);
		Результат.Вставить("returned", Возвращено);
		Результат.Вставить("count", ВсегоПодходящих);
		Результат.Вставить("offset", Смещение);
		Результат.Вставить("has_more", Обрезано);
		Результат.Вставить("next_offset", СледующееСмещение);
		
		// Внутренние поля для обновления клиентского кэша (не уходят наружу из-за whitelist)
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенИндекса <> Неопределено Тогда
			Результат.Вставить("mcp_cache_index_token", ТокенИндекса);
		КонецЕсли;
		
		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеРасширения(Расширение, Фильтр, Секции, КэшПараметры = Неопределено)
	// Возвращает детальную структуру объекта метаданных внутри расширения (details-режим)

	Попытка
		// Парсим Фильтр: "ТипМетаданных.ИмяОбъекта[.ОстатокПути]"
		ПозицияТочки = Найти(Фильтр, ".");
		Если ПозицияТочки = 0 Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Неверный формат фильтра: " + Фильтр + ". Ожидается 'ТипМетаданных.ИмяОбъекта'");
		КонецЕсли;

		ТипОбъекта = Лев(Фильтр, ПозицияТочки - 1);
		ОстатокПослеТипа = Сред(Фильтр, ПозицияТочки + 1);

		// Ищем вторую точку — она отделяет ИмяОбъекта от пути к элементу коллекции
		ПозицияВторойТочки = Найти(ОстатокПослеТипа, ".");
		Если ПозицияВторойТочки = 0 Тогда
			// Формат "Тип.Объект" — стандартное поведение
			ИмяОбъекта = ОстатокПослеТипа;
			ОстатокПутиЭлемента = "";
		Иначе
			ИмяОбъекта = Лев(ОстатокПослеТипа, ПозицияВторойТочки - 1);
			ОстатокПутиЭлемента = Сред(ОстатокПослеТипа, ПозицияВторойТочки + 1);
		КонецЕсли;

		// Находим коллекцию по типу
		КорневыеТипы = ПолучитьКорневыеТипыМетаданных();
		ИмяКоллекции = "";
		Для Каждого ОписаниеТипа Из КорневыеТипы Цикл
			Если ОписаниеТипа.Тип = ТипОбъекта Тогда
				ИмяКоллекции = ОписаниеТипа.Коллекция;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если ПустаяСтрока(ИмяКоллекции) Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Неизвестный тип метаданных: " + ТипОбъекта);
		КонецЕсли;
		
		// Попытка взять details-ответ из кэша (ВременноеХранилище) если хеш расширения совпадает
		ТекущийХеш = ПолучитьХешРасширенияСтрокой(Расширение);
		ТокенДанных = Неопределено;
		
		Если КэшПараметры <> Неопределено Тогда
			Попытка
				Если КэшПараметры.Свойство("hash") И КэшПараметры.hash = ТекущийХеш Тогда
					Если КэшПараметры.Свойство("data_token") Тогда
						ТокенДанных = КэшПараметры.data_token;
					КонецЕсли;
					
					Если КэшПараметры.Свойство("details_token") И КэшПараметры.details_token <> Неопределено Тогда
						ТокенДеталей = КэшПараметры.details_token;
						КэшДетали = Неопределено;
						Попытка
							КэшДетали = ПолучитьИзВременногоХранилища(ТокенДеталей);
						Исключение
							КэшДетали = Неопределено;
						КонецПопытки;
						
						Если КэшДетали <> Неопределено И ТипЗнч(КэшДетали) = Тип("Структура") Тогда
							Если КэшДетали.Свойство("success") И КэшДетали.success Тогда
								// Лёгкая валидация: если в data есть ПолноеИмя, сверим с запрошенным
								Попытка
									Если КэшДетали.Свойство("data")
										И ТипЗнч(КэшДетали.data) = Тип("Структура")
										И КэшДетали.data.Свойство("ПолноеИмя")
										И КэшДетали.data.ПолноеИмя <> Фильтр Тогда
										КэшДетали = Неопределено;
									КонецЕсли;
								Исключение
								КонецПопытки;
							Иначе
								КэшДетали = Неопределено;
							КонецЕсли;
						Иначе
							КэшДетали = Неопределено;
						КонецЕсли;
						
						Если КэшДетали <> Неопределено Тогда
							КэшДетали.Вставить("mcp_cache_hash", ТекущийХеш);
							КэшДетали.Вставить("mcp_cache_details_token", ТокенДеталей);
							Если ТокенДанных <> Неопределено Тогда
								КэшДетали.Вставить("mcp_cache_data_token", ТокенДанных);
							КонецЕсли;
							Возврат КэшДетали;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Получаем метаданные расширения из бинарных данных (GetData) и коллекцию из них.
		// Это даёт корректный результат и совпадает по формату с основной конфигурацией.
		РезМД = ПолучитьМетаданныеКонфигурацииРасширения(Расширение, КэшПараметры);
		Если НЕ РезМД.success Тогда
			Возврат Новый Структура("success, error", Ложь, РезМД.error);
		КонецЕсли;
		
		ТекущийХеш = РезМД.hash;
		ТокенДанных = РезМД.data_token;

		Если РезМД.is_empty Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Объект не найден в расширении (расширение пустое): " + Фильтр);
		КонецЕсли;

		МетаданныеРасширения = РезМД.metadata;
		Если МетаданныеРасширения = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь, "Не удалось получить метаданные расширения");
		КонецЕсли;

		КоллекцияВРасширении = Неопределено;
		Попытка
			КоллекцияВРасширении = Вычислить("МетаданныеРасширения." + ИмяКоллекции);
		Исключение
			КоллекцияВРасширении = Неопределено;
		КонецПопытки;

		Если КоллекцияВРасширении = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Коллекция " + ИмяКоллекции + " недоступна в метаданных расширения " + Расширение.Имя);
		КонецЕсли;

		// Ищем объект по имени
		ОбъектМД = Неопределено;
		Для Каждого ТекОбъект Из КоллекцияВРасширении Цикл
			Если ТекОбъект.Имя = ИмяОбъекта Тогда
				ОбъектМД = ТекОбъект;
				Прервать;
			КонецЕсли;
		КонецЦикла;

		Если ОбъектМД = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Объект не найден в расширении: " + Фильтр);
		КонецЕсли;

		// Навигация к элементу коллекции (если filter указывает глубже Тип.Объект)
		Если НЕ ПустаяСтрока(ОстатокПутиЭлемента) Тогда
			ЭлементМД = НайтиЭлементВКоллекцииОбъекта(ОбъектМД, ОстатокПутиЭлемента);
			Если ЭлементМД = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь,
					"Элемент не найден в расширении: " + Фильтр);
			КонецЕсли;
			Возврат ПолучитьДетальныеМетаданныеЭлементаРасширения(ЭлементМД, Фильтр, Секции, Расширение, ТекущийХеш, ТокенДанных);
		КонецЕсли;

		// Формируем детальную структуру объекта
		ИнформацияОбОбъекте = Новый Структура;
		ИнформацияОбОбъекте.Вставить("ТипОбъектаМетаданных", ТипОбъекта);
		ИнформацияОбОбъекте.Вставить("Имя", ОбъектМД.Имя);
		ИнформацияОбОбъекте.Вставить("Синоним", ОбъектМД.Синоним);
		
		ПолноеИмяФакт = Фильтр;
		Попытка
			ПолноеИмяФакт = ОбъектМД.ПолноеИмя();
		Исключение
			ПолноеИмяФакт = Фильтр;
		КонецПопытки;
		ИнформацияОбОбъекте.Вставить("ПолноеИмя", ПолноеИмяФакт);

		// Маркеры расширений: берём ТОЛЬКО из объекта метаданных расширения (ОбъектМетаданныхКонфигурация),
		// чтобы показать "Заимствованный/Собственный" в контексте расширения, а не рантайм-смёрженные метаданные.
		МеткиРасширений = ПолучитьExtensionMarksИзМетаданныхРасширения(ОбъектМД);
		Если МеткиРасширений <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("extension_marks", МеткиРасширений);
		КонецЕсли;

		// Реквизиты
		Реквизиты = Новый Массив;
		ЕстьКоллекцияРеквизитов = Ложь;

		// Стандартные реквизиты (Код, Наименование, Ссылка и т.д.)
		Попытка
			КоллекцияСтдРеквизитов = ОбъектМД.СтандартныеРеквизиты;
			ЕстьКоллекцияРеквизитов = Истина;
			Для Каждого СтдРеквизит Из КоллекцияСтдРеквизитов Цикл
				Попытка
					СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
						СтдРеквизит.Имя,
						СтдРеквизит.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип),
						Истина);

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(СтдРеквизит);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					Реквизиты.Добавить(СтрокаРеквизита);
				Исключение
					// Пропускаем проблемный стандартный реквизит
				КонецПопытки;
			КонецЦикла;
		Исключение
			// У объекта нет коллекции СтандартныеРеквизиты
		КонецПопытки;

		// Пользовательские реквизиты
		Попытка
			КоллекцияРеквизитов = ОбъектМД.Реквизиты;
			ЕстьКоллекцияРеквизитов = Истина;
			Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
					Реквизит.Имя,
					Реквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип),
					Ложь);

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;

				Реквизиты.Добавить(СтрокаРеквизита);
			КонецЦикла;
		Исключение
			// У некоторых объектов нет пользовательских реквизитов
		КонецПопытки;

		Если ЕстьКоллекцияРеквизитов Тогда
			ИнформацияОбОбъекте.Вставить("Реквизиты", Реквизиты);
		КонецЕсли;

		// Реквизиты адресации (для задач)
		Если ТипОбъекта = "Задача" Тогда
			РеквизитыАдресации = Неопределено;
			Попытка
				РеквизитыАдресации = Новый Массив;
				Для Каждого РеквизитАдресации Из ОбъектМД.РеквизитыАдресации Цикл
					СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
						РеквизитАдресации.Имя,
						РеквизитАдресации.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(РеквизитАдресации.Тип));

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(РеквизитАдресации);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					РеквизитыАдресации.Добавить(СтрокаРеквизита);
				КонецЦикла;
			Исключение
				// Секция не применима/недоступна
				РеквизитыАдресации = Неопределено;
			КонецПопытки;

			Если РеквизитыАдресации <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("РеквизитыАдресации", РеквизитыАдресации);
			КонецЕсли;
		КонецЕсли;

		// Табличные части
		Попытка
			ТабличныеЧасти = Новый Массив;
			Для Каждого ТабличнаяЧасть Из ОбъектМД.ТабличныеЧасти Цикл
				РеквизитыТЧ = Новый Массив;
				Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
					СтрокаРеквизитаТЧ = Новый Структура("Имя, Синоним, Тип",
						Реквизит.Имя,
						Реквизит.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаРеквизитаТЧ.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;
					
					РеквизитыТЧ.Добавить(СтрокаРеквизитаТЧ);
				КонецЦикла;
				
				СтрокаТЧ = Новый Структура("Имя, Синоним, Реквизиты",
					ТабличнаяЧасть.Имя,
					ТабличнаяЧасть.Синоним,
					РеквизитыТЧ);
				
				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(ТабличнаяЧасть);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаТЧ.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				ТабличныеЧасти.Добавить(СтрокаТЧ);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("ТабличныеЧасти", ТабличныеЧасти);
		Исключение
			// У некоторых объектов нет табличных частей
		КонецПопытки;

		// Измерения (для регистров)
		Попытка
			Измерения = Новый Массив;
			Для Каждого Измерение Из ОбъектМД.Измерения Цикл
				СтрокаИзмерения = Новый Структура("Имя, Синоним, Тип",
					Измерение.Имя,
					Измерение.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Измерение.Тип));

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Измерение);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаИзмерения.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				Измерения.Добавить(СтрокаИзмерения);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("Измерения", Измерения);
		Исключение
			// У некоторых объектов нет измерений
		КонецПопытки;

		// Ресурсы (для регистров)
		Попытка
			Ресурсы = Новый Массив;
			Для Каждого Ресурс Из ОбъектМД.Ресурсы Цикл
				СтрокаРесурса = Новый Структура("Имя, Синоним, Тип",
					Ресурс.Имя,
					Ресурс.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Ресурс.Тип));

				МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Ресурс);
				Если МеткиДочернего <> Неопределено Тогда
					СтрокаРесурса.Вставить("extension_marks", МеткиДочернего);
				КонецЕсли;
				
				Ресурсы.Добавить(СтрокаРесурса);
			КонецЦикла;
			ИнформацияОбОбъекте.Вставить("Ресурсы", Ресурсы);
		Исключение
			// У некоторых объектов нет ресурсов
		КонецПопытки;

		// Значения перечисления
		Если ТипОбъекта = "Перечисление" Тогда
			Попытка
				ЗначенияПеречисления = Новый Массив;
				Для Каждого ЗначениеПеречисления Из ОбъектМД.ЗначенияПеречисления Цикл
					ЗначенияПеречисления.Добавить(Новый Структура("Имя, Синоним",
						ЗначениеПеречисления.Имя,
						ЗначениеПеречисления.Синоним));
				КонецЦикла;
				ИнформацияОбОбъекте.Вставить("ЗначенияПеречисления", ЗначенияПеречисления);
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Владельцы (для подчинённых справочников)
		Если ТипОбъекта = "Справочник" Тогда
			Попытка
				Если ОбъектМД.Владельцы.Количество() > 0 Тогда
					Владельцы = Новый Массив;
					Для Каждого Владелец Из ОбъектМД.Владельцы Цикл
						Владельцы.Добавить(Владелец.ПолноеИмя());
					КонецЦикла;
					ИнформацияОбОбъекте.Вставить("Владельцы", Владельцы);
				КонецЕсли;
			Исключение
				// У некоторых справочников нет владельцев
			КонецПопытки;
		КонецЕсли;

		// ПризнакиУчета и ПризнакиУчетаСубконто (только для планов счетов)
		Если ТипОбъекта = "ПланСчетов" Тогда
			Попытка
				КоллекцияПризнаков = ОбъектМД.ПризнакиУчета;
				Если КоллекцияПризнаков <> Неопределено Тогда
					МассивПризнаков = Новый Массив;
					Для Каждого Признак Из КоллекцияПризнаков Цикл
						МассивПризнаков.Добавить(Новый Структура("Имя, Синоним, Тип",
							Признак.Имя, Признак.Синоним,
							ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
					КонецЦикла;
					Если МассивПризнаков.Количество() > 0 Тогда
						ИнформацияОбОбъекте.Вставить("ПризнакиУчета", МассивПризнаков);
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;

			Попытка
				КоллекцияПризнаковСубконто = ОбъектМД.ПризнакиУчетаСубконто;
				Если КоллекцияПризнаковСубконто <> Неопределено Тогда
					МассивПризнаковСубконто = Новый Массив;
					Для Каждого Признак Из КоллекцияПризнаковСубконто Цикл
						МассивПризнаковСубконто.Добавить(Новый Структура("Имя, Синоним, Тип",
							Признак.Имя, Признак.Синоним,
							ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
					КонецЦикла;
					Если МассивПризнаковСубконто.Количество() > 0 Тогда
						ИнформацияОбОбъекте.Вставить("ПризнакиУчетаСубконто", МассивПризнаковСубконто);
					КонецЕсли;
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// СтандартныеТабличныеЧасти (для ПланСчетов и ПланВидовРасчета)
		Если ТипОбъекта = "ПланСчетов" ИЛИ ТипОбъекта = "ПланВидовРасчета" Тогда
			Попытка
				СтандартныеТабличныеЧасти = Новый Массив;
				Для Каждого СтдТЧ Из ОбъектМД.СтандартныеТабличныеЧасти Цикл
					РеквизитыСтдТЧ = Новый Массив;
					Попытка
						Для Каждого СтдРеквизит Из СтдТЧ.СтандартныеРеквизиты Цикл
							Попытка
								РеквизитыСтдТЧ.Добавить(Новый Структура("Имя, Синоним, Тип",
									СтдРеквизит.Имя,
									СтдРеквизит.Синоним,
									ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип)));
							Исключение
							КонецПопытки;
						КонецЦикла;
					Исключение
					КонецПопытки;

					СтрокаСтдТЧ = Новый Структура("Имя, Синоним, Реквизиты",
						СтдТЧ.Имя,
						СтдТЧ.Синоним,
						РеквизитыСтдТЧ);

					МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(СтдТЧ);
					Если МеткиДочернего <> Неопределено Тогда
						СтрокаСтдТЧ.Вставить("extension_marks", МеткиДочернего);
					КонецЕсли;

					СтандартныеТабличныеЧасти.Добавить(СтрокаСтдТЧ);
				КонецЦикла;
				Если СтандартныеТабличныеЧасти.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("СтандартныеТабличныеЧасти", СтандартныеТабличныеЧасти);
				КонецЕсли;
			Исключение
			КонецПопытки;
		КонецЕсли;

		// Дополнительные секции детального ответа (управляемый "богатый" режим)
		Если СекцияЗапрошена(Секции, "properties") Тогда

			Свойства = Новый Структура;
			Кандидаты = Новый Массив;

			ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты);
			
			Для Каждого ИмяСвойства Из Кандидаты Цикл
				ЗначениеСвойства = Неопределено;
				Попытка
					ЗначениеСвойства = Вычислить("ОбъектМД." + ИмяСвойства);
				Исключение
					ЗначениеСвойства = Неопределено;
				КонецПопытки;
				
				Если ЗначениеСвойства <> Неопределено Тогда
					// Сериализация properties должна совпадать с основной конфигурацией:
					// сначала пытаемся получить ПолноеИмя() (или массив полных имён), иначе fallback.
					ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
					Если ЗначениеДляJSON = Неопределено Тогда
						ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
					КонецЕсли;
					Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
				КонецЕсли;
			КонецЦикла;
			
			ИнформацияОбОбъекте.Вставить("properties", Свойства);
			
		КонецЕсли;

		// Формы (если запрошена секция)
		Если СекцияЗапрошена(Секции, "forms") Тогда
			КоллекцияФорм = Неопределено;
			Попытка
				КоллекцияФорм = ОбъектМД.Формы;
			Исключение
				КоллекцияФорм = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияФорм <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("forms", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияФорм));
			КонецЕсли;
		КонецЕсли;

		// Команды (если запрошена секция)
		Если СекцияЗапрошена(Секции, "commands") Тогда
			КоллекцияКоманд = Неопределено;
			Попытка
				КоллекцияКоманд = ОбъектМД.Команды;
			Исключение
				КоллекцияКоманд = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияКоманд <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("commands", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияКоманд));
			КонецЕсли;
		КонецЕсли;

		// Макеты (если запрошена секция)
		Если СекцияЗапрошена(Секции, "layouts") Тогда
			КоллекцияМакетов = Неопределено;
			Попытка
				КоллекцияМакетов = ОбъектМД.Макеты;
			Исключение
				КоллекцияМакетов = Неопределено;
			КонецПопытки;
			
			// Контракт как в основной конфигурации: ключ добавляем только если коллекция реально получена.
			Если КоллекцияМакетов <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("layouts", СекцияИзКоллекцииМакетов(КоллекцияМакетов));
			КонецЕсли;
		КонецЕсли;

		Если СекцияЗапрошена(Секции, "predefined") Тогда
			
			// 1) Если в рантайм-метаданных есть коллекция предопределенных - используем ее
			КоллекцияПредопределенных = Неопределено;
			Попытка
				КоллекцияПредопределенных = ОбъектМД.Предопределенные;
			Исключение
				КоллекцияПредопределенных = Неопределено;
			КонецПопытки;
			
			Если КоллекцияПредопределенных <> Неопределено Тогда
				Попытка
					ИнформацияОбОбъекте.Вставить("predefined", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияПредопределенных));
				Исключение
					// Если это не коллекция - игнорируем и пробуем fallback ниже
				КонецПопытки;
			КонецЕсли;
			
			// 2) Fallback для справочников: предопределенные данные хранятся как данные (отбор по Предопределенный)
			Если Не ИнформацияОбОбъекте.Свойство("predefined") И ТипОбъекта = "Справочник" Тогда
				ПредопределенныеДанные = ПолучитьПредопределенныеЭлементыСправочника(ИмяОбъекта, 200);
				Если ПредопределенныеДанные <> Неопределено Тогда
					ИнформацияОбОбъекте.Вставить("predefined", ПредопределенныеДанные);
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;

		// Движения (только для документов — список регистров, в которых документ делает движения)
		Если СекцияЗапрошена(Секции, "movements") Тогда
			Если ТипОбъекта = "Документ" Тогда
				КоллекцияДвижений = Неопределено;
				Попытка
					КоллекцияДвижений = ОбъектМД.Движения;
				Исключение
					КоллекцияДвижений = Неопределено;
				КонецПопытки;

				Если КоллекцияДвижений <> Неопределено Тогда
					ИнформацияОбОбъекте.Вставить("movements", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияДвижений));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		// Характеристики (описания характеристик, привязанных к объекту метаданных)
		Если СекцияЗапрошена(Секции, "characteristics") Тогда
			КоллекцияХарактеристик = Неопределено;
			Попытка
				КоллекцияХарактеристик = ОбъектМД.Характеристики;
			Исключение
				КоллекцияХарактеристик = Неопределено;
			КонецПопытки;

			Если КоллекцияХарактеристик <> Неопределено Тогда
				МассивХарактеристик = Новый Массив;
				Для Каждого ОписаниеХарактеристики Из КоллекцияХарактеристик Цикл
					ЭлементХарактеристики = Новый Структура;

					// ВидыХарактеристик — ссылка на ПланВидовХарактеристик → ПолноеИмя()
					Попытка
						ВидыХар = ОписаниеХарактеристики.ВидыХарактеристик;
						Если ВидыХар <> Неопределено Тогда
							Попытка
								ЭлементХарактеристики.Вставить("ВидыХарактеристик", ВидыХар.ПолноеИмя());
							Исключение
								ЭлементХарактеристики.Вставить("ВидыХарактеристик", Строка(ВидыХар));
							КонецПопытки;
						КонецЕсли;
					Исключение
					КонецПопытки;

					// ЗначенияХарактеристик — ссылка на регистр сведений → ПолноеИмя()
					Попытка
						ЗначенияХар = ОписаниеХарактеристики.ЗначенияХарактеристик;
						Если ЗначенияХар <> Неопределено Тогда
							Попытка
								ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", ЗначенияХар.ПолноеИмя());
							Исключение
								ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", Строка(ЗначенияХар));
							КонецПопытки;
						КонецЕсли;
					Исключение
					КонецПопытки;

					// ЗначениеОтбораВидов — произвольный тип
					Попытка
						ЗначениеОтбора = ОписаниеХарактеристики.ЗначениеОтбораВидов;
						Если ЗначениеОтбора <> Неопределено Тогда
							ЭлементХарактеристики.Вставить("ЗначениеОтбораВидов",
								БезопасноеЗначениеДляПередачи(ЗначениеОтбора));
						КонецЕсли;
					Исключение
					КонецПопытки;

					// Поля (строковые свойства) — через Вычислить с безопасным доступом
					ПоляСтроковые = Новый Структура;
					ПоляСтроковые.Вставить("ПолеВида",                                "ПолеВида");
					ПоляСтроковые.Вставить("ПолеЗначения",                            "ПолеЗначения");
					ПоляСтроковые.Вставить("ПолеИспользованияМножественныхЗначений",  "ПолеИспользованияМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеКлюча",                               "ПолеКлюча");
					ПоляСтроковые.Вставить("ПолеКлючаМножественныхЗначений",          "ПолеКлючаМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеОбъекта",                             "ПолеОбъекта");
					ПоляСтроковые.Вставить("ПолеОтбораВидов",                         "ПолеОтбораВидов");
					ПоляСтроковые.Вставить("ПолеПорядкаМножественныхЗначений",        "ПолеПорядкаМножественныхЗначений");
					ПоляСтроковые.Вставить("ПолеПутиКДанным",                         "ПолеПутиКДанным");

					Для Каждого КлючЗначение Из ПоляСтроковые Цикл
						Попытка
							ЗначениеПоля = Вычислить("ОписаниеХарактеристики." + КлючЗначение.Значение);
							Если ЗначениеПоля <> Неопределено И Не ПустаяСтрока(Строка(ЗначениеПоля)) Тогда
								ЭлементХарактеристики.Вставить(КлючЗначение.Ключ, Строка(ЗначениеПоля));
							КонецЕсли;
						Исключение
						КонецПопытки;
					КонецЦикла;

					// Пропускаем пустые элементы (все поля = Неопределено/пустые)
					Если ЭлементХарактеристики.Количество() > 0 Тогда
						МассивХарактеристик.Добавить(ЭлементХарактеристики);
					КонецЕсли;
				КонецЦикла;

				Если МассивХарактеристик.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("characteristics", МассивХарактеристик);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Результат = Новый Структура;
		Результат.Вставить("success", Истина);
		Результат.Вставить("data", ИнформацияОбОбъекте);
		Результат.Вставить("extension", Расширение.Имя);
		
		// Кэшируем готовый details-ответ (best effort) и возвращаем токен для клиентского кэша
		ТокенДеталей = Неопределено;
		Попытка
			ТокенДеталей = ПоместитьВоВременноеХранилище(Результат);
		Исключение
			ТокенДеталей = Неопределено;
		КонецПопытки;
		
		Результат.Вставить("mcp_cache_hash", ТекущийХеш);
		Если ТокенДанных <> Неопределено Тогда
			Результат.Вставить("mcp_cache_data_token", ТокенДанных);
		КонецЕсли;
		Если ТокенДеталей <> Неопределено Тогда
			Результат.Вставить("mcp_cache_details_token", ТокенДеталей);
		КонецЕсли;

		Возврат Результат;

	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеЭлементаРасширения(ОбъектМетаданных, ПолноеИмяФильтра, Секции, Расширение, ТекущийХеш, ТокенДанных)

	ИнформацияОбЭлементе = Новый Структура;
	ИнформацияОбЭлементе.Вставить("ПолноеИмя", ПолноеИмяФильтра);
	ИнформацияОбЭлементе.Вставить("Имя", ОбъектМетаданных.Имя);

	Попытка
		ИнформацияОбЭлементе.Вставить("Синоним", ОбъектМетаданных.Синоним);
	Исключение
	КонецПопытки;

	// Тип (описание типов) — есть у реквизитов, измерений, ресурсов
	Попытка
		ИнформацияОбЭлементе.Вставить("Тип",
			ПолучитьСтроковоеПредставлениеОписанияТипов(ОбъектМетаданных.Тип));
	Исключение
		// У некоторых элементов (ТабличнаяЧасть) нет свойства Тип
	КонецПопытки;

	// Для табличных частей — вернуть список реквизитов
	Попытка
		РеквизитыТЧ = Новый Массив;
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

			МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(Реквизит);
			Если МеткиДочернего <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиДочернего);
			КонецЕсли;

			РеквизитыТЧ.Добавить(СтрокаРеквизита);
		КонецЦикла;
		ИнформацияОбЭлементе.Вставить("Реквизиты", РеквизитыТЧ);
	Исключение
		// Нет коллекции реквизитов (не ТабличнаяЧасть)
	КонецПопытки;

	// Extension marks
	МеткиДочернего = ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(ОбъектМетаданных);
	Если МеткиДочернего <> Неопределено Тогда
		ИнформацияОбЭлементе.Вставить("extension_marks", МеткиДочернего);
	КонецЕсли;

	// Properties — расширенные свойства элемента
	Если СекцияЗапрошена(Секции, "properties") Тогда
		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты);

		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
			КонецПопытки;
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;

		ИнформацияОбЭлементе.Вставить("properties", Свойства);
	КонецЕсли;

	Результат = Новый Структура;
	Результат.Вставить("success", Истина);
	Результат.Вставить("data", ИнформацияОбЭлементе);
	Результат.Вставить("extension", Расширение.Имя);

	// Кэшируем (best effort)
	ТокенДеталей = Неопределено;
	Попытка
		ТокенДеталей = ПоместитьВоВременноеХранилище(Результат);
	Исключение
	КонецПопытки;

	Результат.Вставить("mcp_cache_hash", ТекущийХеш);
	Если ТокенДанных <> Неопределено Тогда
		Результат.Вставить("mcp_cache_data_token", ТокенДанных);
	КонецЕсли;
	Если ТокенДеталей <> Неопределено Тогда
		Результат.Вставить("mcp_cache_details_token", ТокенДеталей);
	КонецЕсли;

	Возврат Результат;

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьКорневыеТипыМетаданных()
	
	// Список корневых типов метаданных (как в дереве конфигуратора).
	// Формат: Массив структур {Тип, Коллекция}, где Коллекция - имя свойства Метаданные.<Коллекция>.
	Типы = Новый Массив;
	
	// Общие
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Подсистема", "Подсистемы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийМодуль", "ОбщиеМодули"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПараметрСеанса", "ПараметрыСеанса"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Роль", "Роли"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийРеквизит", "ОбщиеРеквизиты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланОбмена", "ПланыОбмена"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "КритерийОтбора", "КритерииОтбора"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПодпискаНаСобытие", "ПодпискиНаСобытия"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегламентноеЗадание", "РегламентныеЗадания"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Бот", "Боты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ФункциональнаяОпция", "ФункциональныеОпции"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПараметрФункциональныхОпций", "ПараметрыФункциональныхОпций"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОпределяемыйТип", "ОпределяемыеТипы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ХранилищеНастроек", "ХранилищаНастроек"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяКоманда", "ОбщиеКоманды"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ГруппаКоманд", "ГруппыКоманд"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяФорма", "ОбщиеФормы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщийМакет", "ОбщиеМакеты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ОбщаяКартинка", "ОбщиеКартинки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WebСервис", "WebСервисы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "HTTPСервис", "HTTPСервисы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WSСсылка", "WSСсылки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "WebSocketКлиент", "WebSocketКлиенты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "СервисИнтеграции", "СервисыИнтеграции"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ЭлементСтиля", "ЭлементыСтиля"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Стиль", "Стили"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Язык", "Языки"));
	
	// Прикладные
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Константа", "Константы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Справочник", "Справочники"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Документ", "Документы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ЖурналДокументов", "ЖурналыДокументов"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Перечисление", "Перечисления"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Отчет", "Отчеты"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Обработка", "Обработки"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланВидовХарактеристик", "ПланыВидовХарактеристик"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланСчетов", "ПланыСчетов"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПланВидовРасчета", "ПланыВидовРасчета"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрСведений", "РегистрыСведений"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрНакопления", "РегистрыНакопления"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрБухгалтерии", "РегистрыБухгалтерии"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "РегистрРасчета", "РегистрыРасчета"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "БизнесПроцесс", "БизнесПроцессы"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "Задача", "Задачи"));
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ВнешнийИсточникДанных", "ВнешниеИсточникиДанных"));
	
	// Пользовательский тип (фиксируем по договорённости)
	Типы.Добавить(Новый Структура("Тип, Коллекция", "ПакетыXDTO", "ПакетыXDTO"));
	
	Возврат Типы;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСводкуМетаданных()
	
	Типы = ПолучитьКорневыеТипыМетаданных();
	Сводка = Новый Массив;
	
	Для Каждого ОписаниеТипа Из Типы Цикл
		
		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
		Количество = 0;
		Если Коллекция <> Неопределено Тогда
			Попытка
				Количество = Коллекция.Количество();
			Исключение
				Количество = 0;
			КонецПопытки;
		КонецЕсли;
		
		Сводка.Добавить(Новый Структура("Тип, Количество", ОписаниеТипа.Тип, Количество));
		
	КонецЦикла;
	
	ИнформацияОКонфигурации = ПолучитьИнформациюОКонфигурации();
	// Важно: data оставляем массивом (roots), чтобы в TOON-формате оставался табличный вывод.
	// Информацию о конфигурации возвращаем отдельным полем верхнего уровня.
	Возврат Новый Структура("success, data, configuration", Истина, Сводка, ИнформацияОКонфигурации);
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, Ключ)
	
	Если СтрокаСоединения = Неопределено Или ПустаяСтрока(СтрокаСоединения) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Пары = РазделитьСтрокуПоРазделителю(СтрокаСоединения, ";");
	
	Для Каждого Пара Из Пары Цикл
		
		Если ПустаяСтрока(Пара) Тогда
			Продолжить;
		КонецЕсли;
		
		ПозицияРавно = Найти(Пара, "=");
		Если ПозицияРавно <= 0 Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПараметра = СокрЛП(Лев(Пара, ПозицияРавно - 1));
		Если ИмяПараметра <> Ключ Тогда
			Продолжить;
		КонецЕсли;
		
		Значение = СокрЛП(Сред(Пара, ПозицияРавно + 1));
		
		// Убираем кавычки по краям, если есть
		Если СтрДлина(Значение) >= 2 Тогда
			Если Лев(Значение, 1) = Символ(34) И Прав(Значение, 1) = Символ(34) Тогда
				Значение = Сред(Значение, 2, СтрДлина(Значение) - 2);
			КонецЕсли;
		КонецЕсли;
		
		Если ПустаяСтрока(Значение) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Значение;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяИБПоСтрокеСоединения(СтрокаСоединения)
	
	// Серверная ИБ: Srvr="...";Ref="MyBase";
	ИмяИБ = ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, "Ref");
	Если ИмяИБ <> Неопределено Тогда
		Возврат ИмяИБ;
	КонецЕсли;
	
	// Файловая ИБ: File="D:\Bases\MyBase";
	ПутьИБ = ПолучитьЗначениеПараметраСтрокиСоединения(СтрокаСоединения, "File");
	Если ПутьИБ = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Возвращаем только последний сегмент пути (без раскрытия полного пути)
	РазделительПути = Символ(92); // обратный слеш
	ПутьИБ = СтрЗаменить(ПутьИБ, "/", РазделительПути);
	
	ПозицияПоследняя = 0;
	
	// В режиме совместимости 8.2 третий параметр Найти() может быть недоступен,
	// поэтому ищем последний разделитель простым проходом по строке.
	ДлинаПути = СтрДлина(ПутьИБ);
	Для Индекс = 1 По ДлинаПути Цикл
		Если Сред(ПутьИБ, Индекс, 1) = РазделительПути Тогда
			ПозицияПоследняя = Индекс;
		КонецЕсли;
	КонецЦикла;
	
	Если ПозицияПоследняя > 0 И ПозицияПоследняя < СтрДлина(ПутьИБ) Тогда
		ИмяИБ = Сред(ПутьИБ, ПозицияПоследняя + 1);
	Иначе
		ИмяИБ = ПутьИБ;
	КонецЕсли;
	
	Если ПустаяСтрока(ИмяИБ) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ИмяИБ;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИнформациюОКонфигурации()
	
	Инфо = Новый Структура;
	
	// Версия платформы (очень полезно для диагностики)
	Попытка
		СисИнфо = Новый СистемнаяИнформация;
		Если СисИнфо <> Неопределено Тогда
			ВерсияПлатформы = СисИнфо.ВерсияПриложения;
			Если ВерсияПлатформы <> Неопределено И Не ПустаяСтрока(ВерсияПлатформы) Тогда
				Инфо.Вставить("platform_version", БезопасноеЗначениеДляПередачи(Строка(ВерсияПлатформы)));
			КонецЕсли;
		КонецЕсли;
	Исключение
		// нет
	КонецПопытки;
	
	// Имя ИБ (часто полезно как контекст; без путей/адресов)
	Попытка
		СтрСоед = Вычислить("СтрокаСоединенияИнформационнойБазы()");
		Если СтрСоед <> Неопределено И Не ПустаяСтрока(СтрСоед) Тогда
			ИмяИБ = ПолучитьИмяИБПоСтрокеСоединения(СтрСоед);
			Если ИмяИБ <> Неопределено И Не ПустаяСтрока(ИмяИБ) Тогда
				Инфо.Вставить("infobase_name", БезопасноеЗначениеДляПередачи(ИмяИБ));
			КонецЕсли;
		КонецЕсли;
	Исключение
		// нет
	КонецПопытки;
	
	// Пытаемся получить объект метаданных конфигурации (если доступен)
	ОбъектКонфигурации = Неопределено;
	Попытка
		ОбъектКонфигурации = Метаданные.Конфигурация;
	Исключение
		ОбъектКонфигурации = Неопределено;
	КонецПопытки;
	
	Если ОбъектКонфигурации = Неопределено Тогда
		// На некоторых версиях/режимах может быть доступен только корневой объект Метаданные
		ОбъектКонфигурации = Метаданные;
	КонецЕсли;
	
	Свойства = Новый Структура;
	Кандидаты = Новый Массив;
	
	// Базовые/ожидаемые свойства конфигурации (если доступны в рантайме)
	Кандидаты.Добавить("Имя");
	Кандидаты.Добавить("Синоним");
	Кандидаты.Добавить("Комментарий");
	Кандидаты.Добавить("Поставщик");
	Кандидаты.Добавить("Версия");
	Кандидаты.Добавить("ВерсияКонфигурации");	
	Кандидаты.Добавить("ОсновнойЯзык");
	Кандидаты.Добавить("ОсновнойРежимЗапуска");
	Кандидаты.Добавить("РежимСовместимости");
	Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	Кандидаты.Добавить("РежимСовместимостиИнтерфейса");
	Кандидаты.Добавить("РежимИспользованияМодальности");
	Кандидаты.Добавить("РежимАвтонумерацииОбъектов");	
	Кандидаты.Добавить("РежимИспользованияБлочногоХраненияДвоичныхДанных");
	Кандидаты.Добавить("РежимИспользованияТабличныхПространствБазыДанных");
	Кандидаты.Добавить("ИспользоватьОбычныеФормыВУправляемомПриложении");
	Кандидаты.Добавить("ИспользоватьУправляемыеФормыВОбычномПриложении");

	Для Каждого ИмяСвойства Из Кандидаты Цикл
		ЗначениеСвойства = Неопределено;
		Попытка
			ЗначениеСвойства = Вычислить("ОбъектКонфигурации." + ИмяСвойства);
		Исключение
			ЗначениеСвойства = Неопределено;
		КонецПопытки;
		
		Если ЗначениеСвойства <> Неопределено Тогда
			Свойства.Вставить(ИмяСвойства, БезопасноеЗначениеДляПередачи(ЗначениеСвойства));
		КонецЕсли;
	КонецЦикла;
	
	Если Свойства.Количество() > 0 Тогда
		Инфо.Вставить("metadata", Свойства);
	КонецЕсли;
	
	Возврат Инфо;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСписокМетаданных(ТипМетаданных = "", МаскаИмени = "", Лимит = 100, Смещение = 0)
	
	// ТипМетаданных может быть строкой ("Документ", "*") или массивом строк (["Документ","РегистрСведений"])
	Типы = ПолучитьКорневыеТипыМетаданных();
	ТипыДляОбхода = Новый Массив;
	
	ТипТипМетаданных = ТипЗнч(ТипМетаданных);
	
	Если ТипМетаданных = Неопределено Или (ТипТипМетаданных = Тип("Строка") И ПустаяСтрока(ТипМетаданных)) Тогда
		ТипМетаданных = "*";
		ТипТипМетаданных = Тип("Строка");
	КонецЕсли;
	
	Если ТипТипМетаданных = Тип("Строка") Тогда
		
		Если ТипМетаданных = "*" Тогда
			ТипыДляОбхода = Типы;
		Иначе
			ОписаниеЗапрошенногоТипа = Неопределено;
			Для Каждого ОписаниеТипа Из Типы Цикл
				Если ОписаниеТипа.Тип = ТипМетаданных Тогда
					ОписаниеЗапрошенногоТипа = ОписаниеТипа;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
				Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ТипМетаданных);
			КонецЕсли;
			
			ТипыДляОбхода.Добавить(ОписаниеЗапрошенногоТипа);
		КонецЕсли;
		
	Иначе
		
		// Массив типов
		ЗапрошеныВсеТипы = Ложь;
		Уникальные = Новый Соответствие;
		
		Попытка
			Для Каждого ИмяТипа Из ТипМетаданных Цикл
				ИмяТипа = СокрЛП(Строка(ИмяТипа));
				Если ПустаяСтрока(ИмяТипа) Тогда
					Продолжить;
				КонецЕсли;
				Если ИмяТипа = "*" Тогда
					ЗапрошеныВсеТипы = Истина;
					Прервать;
				КонецЕсли;
				Уникальные.Вставить(ИмяТипа, Истина);
			КонецЦикла;
		Исключение
			Возврат Новый Структура("success, error", Ложь, "Некорректный формат meta_type (ожидается строка или массив строк)");
		КонецПопытки;
		
		Если ЗапрошеныВсеТипы Тогда
			ТипыДляОбхода = Типы;
		Иначе
			Для Каждого Пара Из Уникальные Цикл
				ИмяТипа = Пара.Ключ;
				ОписаниеЗапрошенногоТипа = Неопределено;
				Для Каждого ОписаниеТипа Из Типы Цикл
					Если ОписаниеТипа.Тип = ИмяТипа Тогда
						ОписаниеЗапрошенногоТипа = ОписаниеТипа;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если ОписаниеЗапрошенногоТипа = Неопределено Тогда
					Возврат Новый Структура("success, error", Ложь, "Неизвестный тип метаданных: " + ИмяТипа);
				КонецЕсли;
				
				ТипыДляОбхода.Добавить(ОписаниеЗапрошенногоТипа);
			КонецЦикла;
		КонецЕсли;
		
	КонецЕсли;
	
	// Собираем все совпадения, сортируем по ПолноеИмя и делаем срез offset+limit
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("ПолноеИмя");
	Таблица.Колонки.Добавить("Синоним");
	Таблица.Колонки.Добавить("SortKey");
	
	МаскаВерхнийРегистр = "";
	Если МаскаИмени <> Неопределено Тогда
		Попытка
			МаскаВерхнийРегистр = ВРег(МаскаИмени);
		Исключение
			МаскаВерхнийРегистр = "";
		КонецПопытки;
	КонецЕсли;
	
	Для Каждого ОписаниеТипа Из ТипыДляОбхода Цикл
		
		Коллекция = Неопределено;
		Попытка
			Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
		Если Коллекция = Неопределено Тогда
			// В режиме "*" пропускаем недоступные коллекции, иначе считаем ошибкой (тип явно запросили)
			Если (ТипТипМетаданных = Тип("Строка") И ТипМетаданных = "*") Тогда
				Продолжить;
			Иначе
				Возврат Новый Структура("success, error", Ложь,
					"Коллекция метаданных не найдена/недоступна: Метаданные." + ОписаниеТипа.Коллекция);
			КонецЕсли;
		КонецЕсли;
		
		Для Каждого ОбъектМетаданных Из Коллекция Цикл
			
			Имя = "";
			Синоним = "";
			ПолноеИмя = "";
			
			Попытка
				Имя = ОбъектМетаданных.Имя;
			Исключение
				Имя = "";
			КонецПопытки;
			
			Попытка
				Синоним = ОбъектМетаданных.Синоним;
			Исключение
				Синоним = "";
			КонецПопытки;
			
			Если ПрошелФильтрПоМаске(Имя, Синоним, МаскаВерхнийРегистр) Тогда
				
				Попытка
					ПолноеИмя = ОбъектМетаданных.ПолноеИмя();
				Исключение
					ПолноеИмя = "";
				КонецПопытки;
				
				Если ПустаяСтрока(ПолноеИмя) Тогда
					Если Не ПустаяСтрока(Имя) Тогда
						ПолноеИмя = ОписаниеТипа.Тип + "." + Имя;
					Иначе
						ПолноеИмя = ОписаниеТипа.Тип;
					КонецЕсли;
				КонецЕсли;
				
				Стр = Таблица.Добавить();
				Стр.ПолноеИмя = ПолноеИмя;
				Стр.Синоним = Синоним;
				Стр.SortKey = ВРег(ПолноеИмя);
				
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	Таблица.Сортировать("SortKey, ПолноеИмя");
	
	Всего = Таблица.Количество();
	Если Смещение < 0 Тогда
		Смещение = 0;
	КонецЕсли;
	
	СписокОбъектов = Новый Массив;
	Возвращено = 0;
	
	Если Смещение < Всего Тогда
		ИндексПоследний = Мин(Смещение + Лимит - 1, Всего - 1);
		Для Индекс = Смещение По ИндексПоследний Цикл
			СтрокаТаблицы = Таблица.Получить(Индекс);
			СписокОбъектов.Добавить(Новый Структура("ПолноеИмя, Синоним", СтрокаТаблицы.ПолноеИмя, СтрокаТаблицы.Синоним));
			Возвращено = Возвращено + 1;
		КонецЦикла;
	КонецЕсли;
	
	ЕстьЕще = (Смещение + Возвращено) < Всего;
	СледующееСмещение = Смещение + Возвращено;
	
	Возврат Новый Структура("success, data, truncated, limit, returned, count, offset, has_more, next_offset",
		Истина,
		СписокОбъектов,
		ЕстьЕще,
		Лимит,
		Возвращено,
		Всего,
		Смещение,
		ЕстьЕще,
		СледующееСмещение);
	
КонецФункции

&НаСервереБезКонтекста
Функция ПрошелФильтрПоМаске(Имя, Синоним, МаскаВерхнийРегистр)
	
	Если ПустаяСтрока(МаскаВерхнийРегистр) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Найти(ВРег(Имя), МаскаВерхнийРегистр) > 0 
		Или Найти(ВРег(Синоним), МаскаВерхнийРегистр) > 0;
	
КонецФункции


&НаСервереБезКонтекста
Функция СекцияЗапрошена(Секции, ИмяСекции)
	
	Если Секции = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Для Каждого Секция Из Секции Цикл
			Если ВРег(Строка(Секция)) = ВРег(ИмяСекции) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;
	Исключение
		// Некорректный формат sections
	КонецПопытки;
	
	Возврат Ложь;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолноеИмяМетаданныхЕслиВозможно(Значение, Глубина = 0)
	
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Глубина > 5 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Универсальный способ: пробуем метод ПолноеИмя() (для MetadataObject/ОбъектМетаданных).
	// Если метода нет или он недоступен — вернём Неопределено, и дальше будет fallback через БезопасноеЗначениеДляПередачи().
	ПолноеИмя = "";
	Попытка
		ПолноеИмя = Значение.ПолноеИмя();
	Исключение
		ПолноеИмя = "";
	КонецПопытки;
	
	Если НЕ ПустаяСтрока(ПолноеИмя) Тогда
		Возврат ПолноеИмя;
	КонецЕсли;

	// Если это коллекция (в т.ч. коллекция метаданных), попробуем обойти её и собрать ПолныеИмёна элементов.
	МассивПолныхИмен = Новый Массив;
	Попытка
		Для Каждого ЭлементКоллекции Из Значение Цикл
			ЗначениеЭлемента = ПолноеИмяМетаданныхЕслиВозможно(ЭлементКоллекции, Глубина + 1);
			Если ЗначениеЭлемента = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если ТипЗнч(ЗначениеЭлемента) = Тип("Массив") Тогда
				Для Каждого ЭлементМассива Из ЗначениеЭлемента Цикл
					Если ЭлементМассива <> Неопределено И НЕ ПустаяСтрока(Строка(ЭлементМассива)) Тогда
						МассивПолныхИмен.Добавить(ЭлементМассива);
					КонецЕсли;
				КонецЦикла;
			Иначе
				Если НЕ ПустаяСтрока(Строка(ЗначениеЭлемента)) Тогда
					МассивПолныхИмен.Добавить(ЗначениеЭлемента);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	Исключение
		МассивПолныхИмен = Неопределено;
	КонецПопытки;
	
	Если МассивПолныхИмен <> Неопределено И МассивПолныхИмен.Количество() > 0 Тогда
		Возврат МассивПолныхИмен;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции


&НаСервереБезКонтекста
Процедура ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты)

	// Общие свойства (подставляются где доступны)
	Кандидаты.Добавить("Комментарий");

	Если ТипОбъекта = "ПодпискаНаСобытие" Тогда
		Кандидаты.Добавить("Источник");
		Кандидаты.Добавить("Обработчик");
		Кандидаты.Добавить("Событие");
	ИначеЕсли ТипОбъекта = "БизнесПроцесс" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("Задача");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ПривилегированныйРежимПриСозданииЗадач");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "Задача" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("АвтоПрефиксНомераЗадачи");
		Кандидаты.Добавить("Адресация");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ОсновнойРеквизитАдресации");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "Справочник" Тогда
		Кандидаты.Добавить("Иерархический");
		Кандидаты.Добавить("ВидИерархии");
		Кандидаты.Добавить("ИспользованиеПодчинения");
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ТипКода");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ИсторияДанных");
	ИначеЕсли ТипОбъекта = "Документ" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ТипНомера");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("Нумератор");
		Кандидаты.Добавить("Нумерация");
		Кандидаты.Добавить("ОперативноеПроведение");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ПривилегированныйРежимПриОтменеПроведения");
		Кандидаты.Добавить("ПривилегированныйРежимПриПроведении");
		Кандидаты.Добавить("Проведение");
		Кандидаты.Добавить("УдалениеДвижений");
		Кандидаты.Добавить("ЗаполнениеПоследовательностей");
		Кандидаты.Добавить("ЗаписьДвиженийПриПроведении");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ИсторияДанных");
	ИначеЕсли ТипОбъекта = "РегистрСведений" Тогда
		Кандидаты.Добавить("Периодичность");
		Кандидаты.Добавить("РежимЗаписи");
		Кандидаты.Добавить("ПериодичностьРегистраСведений");
		Кандидаты.Добавить("ОсновнойОтборПоПериоду");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("РазрешитьИтогиСрезПервых");
		Кандидаты.Добавить("РазрешитьИтогиСрезПоследних");
	ИначеЕсли ТипОбъекта = "РегистрНакопления" Тогда
		Кандидаты.Добавить("ВидРегистра");
		Кандидаты.Добавить("РазрешитьРазделениеИтогов");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "РегистрБухгалтерии" Тогда
		Кандидаты.Добавить("ПланСчетов");
		Кандидаты.Добавить("ДлинаУточненияПериода");
		Кандидаты.Добавить("Корреспонденция");
		Кандидаты.Добавить("РазрешитьРазделениеИтогов");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "ПланСчетов" Тогда
		Кандидаты.Добавить("АвтоПорядокПоКоду");
		Кандидаты.Добавить("ВидыСубконто");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ТипКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДлинаПорядка");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("МаксКоличествоСубконто");
		Кандидаты.Добавить("МаскаКода");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СерииКодов");
	ИначеЕсли ТипОбъекта = "РегистрРасчета" Тогда
		Кандидаты.Добавить("Периодичность");
		Кандидаты.Добавить("БазовыйПериод");
		Кандидаты.Добавить("График");
		Кандидаты.Добавить("ДатаГрафика");
		Кандидаты.Добавить("ЗначениеГрафика");
		Кандидаты.Добавить("ПериодДействия");
		Кандидаты.Добавить("ПланВидовРасчета");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
	ИначеЕсли ТипОбъекта = "ГруппаКоманд" Тогда
		Кандидаты.Добавить("Категория");
	ИначеЕсли ТипОбъекта = "ЖурналДокументов" Тогда
		Кандидаты.Добавить("Графы");
		Кандидаты.Добавить("РегистрируемыеДокументы");
	ИначеЕсли ТипОбъекта = "Константа" Тогда
		Кандидаты.Добавить("ВыделятьОтрицательные");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("Маска");
		Кандидаты.Добавить("МногострочныйРежим");
		Кандидаты.Добавить("ПараметрыВыбора");
		Кандидаты.Добавить("ПроверкаЗаполнения");
		Кандидаты.Добавить("РежимПароля");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СвязиПараметровВыбора");
		Кандидаты.Добавить("СвязьПоТипу");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "КритерийОтбора" Тогда
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "Нумератор" Тогда
		Кандидаты.Добавить("ДлинаНомера");
		Кандидаты.Добавить("ДопустимаяДлинаНомера");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("ПериодичностьНомера");
		Кандидаты.Добавить("ТипНомера");
	ИначеЕсли ТипОбъекта = "ОбщаяКоманда" Тогда
		Кандидаты.Добавить("Группа");
		Кандидаты.Добавить("ИзменяетДанные");
		Кандидаты.Добавить("Отображение");
		Кандидаты.Добавить("РежимИспользованияПараметра");
		Кандидаты.Добавить("ТипПараметраКоманды");
	ИначеЕсли ТипОбъекта = "ОбщийМодуль" Тогда
		Кандидаты.Добавить("ВнешнееСоединение");
		Кандидаты.Добавить("ВызовСервер");
		Кандидаты.Добавить("Глобальный");
		Кандидаты.Добавить("КлиентОбычноеПриложение");
		Кандидаты.Добавить("КлиентУправляемоеПриложение");
		Кандидаты.Добавить("ПовторноеИспользованиеВозвращаемыхЗначений");
		Кандидаты.Добавить("Привилегированный");
		Кандидаты.Добавить("Сервер");
	ИначеЕсли ТипОбъекта = "ОбщийРеквизит" Тогда
		Кандидаты.Добавить("АвтоИспользование");
		Кандидаты.Добавить("ВыделятьОтрицательные");
		Кандидаты.Добавить("ЗаполнятьИзДанныхЗаполнения");
		Кандидаты.Добавить("ЗначениеРазделенияДанных");
		Кандидаты.Добавить("ИспользованиеРазделенияДанных");
		Кандидаты.Добавить("ИспользованиеРазделяемыхДанных");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("Маска");
		Кандидаты.Добавить("МногострочныйРежим");
		Кандидаты.Добавить("ПроверкаЗаполнения");
		Кандидаты.Добавить("РазделениеАутентификации");
		Кандидаты.Добавить("РазделениеДанных");
		Кандидаты.Добавить("РазделениеПользователей");
		Кандидаты.Добавить("РазделениеРасширенийКонфигурации");
		Кандидаты.Добавить("РежимПароля");
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Тип");
		Кандидаты.Добавить("УсловноеРазделение");
	ИначеЕсли ТипОбъекта = "ОпределяемыйТип" Тогда
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "Отчет" Тогда
		Кандидаты.Добавить("ОсновнаяСхемаКомпоновкиДанных");
		Кандидаты.Добавить("ХранилищеВариантов");
		Кандидаты.Добавить("ХранилищеНастроек");
	ИначеЕсли ТипОбъекта = "ПараметрФункциональныхОпций" Тогда
		Кандидаты.Добавить("Использование");
	ИначеЕсли ТипОбъекта = "ПланВидовРасчета" Тогда
		Кандидаты.Добавить("БазовыеВидыРасчета");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("ЗависимостьОтВидовРасчета");
		Кандидаты.Добавить("ИспользованиеПериодаДействия");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("ТипКода");
	ИначеЕсли ТипОбъекта = "ПланВидовХарактеристик" Тогда
		Кандидаты.Добавить("Автонумерация");
		Кандидаты.Добавить("ГруппыСверху");
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("Иерархический");
		Кандидаты.Добавить("КонтрольУникальности");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("СерииКодов");
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "ПланОбмена" Тогда
		Кандидаты.Добавить("ДлинаКода");
		Кандидаты.Добавить("ДлинаНаименования");
		Кандидаты.Добавить("ДопустимаяДлинаКода");
		Кандидаты.Добавить("ИсторияДанных");
		Кандидаты.Добавить("РежимУправленияБлокировкойДанных");
		Кандидаты.Добавить("Состав");
	ИначеЕсли ТипОбъекта = "Подсистема" Тогда
		Кандидаты.Добавить("ВключатьВКомандныйИнтерфейс");
		Кандидаты.Добавить("ИспользоватьОднуКоманду");
		Кандидаты.Добавить("Подсистемы");
		Кандидаты.Добавить("Состав");
	ИначеЕсли ТипОбъекта = "Последовательность" Тогда
		Кандидаты.Добавить("Движения");
		Кандидаты.Добавить("Документы");
		Кандидаты.Добавить("ПеремещениеГраницыПриПроведении");
	ИначеЕсли ТипОбъекта = "РегламентноеЗадание" Тогда
		Кандидаты.Добавить("ИмяМетода");
		Кандидаты.Добавить("ИнтервалПовтораПриАварийномЗавершении");
		Кандидаты.Добавить("Использование");
		Кандидаты.Добавить("Ключ");
		Кандидаты.Добавить("КоличествоПовторовПриАварийномЗавершении");
		Кандидаты.Добавить("Наименование");
		Кандидаты.Добавить("Предопределенное");
	ИначеЕсли ТипОбъекта = "ФункциональнаяОпция" Тогда
		Кандидаты.Добавить("ПривилегированныйРежимПриПолучении");
		Кандидаты.Добавить("Состав");
		Кандидаты.Добавить("Хранение");
	ИначеЕсли ТипОбъекта = "ОбщийМакет" Тогда
		Кандидаты.Добавить("Тип");
	ИначеЕсли ТипОбъекта = "HTTPСервис" Тогда
		Кандидаты.Добавить("ВремяЖизниСеанса");
		Кандидаты.Добавить("КорневойURL");
		Кандидаты.Добавить("ПовторноеИспользованиеСеансов");
		Кандидаты.Добавить("ШаблоныURL");
	КонецЕсли;

КонецПроцедуры

&НаСервереБезКонтекста
Процедура ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты)
	Кандидаты.Добавить("БазовоеИзмерение");
	Кандидаты.Добавить("Балансовый");
	Кандидаты.Добавить("Ведущее");
	Кандидаты.Добавить("ВыделятьОтрицательные");
	Кандидаты.Добавить("ДанныеВедущихРегистров");
	Кандидаты.Добавить("ЗаполнятьИзДанныхЗаполнения");
	Кандидаты.Добавить("ЗапрещатьНезаполненныеЗначения");
	Кандидаты.Добавить("ИзмерениеАдресации");
	Кандидаты.Добавить("ИзмерениеРегистра");
	Кандидаты.Добавить("Использование");
	Кандидаты.Добавить("ИспользованиеВИтогах");
	Кандидаты.Добавить("ИсторияДанных");
	Кандидаты.Добавить("Маска");
	Кандидаты.Добавить("МногострочныйРежим");
	Кандидаты.Добавить("ОсновнойОтбор");
	Кандидаты.Добавить("ПараметрыВыбора");
	Кандидаты.Добавить("ПризнакУчета");
	Кандидаты.Добавить("ПризнакУчетаСубконто");
	Кандидаты.Добавить("ПроверкаЗаполнения");
	Кандидаты.Добавить("РежимПароля");
	Кандидаты.Добавить("СвязиПараметровВыбора");
	Кандидаты.Добавить("СвязьПоТипу");
	Кандидаты.Добавить("СоответствиеДвижениям");
	Кандидаты.Добавить("СоответствиеДокументам");
	Кандидаты.Добавить("ЗначениеЗаполнения");
КонецПроцедуры

&НаСервереБезКонтекста
Функция СекцияИзКоллекцииПолноеИмяСиноним(Коллекция)
	
	Результат = Новый Массив;
	
	Если Коллекция = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для Каждого Элемент Из Коллекция Цикл
		
		ПолноеИмяЭлемента = "";
		СинонимЭлемента = "";
		
		Попытка
			ПолноеИмяЭлемента = Элемент.ПолноеИмя();
		Исключение
			ПолноеИмяЭлемента = "";
		КонецПопытки;
		
		Если ПустаяСтрока(ПолноеИмяЭлемента) Тогда
			Попытка
				ПолноеИмяЭлемента = Строка(Элемент);
			Исключение
				ПолноеИмяЭлемента = "";
			КонецПопытки;
		КонецЕсли;
		
		Попытка
			СинонимЭлемента = Элемент.Синоним;
		Исключение
			СинонимЭлемента = "";
		КонецПопытки;
		
		Результат.Добавить(Новый Структура("ПолноеИмя, Синоним", ПолноеИмяЭлемента, СинонимЭлемента));

	КонецЦикла;

	Возврат Результат;

КонецФункции

&НаСервереБезКонтекста
Функция СекцияИзКоллекцииМакетов(Коллекция)

	Результат = Новый Массив;

	Если Коллекция = Неопределено Тогда
		Возврат Результат;
	КонецЕсли;

	Для Каждого Элемент Из Коллекция Цикл

		ПолноеИмяЭлемента = "";
		СинонимЭлемента = "";
		ТипМакетаЭлемента = "";

		Попытка
			ПолноеИмяЭлемента = Элемент.ПолноеИмя();
		Исключение
			ПолноеИмяЭлемента = "";
		КонецПопытки;

		Если ПустаяСтрока(ПолноеИмяЭлемента) Тогда
			Попытка
				ПолноеИмяЭлемента = Строка(Элемент);
			Исключение
				ПолноеИмяЭлемента = "";
			КонецПопытки;
		КонецЕсли;

		Попытка
			СинонимЭлемента = Элемент.Синоним;
		Исключение
			СинонимЭлемента = "";
		КонецПопытки;

		Попытка
			ТипМакетаЭлемента = Строка(Элемент.ТипМакета);
		Исключение
			ТипМакетаЭлемента = "";
		КонецПопытки;

		Результат.Добавить(Новый Структура("ПолноеИмя, Синоним, ТипМакета",
			ПолноеИмяЭлемента, СинонимЭлемента, ТипМакетаЭлемента));

	КонецЦикла;

	Возврат Результат;

КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьПредопределенныеЭлементыСправочника(ИмяСправочника, Лимит = 200)
	
	Если ПустаяСтрока(ИмяСправочника) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив;
	
	Попытка
		
		ТекстЗапроса = 
			"ВЫБРАТЬ ПЕРВЫЕ " + Строка(Лимит) + Символы.ПС +
			"	ИмяПредопределенныхДанных КАК ИмяПредопределенныхДанных," + Символы.ПС +
			"	ПРЕДСТАВЛЕНИЕ(Ссылка) КАК Представление" + Символы.ПС +
			"ИЗ" + Символы.ПС +
			"	Справочник." + ИмяСправочника + Символы.ПС +
			"ГДЕ" + Символы.ПС +
			"	Предопределенный";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Таблица = Запрос.Выполнить().Выгрузить();
		
		Для Каждого СтрокаТаблицы Из Таблица Цикл
			Результат.Добавить(Новый Структура(
				"ИмяПредопределенныхДанных, Представление",
				СтрокаТаблицы.ИмяПредопределенныхДанных,
				СтрокаТаблицы.Представление
			));
		КонецЦикла;
		
		Возврат Результат;
		
	Исключение
		// Не удалось получить предопределенные данные (недоступно/нет прав/не поддерживается)
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksЕслиНужно(МетаОбъект)
	// Возвращает структуру extension_marks для объекта метаданных, если объект
	// добавлен/заимствован/изменён расширениями конфигурации.
	// Если объект "обычный" (основная конфигурация, Собственный, нет изменений расширениями),
	// то возвращает Неопределено, чтобы не засорять ответ.
	
	Если МетаОбъект = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Принадлежность = Неопределено;
	Попытка
		Принадлежность = МетаОбъект.ПринадлежностьОбъекта;
	Исключение
		Принадлежность = Неопределено;
	КонецПопытки;
	
	Расширение = Неопределено;
	Попытка
		Расширение = МетаОбъект.РасширениеКонфигурации();
	Исключение
		Расширение = Неопределено;
	КонецПопытки;
	
	ЕстьИзменения = Неопределено;
	Попытка
		ЕстьИзменения = (МетаОбъект.ЕстьИзмененияРасширениямиКонфигурации() = Истина);
	Исключение
		ЕстьИзменения = Неопределено;
	КонецПопытки;
	
	Показать = Ложь;
	
	Если Расширение <> Неопределено Тогда
		Показать = Истина;
	КонецЕсли;
	
	Если ЕстьИзменения = Истина Тогда
		Показать = Истина;
	КонецЕсли;
	
	Если НЕ Показать И Принадлежность <> Неопределено Тогда
		// В некоторых окружениях (толстый клиент/режим совместимости) идентификатор
		// ПринадлежностьОбъекта.<Значение> может быть недоступен как глобальный.
		// Поэтому сравниваем по строковому представлению (best effort).
		СтрПринадлежность = Строка(Принадлежность);
		Если СтрПринадлежность <> "Собственный" И СтрПринадлежность <> "Native" Тогда
			Показать = Истина;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ Показать Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИнфоРасширения = Неопределено;
	Если Расширение <> Неопределено Тогда
		ИнфоРасширения = Новый Структура;
		Попытка
			ИнфоРасширения.Вставить("Имя", Расширение.Имя);
		Исключение
		КонецПопытки;
		Попытка
			ИнфоРасширения.Вставить("Синоним", Расширение.Синоним);
		Исключение
		КонецПопытки;
		Попытка
			ИнфоРасширения.Вставить("УникальныйИдентификатор", БезопасноеЗначениеДляПередачи(Расширение.УникальныйИдентификатор));
		Исключение
		КонецПопытки;
	КонецЕсли;
	
	Метки = Новый Структура;
	Метки.Вставить("ПринадлежностьОбъекта", ?(Принадлежность = Неопределено, Неопределено, Строка(Принадлежность)));
	Метки.Вставить("РасширениеКонфигурации", ИнфоРасширения);
	Метки.Вставить("ЕстьИзмененияРасширениямиКонфигурации", ЕстьИзменения);
	
	Возврат Метки;
	
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksИзМетаданныхРасширения(МетаОбъектРасширения)
	// Маркеры "принадлежности" для объекта, полученного из ОбъектМетаданныхКонфигурация
	// (т.е. из бинарных метаданных расширения).
	//
	// ВАЖНО: метод ЕстьИзмененияРасширениямиКонфигурации() в этом контексте может существовать,
	// но семантически относится к рантайм-метаданным текущего сеанса и на объекте расширения
	// обычно бесполезен (часто всегда Ложь). Поэтому тут возвращаем только то, что точно
	// относится к метаданным расширения: ПринадлежностьОбъекта (Native/Adopted).
	
	Метки = Новый Структура;
	
	Принадлежность = Неопределено;
	Попытка
		Принадлежность = МетаОбъектРасширения.ПринадлежностьОбъекта;
	Исключение
		Принадлежность = Неопределено;
	КонецПопытки;
	
	Метки.Вставить("ПринадлежностьОбъекта", ?(Принадлежность = Неопределено, Неопределено, Строка(Принадлежность)));
	
	Возврат Метки;
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьExtensionMarksДляДочернегоИзМетаданныхРасширения(МетаОбъектРасширения)
	// Для дочерних объектов (реквизиты/табличные части/измерения/ресурсы) показываем метки
	// только если ПринадлежностьОбъекта = "Собственный" (Native), чтобы не раздувать ответ.
	
	Метки = ПолучитьExtensionMarksИзМетаданныхРасширения(МетаОбъектРасширения);
	
	СтрПринадлежность = "";
	Попытка
		Если Метки <> Неопределено И Метки.Свойство("ПринадлежностьОбъекта") И Метки.ПринадлежностьОбъекта <> Неопределено Тогда
			СтрПринадлежность = Строка(Метки.ПринадлежностьОбъекта);
		КонецЕсли;
	Исключение
		СтрПринадлежность = "";
	КонецПопытки;
	
	Если СтрПринадлежность = "Собственный" Или СтрПринадлежность = "Native" Тогда
		Возврат Метки;
	КонецЕсли;
	
	Возврат Неопределено;
КонецФункции


&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданные(ПолноеИмя, Секции = Неопределено)
	
	// Разбор полного имени (например, "Справочник.Номенклатура")
	ПозицияТочки = Найти(ПолноеИмя, ".");
	Если ПозицияТочки = 0 Тогда
		Возврат Новый Структура("success, error", Ложь, "Неверный формат имени объекта. Ожидается: Тип.Имя");
	КонецЕсли;
	
	ТипОбъекта = Лев(ПолноеИмя, ПозицияТочки - 1);
	ИмяОбъекта = Сред(ПолноеИмя, ПозицияТочки + 1);
	
	// Поиск объекта метаданных
	ОбъектМетаданных = Неопределено;
	
	// Основной способ: поиск по полному имени (поддерживает все типы, если доступно в платформе)
	Попытка
		ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ПолноеИмя);
	Исключение
		ОбъектМетаданных = Неопределено;
	КонецПопытки;
	
	// Fallback: поиск в коллекции по корневому типу
	Если ОбъектМетаданных = Неопределено Тогда
		
		ОписаниеТипа = Неопределено;
		Для Каждого Описание Из ПолучитьКорневыеТипыМетаданных() Цикл
			Если Описание.Тип = ТипОбъекта Тогда
				ОписаниеТипа = Описание;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ОписаниеТипа <> Неопределено Тогда
			Коллекция = Неопределено;
			Попытка
				Коллекция = Вычислить("Метаданные." + ОписаниеТипа.Коллекция);
			Исключение
				Коллекция = Неопределено;
			КонецПопытки;
			
			Если Коллекция <> Неопределено Тогда
				Попытка
					ОбъектМетаданных = Коллекция.Найти(ИмяОбъекта);
				Исключение
					ОбъектМетаданных = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОбъектМетаданных = Неопределено Тогда
		// Для путей с >1 точкой (элементы коллекций) пробуем найти через родителя
		// Нужно для стандартных реквизитов, которые НайтиПоПолномуИмени не находит
		КоличествоТочек = 0;
		Для Сч = 1 По СтрДлина(ПолноеИмя) Цикл
			Если Сред(ПолноеИмя, Сч, 1) = "." Тогда
				КоличествоТочек = КоличествоТочек + 1;
			КонецЕсли;
		КонецЦикла;

		Если КоличествоТочек > 1 Тогда
			// Извлекаем "Тип.Объект" (первые 2 сегмента) и "ОстатокПути"
			ПозПервойТочки = Найти(ПолноеИмя, ".");
			ОстатокПослеТипа = Сред(ПолноеИмя, ПозПервойТочки + 1);
			ПозВторойТочки = Найти(ОстатокПослеТипа, ".");
			// Защита от кривого filter (например "Тип.Объект." без имени элемента)
			Если ПозВторойТочки > 0 И ПозВторойТочки < СтрДлина(ОстатокПослеТипа) Тогда
				ИмяРодителя = Лев(ПолноеИмя, ПозПервойТочки + ПозВторойТочки - 1);
				ОстатокПутиЭлемента = Сред(ОстатокПослеТипа, ПозВторойТочки + 1);

				// Находим родительский объект
				РодительМД = Неопределено;
				Попытка
					РодительМД = Метаданные.НайтиПоПолномуИмени(ИмяРодителя);
				Исключение
				КонецПопытки;

				Если РодительМД <> Неопределено Тогда
					ЭлементМД = НайтиЭлементВКоллекцииОбъекта(РодительМД, ОстатокПутиЭлемента);
					Если ЭлементМД <> Неопределено Тогда
						Возврат ПолучитьДетальныеМетаданныеЭлемента(ЭлементМД, ПолноеИмя, Секции);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;

		Возврат Новый Структура("success, error", Ложь, "Объект не найден: " + ПолноеИмя);
	КонецЕсли;

	// Уточняем тип по фактическому полному имени (на случай, если исходная строка была нестандартной)
	ПолноеИмяФакт = ПолноеИмя;
	Попытка
		ПолноеИмяФакт = ОбъектМетаданных.ПолноеИмя();
	Исключение
		ПолноеИмяФакт = ПолноеИмя;
	КонецПопытки;
	
	ПозицияТочкиФакт = Найти(ПолноеИмяФакт, ".");
	Если ПозицияТочкиФакт > 0 Тогда
		ТипОбъекта = Лев(ПолноеИмяФакт, ПозицияТочкиФакт - 1);
	КонецЕсли;

	// Проверяем, является ли найденный объект элементом коллекции (Реквизит, Измерение и т.д.)
	// "Тип.Объект" = 1 точка, "Тип.Объект.Коллекция.Элемент" = 3 точки
	КоличествоТочекФакт = 0;
	Для Сч = 1 По СтрДлина(ПолноеИмяФакт) Цикл
		Если Сред(ПолноеИмяФакт, Сч, 1) = "." Тогда
			КоличествоТочекФакт = КоличествоТочекФакт + 1;
		КонецЕсли;
	КонецЦикла;

	Если КоличествоТочекФакт > 1 Тогда
		// Это элемент коллекции — возвращаем информацию только о нём
		Возврат ПолучитьДетальныеМетаданныеЭлемента(ОбъектМетаданных, ПолноеИмяФакт, Секции);
	КонецЕсли;
	
	// Формирование информации об объекте
	ИнформацияОбОбъекте = Новый Структура;
	ИнформацияОбОбъекте.Вставить("ТипОбъектаМетаданных", ТипОбъекта);
	ИнформацияОбОбъекте.Вставить("Имя", ОбъектМетаданных.Имя);
	ИнформацияОбОбъекте.Вставить("Синоним", ОбъектМетаданных.Синоним);
	ИнформацияОбОбъекте.Вставить("ПолноеИмя", ПолноеИмяФакт);
	
	// Маркеры расширений (показываем только если объект не "обычный")
	МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ОбъектМетаданных);
	Если МеткиРасширений <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("extension_marks", МеткиРасширений);
	КонецЕсли;
	
	// Реквизиты
	Реквизиты = Новый Массив;
	ЕстьКоллекцияРеквизитов = Ложь;

	// Стандартные реквизиты (Код, Наименование, Ссылка и т.д.)
	Попытка
		КоллекцияСтдРеквизитов = ОбъектМетаданных.СтандартныеРеквизиты;
		ЕстьКоллекцияРеквизитов = Истина;
		Для Каждого СтдРеквизит Из КоллекцияСтдРеквизитов Цикл
			Попытка
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
					СтдРеквизит.Имя,
					СтдРеквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип),
					Истина);

				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(СтдРеквизит);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;

				Реквизиты.Добавить(СтрокаРеквизита);
			Исключение
				// Пропускаем проблемный стандартный реквизит
			КонецПопытки;
		КонецЦикла;
	Исключение
		// У объекта нет коллекции СтандартныеРеквизиты
	КонецПопытки;

	// Пользовательские реквизиты
	Попытка
		КоллекцияРеквизитов = ОбъектМетаданных.Реквизиты;
		ЕстьКоллекцияРеквизитов = Истина;
		Для Каждого Реквизит Из КоллекцияРеквизитов Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип, Стандартный",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип),
				Ложь);

			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;

			Реквизиты.Добавить(СтрокаРеквизита);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет пользовательских реквизитов
	КонецПопытки;

	Если ЕстьКоллекцияРеквизитов Тогда
		ИнформацияОбОбъекте.Вставить("Реквизиты", Реквизиты);
	КонецЕсли;
	
	// Реквизиты адресации (для задач)
	Если ТипОбъекта = "Задача" Тогда
		РеквизитыАдресации = Неопределено;
		Попытка
			РеквизитыАдресации = Новый Массив;
			Для Каждого РеквизитАдресации Из ОбъектМетаданных.РеквизитыАдресации Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
					РеквизитАдресации.Имя,
					РеквизитАдресации.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(РеквизитАдресации.Тип));
				
				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(РеквизитАдресации);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;
				
				РеквизитыАдресации.Добавить(СтрокаРеквизита);
			КонецЦикла;
		Исключение
			// Секция не применима/недоступна
			РеквизитыАдресации = Неопределено;
		КонецПопытки;
		
		Если РеквизитыАдресации <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("РеквизитыАдресации", РеквизитыАдресации);
		КонецЕсли;
	КонецЕсли;
	
	// Табличные части
	ТабличныеЧасти = Неопределено;
	Попытка
		ТабличныеЧасти = Новый Массив;
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			РеквизитыТЧ = Новый Массив;
			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
				СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
					Реквизит.Имя,
					Реквизит.Синоним,
					ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));
				
				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;
				
				РеквизитыТЧ.Добавить(СтрокаРеквизита);
			КонецЦикла;
			
			СтрокаТЧ = Новый Структура("Имя, Синоним, Реквизиты",
				ТабличнаяЧасть.Имя,
				ТабличнаяЧасть.Синоним,
				РеквизитыТЧ);
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ТабличнаяЧасть);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаТЧ.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			ТабличныеЧасти.Добавить(СтрокаТЧ);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет табличных частей (секция не применима)
		ТабличныеЧасти = Неопределено;
	КонецПопытки;
	Если ТабличныеЧасти <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("ТабличныеЧасти", ТабличныеЧасти);
	КонецЕсли;
	
	// Измерения (для регистров)
	Измерения = Неопределено;
	Попытка
		Измерения = Новый Массив;
		Для Каждого Измерение Из ОбъектМетаданных.Измерения Цикл
			СтрокаИзмерения = Новый Структура("Имя, Синоним, Тип",
				Измерение.Имя,
				Измерение.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Измерение.Тип));
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Измерение);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаИзмерения.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			Измерения.Добавить(СтрокаИзмерения);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет измерений (секция не применима)
		Измерения = Неопределено;
	КонецПопытки;
	Если Измерения <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("Измерения", Измерения);
	КонецЕсли;
	
	// Ресурсы (для регистров)
	Ресурсы = Неопределено;
	Попытка
		Ресурсы = Новый Массив;
		Для Каждого Ресурс Из ОбъектМетаданных.Ресурсы Цикл
			СтрокаРесурса = Новый Структура("Имя, Синоним, Тип",
				Ресурс.Имя,
				Ресурс.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Ресурс.Тип));
			
			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Ресурс);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРесурса.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;
			
			Ресурсы.Добавить(СтрокаРесурса);
		КонецЦикла;
	Исключение
		// У некоторых объектов нет ресурсов (секция не применима)
		Ресурсы = Неопределено;
	КонецПопытки;
	Если Ресурсы <> Неопределено Тогда
		ИнформацияОбОбъекте.Вставить("Ресурсы", Ресурсы);
	КонецЕсли;
	
	// Значения перечисления
	Если ТипОбъекта = "Перечисление" Тогда
		ЗначенияПеречисления = Новый Массив;
		Для Каждого ЗначениеПеречисления Из ОбъектМетаданных.ЗначенияПеречисления Цикл
			ЗначенияПеречисления.Добавить(Новый Структура("Имя, Синоним", 
				ЗначениеПеречисления.Имя, 
				ЗначениеПеречисления.Синоним));
		КонецЦикла;
		ИнформацияОбОбъекте.Вставить("ЗначенияПеречисления", ЗначенияПеречисления);
	КонецЕсли;
	
	// Владельцы (для подчинённых справочников)
	Если ТипОбъекта = "Справочник" Тогда
		Попытка
			Если ОбъектМетаданных.Владельцы.Количество() > 0 Тогда
				Владельцы = Новый Массив;
				Для Каждого Владелец Из ОбъектМетаданных.Владельцы Цикл
					Владельцы.Добавить(Владелец.ПолноеИмя());
				КонецЦикла;
				ИнформацияОбОбъекте.Вставить("Владельцы", Владельцы);
			КонецЕсли;
		Исключение
			// У некоторых справочников нет владельцев
		КонецПопытки;
	КонецЕсли;

	// ПризнакиУчета и ПризнакиУчетаСубконто (только для планов счетов)
	Если ТипОбъекта = "ПланСчетов" Тогда
		Попытка
			КоллекцияПризнаков = ОбъектМетаданных.ПризнакиУчета;
			Если КоллекцияПризнаков <> Неопределено Тогда
				МассивПризнаков = Новый Массив;
				Для Каждого Признак Из КоллекцияПризнаков Цикл
					МассивПризнаков.Добавить(Новый Структура("Имя, Синоним, Тип",
						Признак.Имя, Признак.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
				КонецЦикла;
				Если МассивПризнаков.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("ПризнакиУчета", МассивПризнаков);
				КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;

		Попытка
			КоллекцияПризнаковСубконто = ОбъектМетаданных.ПризнакиУчетаСубконто;
			Если КоллекцияПризнаковСубконто <> Неопределено Тогда
				МассивПризнаковСубконто = Новый Массив;
				Для Каждого Признак Из КоллекцияПризнаковСубконто Цикл
					МассивПризнаковСубконто.Добавить(Новый Структура("Имя, Синоним, Тип",
						Признак.Имя, Признак.Синоним,
						ПолучитьСтроковоеПредставлениеОписанияТипов(Признак.Тип)));
				КонецЦикла;
				Если МассивПризнаковСубконто.Количество() > 0 Тогда
					ИнформацияОбОбъекте.Вставить("ПризнакиУчетаСубконто", МассивПризнаковСубконто);
				КонецЕсли;
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;

	// СтандартныеТабличныеЧасти (для ПланСчетов и ПланВидовРасчета)
	Если ТипОбъекта = "ПланСчетов" ИЛИ ТипОбъекта = "ПланВидовРасчета" Тогда
		Попытка
			СтандартныеТабличныеЧасти = Новый Массив;
			Для Каждого СтдТЧ Из ОбъектМетаданных.СтандартныеТабличныеЧасти Цикл
				РеквизитыСтдТЧ = Новый Массив;
				Попытка
					Для Каждого СтдРеквизит Из СтдТЧ.СтандартныеРеквизиты Цикл
						Попытка
							РеквизитыСтдТЧ.Добавить(Новый Структура("Имя, Синоним, Тип",
								СтдРеквизит.Имя,
								СтдРеквизит.Синоним,
								ПолучитьСтроковоеПредставлениеОписанияТипов(СтдРеквизит.Тип)));
						Исключение
						КонецПопытки;
					КонецЦикла;
				Исключение
				КонецПопытки;

				СтрокаСтдТЧ = Новый Структура("Имя, Синоним, Реквизиты",
					СтдТЧ.Имя,
					СтдТЧ.Синоним,
					РеквизитыСтдТЧ);

				МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(СтдТЧ);
				Если МеткиРасширений <> Неопределено Тогда
					СтрокаСтдТЧ.Вставить("extension_marks", МеткиРасширений);
				КонецЕсли;

				СтандартныеТабличныеЧасти.Добавить(СтрокаСтдТЧ);
			КонецЦикла;
			Если СтандартныеТабличныеЧасти.Количество() > 0 Тогда
				ИнформацияОбОбъекте.Вставить("СтандартныеТабличныеЧасти", СтандартныеТабличныеЧасти);
			КонецЕсли;
		Исключение
		КонецПопытки;
	КонецЕсли;

	// Дополнительные секции детального ответа (управляемый "богатый" режим)
	Если СекцияЗапрошена(Секции, "properties") Тогда

		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		
		ДобавитьКандидатыСвойствПоТипу(ТипОбъекта, Кандидаты);
		
		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
				ЗначениеСвойства = Неопределено;
			КонецПопытки;
			
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;
		
		ИнформацияОбОбъекте.Вставить("properties", Свойства);
		
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "forms") Тогда
		КоллекцияФорм = Неопределено;
		Попытка
			КоллекцияФорм = ОбъектМетаданных.Формы;
		Исключение
			КоллекцияФорм = Неопределено;
		КонецПопытки;
		
		Если КоллекцияФорм <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("forms", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияФорм));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "commands") Тогда
		КоллекцияКоманд = Неопределено;
		Попытка
			КоллекцияКоманд = ОбъектМетаданных.Команды;
		Исключение
			КоллекцияКоманд = Неопределено;
		КонецПопытки;
		
		Если КоллекцияКоманд <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("commands", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияКоманд));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "layouts") Тогда
		КоллекцияМакетов = Неопределено;
		Попытка
			КоллекцияМакетов = ОбъектМетаданных.Макеты;
		Исключение
			КоллекцияМакетов = Неопределено;
		КонецПопытки;
		
		Если КоллекцияМакетов <> Неопределено Тогда
			ИнформацияОбОбъекте.Вставить("layouts", СекцияИзКоллекцииМакетов(КоллекцияМакетов));
		КонецЕсли;
	КонецЕсли;
	
	Если СекцияЗапрошена(Секции, "predefined") Тогда
		
		// 1) Если в рантайм-метаданных есть коллекция предопределенных - используем ее
		КоллекцияПредопределенных = Неопределено;
		Попытка
			КоллекцияПредопределенных = ОбъектМетаданных.Предопределенные;
		Исключение
			КоллекцияПредопределенных = Неопределено;
		КонецПопытки;
		
		Если КоллекцияПредопределенных <> Неопределено Тогда
			Попытка
				ИнформацияОбОбъекте.Вставить("predefined", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияПредопределенных));
			Исключение
				// Если это не коллекция - игнорируем и пробуем fallback ниже
			КонецПопытки;
		КонецЕсли;
		
		// 2) Fallback для справочников: предопределенные данные хранятся как данные (отбор по Предопределенный)
		Если Не ИнформацияОбОбъекте.Свойство("predefined") И ТипОбъекта = "Справочник" Тогда
			ПредопределенныеДанные = ПолучитьПредопределенныеЭлементыСправочника(ИмяОбъекта, 200);
			Если ПредопределенныеДанные <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("predefined", ПредопределенныеДанные);
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;

	// Движения (только для документов — список регистров, в которых документ делает движения)
	Если СекцияЗапрошена(Секции, "movements") Тогда
		Если ТипОбъекта = "Документ" Тогда
			КоллекцияДвижений = Неопределено;
			Попытка
				КоллекцияДвижений = ОбъектМетаданных.Движения;
			Исключение
				КоллекцияДвижений = Неопределено;
			КонецПопытки;

			Если КоллекцияДвижений <> Неопределено Тогда
				ИнформацияОбОбъекте.Вставить("movements", СекцияИзКоллекцииПолноеИмяСиноним(КоллекцияДвижений));
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// Характеристики (описания характеристик, привязанных к объекту метаданных)
	Если СекцияЗапрошена(Секции, "characteristics") Тогда
		КоллекцияХарактеристик = Неопределено;
		Попытка
			КоллекцияХарактеристик = ОбъектМетаданных.Характеристики;
		Исключение
			КоллекцияХарактеристик = Неопределено;
		КонецПопытки;

		Если КоллекцияХарактеристик <> Неопределено Тогда
			МассивХарактеристик = Новый Массив;
			Для Каждого ОписаниеХарактеристики Из КоллекцияХарактеристик Цикл
				ЭлементХарактеристики = Новый Структура;

				// ВидыХарактеристик — ссылка на ПланВидовХарактеристик → ПолноеИмя()
				Попытка
					ВидыХар = ОписаниеХарактеристики.ВидыХарактеристик;
					Если ВидыХар <> Неопределено Тогда
						Попытка
							ЭлементХарактеристики.Вставить("ВидыХарактеристик", ВидыХар.ПолноеИмя());
						Исключение
							ЭлементХарактеристики.Вставить("ВидыХарактеристик", Строка(ВидыХар));
						КонецПопытки;
					КонецЕсли;
				Исключение
				КонецПопытки;

				// ЗначенияХарактеристик — ссылка на регистр сведений → ПолноеИмя()
				Попытка
					ЗначенияХар = ОписаниеХарактеристики.ЗначенияХарактеристик;
					Если ЗначенияХар <> Неопределено Тогда
						Попытка
							ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", ЗначенияХар.ПолноеИмя());
						Исключение
							ЭлементХарактеристики.Вставить("ЗначенияХарактеристик", Строка(ЗначенияХар));
						КонецПопытки;
					КонецЕсли;
				Исключение
				КонецПопытки;

				// ЗначениеОтбораВидов — произвольный тип
				Попытка
					ЗначениеОтбора = ОписаниеХарактеристики.ЗначениеОтбораВидов;
					Если ЗначениеОтбора <> Неопределено Тогда
						ЭлементХарактеристики.Вставить("ЗначениеОтбораВидов",
							БезопасноеЗначениеДляПередачи(ЗначениеОтбора));
					КонецЕсли;
				Исключение
				КонецПопытки;

				// Поля (строковые свойства) — через Вычислить с безопасным доступом
				ПоляСтроковые = Новый Структура;
				ПоляСтроковые.Вставить("ПолеВида",                                "ПолеВида");
				ПоляСтроковые.Вставить("ПолеЗначения",                            "ПолеЗначения");
				ПоляСтроковые.Вставить("ПолеИспользованияМножественныхЗначений",  "ПолеИспользованияМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеКлюча",                               "ПолеКлюча");
				ПоляСтроковые.Вставить("ПолеКлючаМножественныхЗначений",          "ПолеКлючаМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеОбъекта",                             "ПолеОбъекта");
				ПоляСтроковые.Вставить("ПолеОтбораВидов",                         "ПолеОтбораВидов");
				ПоляСтроковые.Вставить("ПолеПорядкаМножественныхЗначений",        "ПолеПорядкаМножественныхЗначений");
				ПоляСтроковые.Вставить("ПолеПутиКДанным",                         "ПолеПутиКДанным");

				Для Каждого КлючЗначение Из ПоляСтроковые Цикл
					Попытка
						ЗначениеПоля = Вычислить("ОписаниеХарактеристики." + КлючЗначение.Значение);
						Если ЗначениеПоля <> Неопределено И Не ПустаяСтрока(Строка(ЗначениеПоля)) Тогда
							ЭлементХарактеристики.Вставить(КлючЗначение.Ключ, Строка(ЗначениеПоля));
						КонецЕсли;
					Исключение
					КонецПопытки;
				КонецЦикла;

				// Пропускаем пустые элементы (все поля = Неопределено/пустые)
				Если ЭлементХарактеристики.Количество() > 0 Тогда
					МассивХарактеристик.Добавить(ЭлементХарактеристики);
				КонецЕсли;
			КонецЦикла;

			Если МассивХарактеристик.Количество() > 0 Тогда
				ИнформацияОбОбъекте.Вставить("characteristics", МассивХарактеристик);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, ИнформацияОбОбъекте);

КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьДетальныеМетаданныеЭлемента(ОбъектМетаданных, ПолноеИмяМД, Секции)

	ИнформацияОбЭлементе = Новый Структура;
	ИнформацияОбЭлементе.Вставить("ПолноеИмя", ПолноеИмяМД);
	ИнформацияОбЭлементе.Вставить("Имя", ОбъектМетаданных.Имя);

	Попытка
		ИнформацияОбЭлементе.Вставить("Синоним", ОбъектМетаданных.Синоним);
	Исключение
	КонецПопытки;

	// Тип (описание типов) — есть у реквизитов, измерений, ресурсов
	Попытка
		ИнформацияОбЭлементе.Вставить("Тип",
			ПолучитьСтроковоеПредставлениеОписанияТипов(ОбъектМетаданных.Тип));
	Исключение
		// У некоторых элементов (ТабличнаяЧасть) нет свойства Тип
	КонецПопытки;

	// Для табличных частей — вернуть список реквизитов
	Попытка
		РеквизитыТЧ = Новый Массив;
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			СтрокаРеквизита = Новый Структура("Имя, Синоним, Тип",
				Реквизит.Имя,
				Реквизит.Синоним,
				ПолучитьСтроковоеПредставлениеОписанияТипов(Реквизит.Тип));

			МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(Реквизит);
			Если МеткиРасширений <> Неопределено Тогда
				СтрокаРеквизита.Вставить("extension_marks", МеткиРасширений);
			КонецЕсли;

			РеквизитыТЧ.Добавить(СтрокаРеквизита);
		КонецЦикла;
		ИнформацияОбЭлементе.Вставить("Реквизиты", РеквизитыТЧ);
	Исключение
		// Нет коллекции реквизитов (не ТабличнаяЧасть)
	КонецПопытки;

	// Extension marks
	МеткиРасширений = ПолучитьExtensionMarksЕслиНужно(ОбъектМетаданных);
	Если МеткиРасширений <> Неопределено Тогда
		ИнформацияОбЭлементе.Вставить("extension_marks", МеткиРасширений);
	КонецЕсли;

	// Properties — расширенные свойства элемента
	Если СекцияЗапрошена(Секции, "properties") Тогда
		Свойства = Новый Структура;
		Кандидаты = Новый Массив;
		ДобавитьКандидатыСвойствЭлементаКоллекции(Кандидаты);

		Для Каждого ИмяСвойства Из Кандидаты Цикл
			ЗначениеСвойства = Неопределено;
			Попытка
				ЗначениеСвойства = Вычислить("ОбъектМетаданных." + ИмяСвойства);
			Исключение
			КонецПопытки;
			Если ЗначениеСвойства <> Неопределено Тогда
				ЗначениеДляJSON = ПолноеИмяМетаданныхЕслиВозможно(ЗначениеСвойства);
				Если ЗначениеДляJSON = Неопределено Тогда
					ЗначениеДляJSON = БезопасноеЗначениеДляПередачи(ЗначениеСвойства);
				КонецЕсли;
				Свойства.Вставить(ИмяСвойства, ЗначениеДляJSON);
			КонецЕсли;
		КонецЦикла;

		ИнформацияОбЭлементе.Вставить("properties", Свойства);
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, ИнформацияОбЭлементе);

КонецФункции

&НаСервереБезКонтекста
Функция НайтиЭлементВКоллекцииОбъекта(ОбъектМД, ОстатокПути)
	// ОстатокПути = "Реквизит.ИНН" или "ТабличнаяЧасть.Товары.Реквизит.Номенклатура"
	// Сегменты в единственном числе — формат ПолноеИмя() платформы
	Части = РазделитьСтрокуПоРазделителю(ОстатокПути, ".");

	Если Части.Количество() < 2 Тогда
		Возврат Неопределено;
	КонецЕсли;

	// Маппинг: единственное число из ПолноеИмя() → имя свойства объекта метаданных
	ИмяСегмента = Части[0];
	Если ИмяСегмента = "Реквизит" Тогда
		ИмяКоллекции = "Реквизиты";
	ИначеЕсли ИмяСегмента = "СтандартныйРеквизит" Тогда
		ИмяКоллекции = "СтандартныеРеквизиты";
	ИначеЕсли ИмяСегмента = "Измерение" Тогда
		ИмяКоллекции = "Измерения";
	ИначеЕсли ИмяСегмента = "Ресурс" Тогда
		ИмяКоллекции = "Ресурсы";
	ИначеЕсли ИмяСегмента = "РеквизитАдресации" Тогда
		ИмяКоллекции = "РеквизитыАдресации";
	ИначеЕсли ИмяСегмента = "ТабличнаяЧасть" Тогда
		ИмяКоллекции = "ТабличныеЧасти";
	Иначе
		ИмяКоллекции = ИмяСегмента;
	КонецЕсли;

	ИмяЭлемента = Части[1];

	// Получаем коллекцию
	Коллекция = Неопределено;
	Попытка
		Коллекция = Вычислить("ОбъектМД." + ИмяКоллекции);
	Исключение
		Возврат Неопределено;
	КонецПопытки;

	// Ищем элемент по имени
	Для Каждого Элемент Из Коллекция Цикл
		Если Элемент.Имя = ИмяЭлемента Тогда
			// Для вложенного пути (ТабличнаяЧасть.Товары.Реквизит.Номенклатура)
			Если Части.Количество() > 2 Тогда
				ВложенныйОстаток = "";
				Для Инд = 2 По Части.Количество() - 1 Цикл
					ВложенныйОстаток = ВложенныйОстаток
						+ ?(ВложенныйОстаток = "", "", ".") + Части[Инд];
				КонецЦикла;
				Возврат НайтиЭлементВКоллекцииОбъекта(Элемент, ВложенныйОстаток);
			КонецЕсли;
			Возврат Элемент;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ЖУРНАЛ РЕГИСТРАЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервереБезКонтекста
Функция ПолучитьЖурналРегистрации(ДатаНачала, ДатаОкончания, Уровни, СобытияЖурнала, Лимит,
	ДанныеОбъекта = Неопределено, ТипыМетаданных = Неопределено, Пользователи = Неопределено,
	Сеансы = Неопределено, Приложения = Неопределено, Компьютер = Неопределено,
	ПодстрокаКомментария = Неопределено, СтатусТранзакцииСтрока = Неопределено, СмещениеВСекунде = 0)
	
	Попытка
		// Формируем отбор
		Отбор = Новый Структура;
		
		Если ЗначениеЗаполнено(ДатаНачала) Тогда
			Отбор.Вставить("ДатаНачала", ДатаНачала);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ДатаОкончания) Тогда
			Отбор.Вставить("ДатаОкончания", ДатаОкончания);
		КонецЕсли;
		
		// Уровни важности
		Если Уровни <> Неопределено И ЭтоКоллекция(Уровни) Тогда
			МассивУровней = Новый Массив;
			Для Каждого УровеньСтрока Из Уровни Цикл
				Если ВРег(УровеньСтрока) = "INFORMATION" Или ВРег(УровеньСтрока) = "ИНФОРМАЦИЯ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Информация);
				ИначеЕсли ВРег(УровеньСтрока) = "WARNING" Или ВРег(УровеньСтрока) = "ПРЕДУПРЕЖДЕНИЕ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Предупреждение);
				ИначеЕсли ВРег(УровеньСтрока) = "ERROR" Или ВРег(УровеньСтрока) = "ОШИБКА" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Ошибка);
				ИначеЕсли ВРег(УровеньСтрока) = "NOTE" Или ВРег(УровеньСтрока) = "ПРИМЕЧАНИЕ" Тогда
					МассивУровней.Добавить(УровеньЖурналаРегистрации.Примечание);
				КонецЕсли;
			КонецЦикла;
			Если МассивУровней.Количество() > 0 Тогда
				Отбор.Вставить("Уровень", МассивУровней);
			КонецЕсли;
		КонецЕсли;
		
		// События
		Если СобытияЖурнала <> Неопределено И ЭтоКоллекция(СобытияЖурнала) Тогда
			Отбор.Вставить("Событие", СобытияЖурнала);
		КонецЕсли;
		
		// Фильтр по объекту данных (навигационная ссылка)
		Если ЗначениеЗаполнено(ДанныеОбъекта) Тогда
			СсылкаОбъекта = ПолучитьСсылкуИзСтроки(ДанныеОбъекта);
			Если СсылкаОбъекта = Неопределено Тогда
				// Возвращаем явную ошибку при невозможности применить фильтр по объекту
				Возврат Новый Структура("success,error", Ложь,
					"Не удалось применить фильтр по объекту: некорректная ссылка / Failed to apply object filter: invalid reference");
			КонецЕсли;
			Отбор.Вставить("Данные", СсылкаОбъекта);
		КонецЕсли;
		
		// Фильтр по типу метаданных
		Если ТипыМетаданных <> Неопределено И ЭтоКоллекция(ТипыМетаданных) Тогда
			МассивМетаданных = Новый Массив;
			Для Каждого ИмяМетаданных Из ТипыМетаданных Цикл
				ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяМетаданных);
				Если ОбъектМетаданных <> Неопределено Тогда
					МассивМетаданных.Добавить(ОбъектМетаданных);
				КонецЕсли;
			КонецЦикла;
			Если МассивМетаданных.Количество() > 0 Тогда
				Отбор.Вставить("Метаданные", МассивМетаданных);
			КонецЕсли;
		КонецЕсли;
		
		// Фильтр по пользователю
		Если Пользователи <> Неопределено И ЭтоКоллекция(Пользователи) Тогда
			МассивПользователей = Новый Массив;
			Для Каждого ИмяПользователя Из Пользователи Цикл
				ЗначениеПользователя = СокрЛП(ИмяПользователя);
				ПользовательИБ = Неопределено;
				// Проверка формата UUID (два шага: длина, затем дефисы)
				ЭтоУИД = Ложь;
				Если СтрДлина(ЗначениеПользователя) = 36 Тогда
					ЭтоУИД = (Сред(ЗначениеПользователя, 9, 1) = "-")
						И (Сред(ЗначениеПользователя, 14, 1) = "-")
						И (Сред(ЗначениеПользователя, 19, 1) = "-")
						И (Сред(ЗначениеПользователя, 24, 1) = "-");
				КонецЕсли;
				Если ЭтоУИД Тогда
					Попытка
						ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(
							Новый УникальныйИдентификатор(ЗначениеПользователя));
					Исключение
					КонецПопытки;
				КонецЕсли;
				Если ПользовательИБ = Неопределено Тогда
					ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ЗначениеПользователя);
				КонецЕсли;
				Если ПользовательИБ <> Неопределено Тогда
					МассивПользователей.Добавить(ПользовательИБ);
				Иначе
					// Удалённый пользователь или "" (пользователь по умолчанию) — передаём строкой
					МассивПользователей.Добавить(ЗначениеПользователя);
				КонецЕсли;
			КонецЦикла;
			Если МассивПользователей.Количество() > 0 Тогда
				Отбор.Вставить("Пользователь", МассивПользователей);
			КонецЕсли;
		КонецЕсли;
		
		// Фильтр по сеансу
		Если Сеансы <> Неопределено И ЭтоКоллекция(Сеансы) Тогда
			Отбор.Вставить("Сеанс", Сеансы);
		КонецЕсли;
		
		// Фильтр по приложению
		Если Приложения <> Неопределено И ЭтоКоллекция(Приложения) Тогда
			Отбор.Вставить("ИмяПриложения", Приложения);
		КонецЕсли;
		
		// Фильтр по компьютеру
		Если ЗначениеЗаполнено(Компьютер) Тогда
			Отбор.Вставить("Компьютер", Компьютер);
		КонецЕсли;
		
		// Статус транзакции - нативный фильтр (8.1+), через Вычислить() для совместимости с 8.2.13
		Если ЗначениеЗаполнено(СтатусТранзакцииСтрока) Тогда
			МассивСтатусов = Новый Массив;
			СтатусВерхний = ВРег(СтатусТранзакцииСтрока);
			ИмяЗначения = "";
			Если СтатусВерхний = "COMMITTED" Тогда
				ИмяЗначения = "СтатусТранзакцииЗаписиЖурналаРегистрации.Зафиксирована";
			ИначеЕсли СтатусВерхний = "ROLLEDBACK" Тогда
				ИмяЗначения = "СтатусТранзакцииЗаписиЖурналаРегистрации.Отменена";
			ИначеЕсли СтатусВерхний = "NOTAPPLICABLE" Тогда
				ИмяЗначения = "СтатусТранзакцииЗаписиЖурналаРегистрации.НетТранзакции";
			ИначеЕсли СтатусВерхний = "UNFINISHED" Тогда
				ИмяЗначения = "СтатусТранзакцииЗаписиЖурналаРегистрации.НеЗавершена";
			Иначе
				ИмяЗначения = "";
			КонецЕсли;
			Если ЗначениеЗаполнено(ИмяЗначения) Тогда
				Попытка
					МассивСтатусов.Добавить(Вычислить(ИмяЗначения));
					Отбор.Вставить("СтатусТранзакции", МассивСтатусов);
				Исключение
					Возврат Новый Структура("success,error", Ложь,
						"Фильтр по статусу транзакции недоступен на данной платформе: " + ОписаниеОшибки());
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
		// Вычисляем лимит выгрузки с учётом смещения и постфильтров
		// Формула: Лимит + СмещениеВСекунде + 1 (для определения has_more)
		// При постфильтрах: (Лимит * 10) + СмещениеВСекунде + 1
		ЕстьПостфильтры = ЗначениеЗаполнено(ПодстрокаКомментария);
		Если ЕстьПостфильтры Тогда
			ЛимитВыгрузки = (Лимит * 10) + СмещениеВСекунде + 1;
		Иначе
			ЛимитВыгрузки = Лимит + СмещениеВСекунде + 1;
		КонецЕсли;
		
		// Выгружаем журнал
		ТаблицаЖурнала = Новый ТаблицаЗначений;
		ВыгрузитьЖурналРегистрации(ТаблицаЖурнала, Отбор, , , ЛимитВыгрузки);
		
		// Постфильтрация по комментарию (платформа не поддерживает поиск по подстроке)
		Если ЗначениеЗаполнено(ПодстрокаКомментария) Тогда
			ПодстрокаВерхнийРегистр = ВРег(ПодстрокаКомментария);
			СтрокиДляУдаления = Новый Массив;
			Для Каждого СтрокаТаблицы Из ТаблицаЖурнала Цикл
				Если Найти(ВРег(СтрокаТаблицы.Комментарий), ПодстрокаВерхнийРегистр) = 0 Тогда
					СтрокиДляУдаления.Добавить(СтрокаТаблицы);
				КонецЕсли;
			КонецЦикла;
			Для Каждого СтрокаДляУдаления Из СтрокиДляУдаления Цикл
				ТаблицаЖурнала.Удалить(СтрокаДляУдаления);
			КонецЦикла;
		КонецЕсли;

		// КУРСОРНАЯ ПАГИНАЦИЯ: Явная сортировка с tie-breakers для стабильного порядка
		// Гарантирует детерминированный порядок записей с одинаковой секундой
		ТаблицаЖурнала.Сортировать("Дата, Сеанс, Событие, Пользователь, Метаданные, ПредставлениеДанных");

		// Вычисляем ключ секунды для start_date (для корректного сравнения)
		// В 1С дата может содержать доли секунды — сравнение = может не работать
		КлючСекундыНачала = "";
		Если ЗначениеЗаполнено(ДатаНачала) Тогда
			КлючСекундыНачала = Формат(ДатаНачала, "ДФ=yyyy-MM-ddTHH:mm:ss");
		КонецЕсли;

		// Преобразуем в массив для JSON с логикой курсорной пагинации
		Результат = Новый Массив;
		Счетчик = 0;
		ПропущеноВСекунде = 0;
		КлючПоследнейСекунды = "";
		КоличествоВПоследнейСекунде = 0;

		Для Каждого СтрокаТаблицы Из ТаблицаЖурнала Цикл
			// Ключ секунды текущей строки
			КлючСекундыСтроки = Формат(СтрокаТаблицы.Дата, "ДФ=yyyy-MM-ddTHH:mm:ss");

			// Пропускаем записи с начальной секундой если задан offset
			Если КлючСекундыНачала <> ""
			   И КлючСекундыСтроки = КлючСекундыНачала
			   И ПропущеноВСекунде < СмещениеВСекунде Тогда
				ПропущеноВСекунде = ПропущеноВСекунде + 1;
				Продолжить;
			КонецЕсли;

			Если Счетчик >= Лимит Тогда
				Прервать;
			КонецЕсли;

			ЗаписьЖурнала = Новый Структура;
			ЗаписьЖурнала.Вставить("date", КлючСекундыСтроки);
			ЗаписьЖурнала.Вставить("level", ПолучитьИмяУровня(СтрокаТаблицы.Уровень));
			ЗаписьЖурнала.Вставить("event", СтрокаТаблицы.Событие);
			ЗаписьЖурнала.Вставить("comment", СтрокаТаблицы.Комментарий);
			ЗаписьЖурнала.Вставить("user", Строка(СтрокаТаблицы.Пользователь));
			ЗаписьЖурнала.Вставить("metadata", Строка(СтрокаТаблицы.Метаданные));
			ЗаписьЖурнала.Вставить("data_presentation", СтрокаТаблицы.ПредставлениеДанных);
			ЗаписьЖурнала.Вставить("session", СтрокаТаблицы.Сеанс);
			ЗаписьЖурнала.Вставить("application", СтрокаТаблицы.ИмяПриложения);
			ЗаписьЖурнала.Вставить("computer", СтрокаТаблицы.Компьютер);
			ЗаписьЖурнала.Вставить("transaction_status", ПолучитьИмяСтатусаТранзакции(СтрокаТаблицы.СтатусТранзакции));
			Результат.Добавить(ЗаписьЖурнала);

			// Отслеживаем для курсора (накопительный счётчик) — по ключу секунды
			Если КлючПоследнейСекунды = КлючСекундыСтроки Тогда
				КоличествоВПоследнейСекунде = КоличествоВПоследнейСекунде + 1;
			Иначе
				КлючПоследнейСекунды = КлючСекундыСтроки;
				КоличествоВПоследнейСекунде = 1;
			КонецЕсли;

			Счетчик = Счетчик + 1;
		КонецЦикла;

		// Формируем ответ
		ОтветСтруктура = Новый Структура("success,data,count", Истина, Результат, Результат.Количество());

		// Курсорная пагинация - только если указаны даты
		ЕстьФильтрПоДате = ЗначениеЗаполнено(ДатаНачала) Или ЗначениеЗаполнено(ДатаОкончания);

		Если ЕстьФильтрПоДате И КлючПоследнейСекунды <> "" Тогда
			ОтветСтруктура.Вставить("last_date", КлючПоследнейСекунды);

			// КРИТИЧНО: возвращаем НАКОПИТЕЛЬНЫЙ offset для следующей страницы
			// Сравниваем по КЛЮЧУ СЕКУНДЫ, а не по Date-объектам
			Если КлючПоследнейСекунды = КлючСекундыНачала Тогда
				// Та же секунда что и на входе — накапливаем
				СледующийOffset = СмещениеВСекунде + КоличествоВПоследнейСекунде;
			Иначе
				// Новая секунда — offset только от записей с этой секундой
				СледующийOffset = КоличествоВПоследнейСекунде;
			КонецЕсли;
			ОтветСтруктура.Вставить("next_same_second_offset", СледующийOffset);

			// has_more: осталось больше записей чем limit после пропуска?
			ОсталосьЗаписей = ТаблицаЖурнала.Количество() - ПропущеноВСекунде;
			ЕстьЕще = ОсталосьЗаписей > Лимит;
			ОтветСтруктура.Вставить("has_more", ЕстьЕще);
		КонецЕсли;

		Возврат ОтветСтруктура;
		
	Исключение
		Возврат Новый Структура("success,error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьСсылкуИзСтроки(СтрокаСсылки)
	
	Если Не ЗначениеЗаполнено(СтрокаСсылки) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		// Пробуем как навигационную ссылку (e1cib/data/...)
		Если Найти(НРег(СтрокаСсылки), "e1cib") > 0 Тогда
			Возврат НайтиОбъектВручную(СтрокаСсылки);
		КонецЕсли;
		
		// Пробуем как UUID (8-4-4-4-12 формат)
		Если СтрДлина(СтрокаСсылки) = 36 И Найти(СтрокаСсылки, "-") > 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Возврат Неопределено;
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяСтатусаТранзакции(Статус)
	Если Не ЗначениеЗаполнено(Статус) Тогда
		Возврат "";
	КонецЕсли;
	// XMLСтрока() возвращает английский идентификатор напрямую — используем его
	Попытка
		СтатусСтрока = XMLСтрока(Статус);
		Если СтатусСтрока = "Committed"
		  Или СтатусСтрока = "RolledBack"
		  Или СтатусСтрока = "NotApplicable"
		  Или СтатусСтрока = "Unfinished" Тогда
			Возврат СтатусСтрока;
		КонецЕсли;
	Исключение
	КонецПопытки;
	// Fallback: Строка() возвращает русский синоним, ВРег() для надёжности
	СтатусСтрокаВерх = ВРег(Строка(Статус));
	Если Найти(СтатусСтрокаВерх, "ЗАФИКСИРОВАН") > 0 Тогда
		Возврат "Committed";
	ИначеЕсли Найти(СтатусСтрокаВерх, "ОТМЕНЕНА") > 0 Тогда
		Возврат "RolledBack";
	ИначеЕсли Найти(СтатусСтрокаВерх, "НЕТТРАНЗАКЦИИ") > 0
	       Или Найти(СтатусСтрокаВерх, "НЕТ ТРАНЗАКЦИИ") > 0 Тогда
		Возврат "NotApplicable";
	ИначеЕсли Найти(СтатусСтрокаВерх, "НЕЗАВЕРШЕНА") > 0
	       Или Найти(СтатусСтрокаВерх, "НЕ ЗАВЕРШЕНА") > 0 Тогда
		Возврат "Unfinished";
	КонецЕсли;
	Возврат "";
КонецФункции

&НаСервереБезКонтекста
Функция ПолучитьИмяУровня(Уровень)
	
	Если Уровень = УровеньЖурналаРегистрации.Информация Тогда
		Возврат "Information";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Предупреждение Тогда
		Возврат "Warning";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Ошибка Тогда
		Возврат "Error";
	ИначеЕсли Уровень = УровеньЖурналаРегистрации.Примечание Тогда
		Возврат "Note";
	Иначе
		Возврат Строка(Уровень);
	КонецЕсли;
	
КонецФункции

&НаСервереБезКонтекста
Функция ПрочитатьДатуИзISO(СтрокаДаты)
	
	Если Не ЗначениеЗаполнено(СтрокаДаты) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Попытка
		// Формат ISO 8601: YYYY-MM-DDTHH:MM:SS
		// Убираем возможный суффикс Z
		СтрокаДаты = СтрЗаменить(СтрокаДаты, "Z", "");
		
		Год = Число(Лев(СтрокаДаты, 4));
		Месяц = Число(Сред(СтрокаДаты, 6, 2));
		День = Число(Сред(СтрокаДаты, 9, 2));
		
		Час = 0;
		Минута = 0;
		Секунда = 0;
		
		Если СтрДлина(СтрокаДаты) >= 19 Тогда
			Час = Число(Сред(СтрокаДаты, 12, 2));
			Минута = Число(Сред(СтрокаДаты, 15, 2));
			Секунда = Число(Сред(СтрокаДаты, 18, 2));
		КонецЕсли;
		
		Возврат Дата(Год, Месяц, День, Час, Минута, Секунда);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// СОХРАНЕНИЕ И ЗАГРУЗКА НАСТРОЕК
// ─────────────────────────────────────────────────────────────────────────────────

&НаСервере
Процедура ЗагрузитьНастройки()
	
	// Загрузка адреса сервера из хранилища настроек
	Попытка
		СохраненныйАдрес = ХранилищеОбщихНастроек.Загрузить("MCPToolkit", "АдресСервера");
		Если СохраненныйАдрес <> Неопределено И Не ПустаяСтрока(СохраненныйАдрес) Тогда
			АдресСервера = СохраненныйАдрес;
		КонецЕсли;
	Исключение
		// Настройки не найдены или ошибка загрузки
	КонецПопытки;
	
	// Загрузка идентификатора канала из хранилища настроек
	Попытка
		СохранённыйКанал = ХранилищеОбщихНастроек.Загрузить("MCPToolkit", "ИдентификаторКанала");
		Если СохранённыйКанал <> Неопределено Тогда
			ИдентификаторКанала = СохранённыйКанал;
		КонецЕсли;
	Исключение
		// Настройки не найдены или ошибка загрузки
	КонецПопытки;

	// Загрузка формата ответов встроенного сервера (по умолчанию TOON = 1)
	Попытка
		СохранённыйФормат = ХранилищеОбщихНастроек.Загрузить("MCPToolkit", "ФорматОтветаВстроенный");
		Если СохранённыйФормат <> Неопределено Тогда
			ФорматОтветаВстроенный = СохранённыйФормат;
		Иначе
			ФорматОтветаВстроенный = 1; // TOON по умолчанию
		КонецЕсли;
	Исключение
		ФорматОтветаВстроенный = 1; // TOON по умолчанию
	КонецПопытки;

КонецПроцедуры

&НаСервереБезКонтекста
Процедура СохранитьНастройкиНаСервере(Адрес)
	
	// Сохранение адреса сервера в хранилище настроек
	Попытка
		ХранилищеОбщихНастроек.Сохранить("MCPToolkit", "АдресСервера", Адрес);
	Исключение
		// Ошибка сохранения настроек
	КонецПопытки;
	
КонецПроцедуры

&НаСервереБезКонтекста
Процедура СохранитьИдентификаторКаналаНаСервере(Канал)
	
	// Сохранение идентификатора канала в хранилище настроек
	Попытка
		ХранилищеОбщихНастроек.Сохранить("MCPToolkit", "ИдентификаторКанала", Канал);
	Исключение
		// Ошибка сохранения настроек
	КонецПопытки;
	
КонецПроцедуры

&НаКлиенте
Процедура ИдентификаторКаналаПриИзменении(Элемент)

	// Сохраняем при изменении
	СохранитьИдентификаторКаналаНаСервере(ИдентификаторКанала);

КонецПроцедуры

&НаСервереБезКонтекста
Процедура СохранитьФорматОтветаВстроенныйНаСервере(Формат)

	Попытка
		ХранилищеОбщихНастроек.Сохранить("MCPToolkit", "ФорматОтветаВстроенный", Формат);
	Исключение
		// Ошибка сохранения настроек
	КонецПопытки;

КонецПроцедуры

&НаКлиенте
Процедура ФорматОтветаВстроенныйПриИзменении(Элемент)

	СохранитьФорматОтветаВстроенныйНаСервере(ФорматОтветаВстроенный);

КонецПроцедуры

&НаКлиенте
Процедура СгенерироватьИдентификаторКанала(Команда)
	
	// Генерация нового UUID для идентификатора канала
	ИдентификаторКанала = Строка(Новый УникальныйИдентификатор());
	СохранитьИдентификаторКаналаНаСервере(ИдентификаторКанала);
	
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

// Соединяет элементы массива в строку через разделитель
// Замена СоединитьМассив() для совместимости с 8.2.13
&НаКлиентеНаСервереБезКонтекста
Функция СоединитьМассив(Массив, Разделитель = ", ")
	
	Если Массив = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	// Проверяем, является ли значение коллекцией
	Попытка
		Количество = Массив.Количество();
	Исключение
		// Если не коллекция, возвращаем как строку
		Возврат Строка(Массив);
	КонецПопытки;
	
	Если Количество = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	Первый = Истина;
	Для Каждого Элемент Из Массив Цикл
		Если Первый Тогда
			Первый = Ложь;
		Иначе
			Результат = Результат + Разделитель;
		КонецЕсли;
		Результат = Результат + Строка(Элемент);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет, является ли значение коллекцией (массив, фиксированный массив и т.п.)
&НаКлиентеНаСервереБезКонтекста
Функция ЭтоКоллекция(Значение)
	
	Если Значение = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Попытка
		Количество = Значение.Количество();
		Возврат Количество > 0;
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Процедура УстановитьСтатус(НовыйСтатус, НовоеСостояниеПодключения)
	
	Статус = НовыйСтатус;
	Подключено = НовоеСостояниеПодключения;
	
КонецПроцедуры

&НаКлиенте
Процедура ДобавитьВЛог(Сообщение)
	
	ВремяСообщения = Формат(ТекущаяДата(), "ДФ='HH:mm:ss'");
	НоваяСтрока = ВремяСообщения + " " + Сообщение;
	
	Если ПустаяСтрока(Лог) Тогда
		Лог = НоваяСтрока;
	Иначе
		Лог = НоваяСтрока + Символы.ПС + Лог;
	КонецЕсли;
	
	// Ограничение размера лога
	Если СтрДлина(Лог) > 70000 Тогда
		Лог = Лев(Лог, 70000);
	КонецЕсли;
	
КонецПроцедуры


// ─────────────────────────────────────────────────────────────────────────────────
// НАВИГАЦИОННЫЕ ССЫЛКИ
// ─────────────────────────────────────────────────────────────────────────────────

// Разбирает навигационную ссылку 1С и извлекает её компоненты
// Формат ссылки: e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
// Пример: e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка для разбора
//
// Возвращаемое значение:
//   Структура - с полями:
//     * ТипОбъекта - Строка - тип объекта (например, "Справочник", "Документ")
//     * ИмяОбъекта - Строка - имя объекта (например, "Контрагенты")
//     * HexGUID - Строка - шестнадцатеричный идентификатор (32 символа)
//
// Исключения:
//   Вызывает исключение с описательным сообщением при ошибке парсинга
//
&НаСервереБезКонтекста
Функция РазобратьНавигационнуюСсылку(НавигационнаяСсылка)
	
	// Проверка на пустую строку
	Если Не ЗначениеЗаполнено(НавигационнаяСсылка) Тогда
		ВызватьИсключение "Навигационная ссылка не может быть пустой / Navigation link cannot be empty";
	КонецЕсли;
	
	// Удаление пробелов по краям
	НавигационнаяСсылка = СокрЛП(НавигационнаяСсылка);
	
	// Проверка префикса e1cib/data/
	Префикс = "e1cib/data/";
	Если НРег(Лев(НавигационнаяСсылка, СтрДлина(Префикс))) <> НРег(Префикс) Тогда
		ВызватьИсключение "Неверный формат ссылки: должна начинаться с 'e1cib/data/' / Invalid link format: must start with 'e1cib/data/'";
	КонецЕсли;
	
	// Извлечение части после префикса
	ЧастьДанных = Сред(НавигационнаяСсылка, СтрДлина(Префикс) + 1);
	
	// Поиск параметра ref
	ПозицияВопроса = Найти(ЧастьДанных, "?");
	Если ПозицияВопроса = 0 Тогда
		ВызватьИсключение "Неверный формат ссылки: отсутствует параметр '?ref=' / Invalid link format: missing '?ref=' parameter";
	КонецЕсли;
	
	// Извлечение полного имени объекта (ТипОбъекта.ИмяОбъекта)
	ПолноеИмяОбъекта = Лев(ЧастьДанных, ПозицияВопроса - 1);
	
	// Проверка наличия точки в имени объекта
	ПозицияТочки = Найти(ПолноеИмяОбъекта, ".");
	Если ПозицияТочки = 0 Тогда
		ВызватьИсключение "Неверный формат имени объекта: ожидается 'ТипОбъекта.ИмяОбъекта', получено '" + ПолноеИмяОбъекта + "' / Invalid object name format: expected 'ObjectType.ObjectName', got '" + ПолноеИмяОбъекта + "'";
	КонецЕсли;
	
	// Извлечение типа и имени объекта
	ТипОбъекта = Лев(ПолноеИмяОбъекта, ПозицияТочки - 1);
	ИмяОбъекта = Сред(ПолноеИмяОбъекта, ПозицияТочки + 1);
	
	// Проверка что тип и имя не пустые
	Если Не ЗначениеЗаполнено(ТипОбъекта) Тогда
		ВызватьИсключение "Тип объекта не может быть пустым / Object type cannot be empty";
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ИмяОбъекта) Тогда
		ВызватьИсключение "Имя объекта не может быть пустым / Object name cannot be empty";
	КонецЕсли;
	
	// Извлечение параметров после ?
	ЧастьПараметров = Сред(ЧастьДанных, ПозицияВопроса + 1);
	
	// Поиск параметра ref=
	ПозицияRef = Найти(НРег(ЧастьПараметров), "ref=");
	Если ПозицияRef = 0 Тогда
		ВызватьИсключение "Неверный формат ссылки: отсутствует параметр 'ref=' / Invalid link format: missing 'ref=' parameter";
	КонецЕсли;
	
	// Извлечение HexGUID
	HexGUID = Сред(ЧастьПараметров, ПозицияRef + 4);
	
	// Удаление возможных дополнительных параметров после &
	ПозицияАмперсанда = Найти(HexGUID, "&");
	Если ПозицияАмперсанда > 0 Тогда
		HexGUID = Лев(HexGUID, ПозицияАмперсанда - 1);
	КонецЕсли;
	
	// Удаление пробелов
	HexGUID = СокрЛП(HexGUID);
	
	// Проверка длины HexGUID (должно быть 32 символа)
	Если СтрДлина(HexGUID) <> 32 Тогда
		ВызватьИсключение "Неверная длина HexGUID: ожидается 32 символа, получено " + СтрДлина(HexGUID) + " / Invalid HexGUID length: expected 32 characters, got " + СтрДлина(HexGUID);
	КонецЕсли;
	
	// Проверка что HexGUID содержит только шестнадцатеричные символы
	ДопустимыеСимволы = "0123456789abcdefABCDEF";
	Для Позиция = 1 По 32 Цикл
		Символ = Сред(HexGUID, Позиция, 1);
		Если Найти(ДопустимыеСимволы, Символ) = 0 Тогда
			ВызватьИсключение "HexGUID содержит недопустимый символ '" + Символ + "' в позиции " + Позиция + ". Допускаются только шестнадцатеричные символы (0-9, a-f, A-F) / HexGUID contains invalid character '" + Символ + "' at position " + Позиция + ". Only hexadecimal characters (0-9, a-f, A-F) are allowed";
		КонецЕсли;
	КонецЦикла;
	
	// Формирование результата
	Результат = Новый Структура;
	Результат.Вставить("ТипОбъекта", ТипОбъекта);
	Результат.Вставить("ИмяОбъекта", ИмяОбъекта);
	Результат.Вставить("HexGUID", НРег(HexGUID)); // Приводим к нижнему регистру для единообразия
	
	Возврат Результат;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КонвертироватьHexGUIDвUUID
// Преобразует 32-символьный HexGUID в стандартный формат UUID (8-4-4-4-12)
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   HexGUID - Строка - шестнадцатеричный идентификатор без дефисов (32 символа)
//                      Пример: "80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   Строка - UUID в формате 8-4-4-4-12 с дефисами
//            Пример: "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5"
//
// Исключения:
//   Вызывает исключение если длина HexGUID не равна 32 символам
//
&НаСервереБезКонтекста
Функция КонвертироватьHexGUIDвUUID(HexGUID)
	
	// Валидация длины входной строки
	Если СтрДлина(HexGUID) <> 32 Тогда
		ВызватьИсключение "Неверная длина HexGUID: ожидается 32 символа, получено " + СтрДлина(HexGUID) + " / Invalid HexGUID length: expected 32 characters, got " + СтрДлина(HexGUID);
	КонецЕсли;
	
	// HexGUID в навигационной ссылке 1С имеет особый порядок байтов!
	// Входной HexGUID: 80c6cc1a7e58902811ebcda8cb07c0f5
	// Нужно переставить байты для получения правильного UUID
	//
	// Формат HexGUID в ссылке: AABBCCDD EEFF GGHH IIJJ KKLLMMNNOOPP
	// Формат UUID в 1С:        DDCCBBAA FFEE HHGG IIJJ KKLLMMNNOOPP
	//
	// Первые 4 байта (8 символов) - reverse
	// Следующие 2 байта (4 символа) - reverse  
	// Следующие 2 байта (4 символа) - reverse
	// Остальные 8 байт (16 символов) - без изменений
	
	Часть1 = Сред(HexGUID, 7, 2) + Сред(HexGUID, 5, 2) + Сред(HexGUID, 3, 2) + Сред(HexGUID, 1, 2);
	Часть2 = Сред(HexGUID, 11, 2) + Сред(HexGUID, 9, 2);
	Часть3 = Сред(HexGUID, 15, 2) + Сред(HexGUID, 13, 2);
	Часть4 = Сред(HexGUID, 17, 4);
	Часть5 = Сред(HexGUID, 21, 12);
	
	UUID = Часть1 + "-" + Часть2 + "-" + Часть3 + "-" + Часть4 + "-" + Часть5;
	
	Возврат UUID;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КонвертироватьUUIDвHexGUID
// Преобразует UUID в формате 8-4-4-4-12 в 32-символьный HexGUID для навигационной ссылки
// Обратная операция к КонвертироватьHexGUIDвUUID
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   UUID - Строка - уникальный идентификатор в формате 8-4-4-4-12 с дефисами
//                   Пример: "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5"
//
// Возвращаемое значение:
//   Строка - HexGUID без дефисов (32 символа) для использования в навигационной ссылке
//            Пример: "1acc6c80589028e711ebcda8cb07c0f5"
//
// Примечание:
//   HexGUID в навигационной ссылке 1С имеет особый порядок байтов (обратный к UUID)
//
&НаСервереБезКонтекста
Функция КонвертироватьUUIDвHexGUID(UUID)
	
	// Удаляем дефисы из UUID
	УникальныйИдентификатор = СтрЗаменить(UUID, "-", "");
	
	// Валидация длины
	Если СтрДлина(УникальныйИдентификатор) <> 32 Тогда
		ВызватьИсключение "Неверная длина UUID: ожидается 32 символа без дефисов, получено " + СтрДлина(УникальныйИдентификатор);
	КонецЕсли;
	
	// Обратная операция к КонвертироватьHexGUIDвUUID
	// UUID формат:     AAAAAAAA-BBBB-CCCC-DDDD-EEEEEEEEEEEE
	// HexGUID формат:  DDDDEEEEEEEEEEEE CCCC BBBB AAAAAAAA
	//
	// Переставляем части в обратном порядке
	
	Часть1 = Сред(УникальныйИдентификатор, 1, 8);   // AAAAAAAA
	Часть2 = Сред(УникальныйИдентификатор, 9, 4);   // BBBB
	Часть3 = Сред(УникальныйИдентификатор, 13, 4);  // CCCC
	Часть4 = Сред(УникальныйИдентификатор, 17, 4);  // DDDD
	Часть5 = Сред(УникальныйИдентификатор, 21, 12); // EEEEEEEEEEEE
	
	// HexGUID = DDDD + EEEEEEEEEEEE + CCCC + BBBB + AAAAAAAA
	HexGUID = Часть4 + Часть5 + Часть3 + Часть2 + Часть1;
	
	Возврат НРег(HexGUID); // Приводим к нижнему регистру для единообразия
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// СформироватьНавигационнуюСсылку
// Формирует навигационную ссылку 1С по описанию объекта
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ОписаниеОбъекта - Структура - описание объекта с полями:
//     * _objectRef - Булево - признак описания объекта (должен быть true)
//     * УникальныйИдентификатор - Строка - UUID объекта
//     * ТипОбъекта - Строка - тип объекта (например, "СправочникСсылка.Контрагенты")
//
// Возвращаемое значение:
//   Строка - навигационная ссылка в формате e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//            Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Исключения:
//   Вызывает исключение если описание объекта некорректно
//
&НаСервереБезКонтекста
Функция СформироватьНавигационнуюСсылку(ОписаниеОбъекта)
	
	// Проверка что это описание объекта
	Если ТипЗнч(ОписаниеОбъекта) <> Тип("Структура") Тогда
		ВызватьИсключение "ОписаниеОбъекта должно быть структурой / objectDescription must be a structure";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("_objectRef") Или ОписаниеОбъекта._objectRef <> Истина Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует _objectRef = true / Invalid object description: missing _objectRef = true";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("УникальныйИдентификатор") Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует УникальныйИдентификатор / Invalid object description: missing УникальныйИдентификатор";
	КонецЕсли;
	
	Если Не ОписаниеОбъекта.Свойство("ТипОбъекта") Тогда
		ВызватьИсключение "Некорректное описание объекта: отсутствует ТипОбъекта / Invalid object description: missing ТипОбъекта";
	КонецЕсли;
	
	// Преобразуем тип объекта из формата "СправочникСсылка.Контрагенты" в "Справочник.Контрагенты"
	ТипОбъекта = ОписаниеОбъекта.ТипОбъекта;
	
	// Убираем "Ссылка" из типа
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "СправочникСсылка.", "Справочник.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ДокументСсылка.", "Документ.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПеречислениеСсылка.", "Перечисление.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланВидовХарактеристикСсылка.", "ПланВидовХарактеристик.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланСчетовСсылка.", "ПланСчетов.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланВидовРасчетаСсылка.", "ПланВидовРасчета.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "БизнесПроцессСсылка.", "БизнесПроцесс.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ЗадачаСсылка.", "Задача.");
	ТипОбъекта = СтрЗаменить(ТипОбъекта, "ПланОбменаСсылка.", "ПланОбмена.");
	
	// Конвертируем UUID в HexGUID
	HexGUID = КонвертироватьUUIDвHexGUID(ОписаниеОбъекта.УникальныйИдентификатор);
	
	// Формируем навигационную ссылку
	НавигационнаяСсылка = "e1cib/data/" + ТипОбъекта + "?ref=" + HexGUID;
	
	Возврат НавигационнаяСсылка;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьНавигационнуюСсылкуПоОписанию
// Обёртка для формирования навигационной ссылки с обработкой ошибок
// Используется в MCP-инструменте get_link_of_object
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ОписаниеОбъекта - Структура - описание объекта из результатов execute_query
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * link    - Строка - навигационная ссылка (при success = Истина)
//     * error   - Строка - описание ошибки (при success = Ложь)
//
&НаСервереБезКонтекста
Функция ПолучитьНавигационнуюСсылкуПоОписанию(ОписаниеОбъекта)
	
	Попытка
		
		НавигационнаяСсылка = СформироватьНавигационнуюСсылку(ОписаниеОбъекта);
		
		Возврат Новый Структура("success, data", Истина, НавигационнаяСсылка);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ВерсияПлатформыНеМеньше
// Проверяет, что версия текущей платформы не меньше указанной минимальной версии
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   МинимальнаяВерсия - Строка - минимальная требуемая версия платформы
//                                Пример: "8.3.3" или "8.2.13"
//
// Возвращаемое значение:
//   Булево - Истина, если текущая версия платформы >= минимальной версии
//            Ложь, если текущая версия платформы < минимальной версии
//
// Примечание:
//   Сравнение выполняется покомпонентно (8.3.25.1374 -> [8, 3, 25, 1374])
//   Не использует СтрРазделить для совместимости с 8.2.13
//
&НаСервереБезКонтекста
Функция ВерсияПлатформыНеМеньше(МинимальнаяВерсия)
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	ВерсияПлатформы = СистемнаяИнформация.ВерсияПриложения;
	
	// Разбор версий в массивы компонентов
	// Не используем СтрРазделить для совместимости с 8.2.13
	ЧастиТекущей = РазделитьСтрокуПоРазделителю(ВерсияПлатформы, ".");
	ЧастиМинимальной = РазделитьСтрокуПоРазделителю(МинимальнаяВерсия, ".");
	
	// Определяем минимальное количество компонентов для сравнения
	КоличествоТекущей = ЧастиТекущей.Количество();
	КоличествоМинимальной = ЧастиМинимальной.Количество();
	
	Если КоличествоТекущей < КоличествоМинимальной Тогда
		МинимальноеКоличество = КоличествоТекущей;
	Иначе
		МинимальноеКоличество = КоличествоМинимальной;
	КонецЕсли;
	
	// Сравнение версий по компонентам
	Для Индекс = 0 По МинимальноеКоличество - 1 Цикл
		ТекущаяЧасть = Число(ЧастиТекущей[Индекс]);
		МинимальнаяЧасть = Число(ЧастиМинимальной[Индекс]);
		
		Если ТекущаяЧасть > МинимальнаяЧасть Тогда
			Возврат Истина;
		ИначеЕсли ТекущаяЧасть < МинимальнаяЧасть Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	// Все сравниваемые компоненты равны
	Возврат Истина;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// РазделитьСтрокуПоРазделителю
// Разделяет строку на массив подстрок по указанному разделителю
// Совместимость: 1С:Предприятие 8.2.13+ (замена СтрРазделить)
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Строка - Строка - исходная строка для разделения
//   Разделитель - Строка - символ-разделитель
//
// Возвращаемое значение:
//   Массив - массив подстрок
//
&НаСервереБезКонтекста
Функция РазделитьСтрокуПоРазделителю(Строка, Разделитель)
	
	Результат = Новый Массив;
	ОстатокСтроки = Строка;
	
	ПозицияРазделителя = Найти(ОстатокСтроки, Разделитель);
	
	Пока ПозицияРазделителя > 0 Цикл
		Часть = Лев(ОстатокСтроки, ПозицияРазделителя - 1);
		Результат.Добавить(Часть);
		ОстатокСтроки = Сред(ОстатокСтроки, ПозицияРазделителя + СтрДлина(Разделитель));
		ПозицияРазделителя = Найти(ОстатокСтроки, Разделитель);
	КонецЦикла;
	
	// Добавляем последнюю часть (или всю строку, если разделитель не найден)
	Результат.Добавить(ОстатокСтроки);
	
	Возврат Результат;
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// НайтиОбъектВручную
// Находит объект 1С по навигационной ссылке без использования встроенного метода
// НайтиПоНавигационнойСсылке (для платформ < 8.3.3)
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка в формате
//                                  e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//                                  Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   СправочникСсылка, ДокументСсылка и т.д. - ссылка на найденный объект
//   Неопределено - если объект не найден
//
// Исключения:
//   Вызывает исключение при неверном формате ссылки или неподдерживаемом типе объекта
//
// Требования: 4.2
//
&НаСервереБезКонтекста
Функция НайтиОбъектВручную(НавигационнаяСсылка)

	// Парсинг навигационной ссылки с использованием существующей функции
	// Возвращает структуру с полями: ТипОбъекта, ИмяОбъекта, HexGUID
	РезультатПарсинга = РазобратьНавигационнуюСсылку(НавигационнаяСсылка);

	ТипОбъекта = РезультатПарсинга.ТипОбъекта;
	ИмяОбъекта = РезультатПарсинга.ИмяОбъекта;
	HexGUID = РезультатПарсинга.HexGUID;

	// Формируем полное имя типа для получения пустой ссылки
	ПолноеИмяТипа = ТипОбъекта + "." + ИмяОбъекта;

	// Получаем пустую ссылку нужного типа через предопределённое значение
	ПустаяСсылка = ПредопределенноеЗначение(ПолноеИмяТипа + ".ПустаяСсылка");

	// Преобразуем пустую ссылку во внутреннее строковое представление
	// Шаблон содержит строку с 32 нулями вместо GUID
	Шаблон = ЗначениеВСтрокуВнутр(ПустаяСсылка);

	// Заменяем нули на HexGUID из навигационной ссылки
	Значение = СтрЗаменить(Шаблон, "00000000000000000000000000000000", HexGUID);

	// Преобразуем обратно в ссылку 1С
	Возврат ЗначениеИзСтрокиВнутр(Значение);

КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьСсылкуПоТипуИUUID
// Получает ссылку на объект 1С по типу объекта, имени и UUID
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   ТипОбъекта - Строка - тип объекта метаданных (Справочник, Документ и т.д.)
//                         Поддерживаются русские и английские имена типов
//   ИмяОбъекта - Строка - имя объекта метаданных (например, "Контрагенты")
//   UUID       - Строка - уникальный идентификатор в формате 8-4-4-4-12
//
// Возвращаемое значение:
//   СправочникСсылка, ДокументСсылка и т.д. - ссылка на объект
//
// Поддерживаемые типы объектов:
//   Русские: Справочник, Документ, ПланВидовХарактеристик, ПланСчетов,
//            ПланВидовРасчета, ПланОбмена, БизнесПроцесс, Задача
//   Английские: Catalog, Document, ChartOfCharacteristicTypes, ChartOfAccounts,
//               ChartOfCalculationTypes, ExchangePlan, BusinessProcess, Task
//
// Исключения:
//   Вызывает исключение при неподдерживаемом типе объекта
//
// Требования: 4.3, 6.2
//
&НаСервереБезКонтекста
Функция ПолучитьСсылкуПоТипуИUUID(ТипОбъекта, ИмяОбъекта, UUID)
	
	УникальныйИдентификатор = Новый УникальныйИдентификатор(UUID);
	
	Если ТипОбъекта = "Справочник" Или ТипОбъекта = "Catalog" Тогда
		Возврат Справочники[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "Документ" Или ТипОбъекта = "Document" Тогда
		Возврат Документы[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланВидовХарактеристик" Или ТипОбъекта = "ChartOfCharacteristicTypes" Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланСчетов" Или ТипОбъекта = "ChartOfAccounts" Тогда
		Возврат ПланыСчетов[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланВидовРасчета" Или ТипОбъекта = "ChartOfCalculationTypes" Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "БизнесПроцесс" Или ТипОбъекта = "BusinessProcess" Тогда
		Возврат БизнесПроцессы[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "Задача" Или ТипОбъекта = "Task" Тогда
		Возврат Задачи[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	ИначеЕсли ТипОбъекта = "ПланОбмена" Или ТипОбъекта = "ExchangePlan" Тогда
		Возврат ПланыОбмена[ИмяОбъекта].ПолучитьСсылку(УникальныйИдентификатор);
		
	Иначе
		ВызватьИсключение "Неподдерживаемый тип объекта: " + ТипОбъекта + ". "
			+ "Поддерживаемые типы: Справочник (Catalog), Документ (Document), "
			+ "ПланВидовХарактеристик (ChartOfCharacteristicTypes), ПланСчетов (ChartOfAccounts), "
			+ "ПланВидовРасчета (ChartOfCalculationTypes), ПланОбмена (ExchangePlan), "
			+ "БизнесПроцесс (BusinessProcess), Задача (Task)";
	КонецЕсли;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьДанныеОбъекта
// Получает все данные объекта 1С (реквизиты и табличные части) по ссылке
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Ссылка - СправочникСсылка, ДокументСсылка и т.д. - ссылка на объект 1С
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * data    - Структура - данные объекта (при success = Истина):
//       * _type         - Строка - полное имя типа объекта (например, "Справочник.Контрагенты")
//       * _presentation - Строка - строковое представление ссылки
//       * Код           - Строка - код объекта (если есть)
//       * Наименование  - Строка - наименование объекта (если есть)
//       * Дата          - Дата - дата документа (если есть)
//       * Номер         - Строка - номер документа (если есть)
//       * <Реквизит>    - Произвольный - значения пользовательских реквизитов
//       * <ТабличнаяЧасть> - Массив - строки табличных частей
//     * error   - Строка - описание ошибки (при success = Ложь)
//
// Требования: 5.1, 5.2, 5.3, 5.4, 5.5
//
&НаСервереБезКонтекста
Функция ПолучитьДанныеОбъекта(Ссылка)
	
	Попытка
		Объект = Ссылка.ПолучитьОбъект();
		
		Если Объект = Неопределено Тогда
			// Отладка: показываем информацию о ссылке
			Возврат Новый Структура("success, error, debug", Ложь, 
				"Объект не найден или недостаточно прав доступа / Object not found or insufficient access rights",
				Новый Структура("СсылкаСтрока, СсылкаПустая", Строка(Ссылка), Ссылка.Пустая()));
		КонецЕсли;
		
		ДанныеОбъекта = Новый Структура;
		МетаданныеОбъекта = Ссылка.Метаданные();
		
		// Базовая информация
		ДанныеОбъекта.Вставить("_type", МетаданныеОбъекта.ПолноеИмя());
		ДанныеОбъекта.Вставить("_presentation", Строка(Ссылка));
		
		// Стандартные реквизиты (Код, Наименование, Дата, Номер)
		// Используем Попытка/Исключение, т.к. не все объекты имеют эти реквизиты
		Попытка
			ДанныеОбъекта.Вставить("Код", Объект.Код);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Наименование", Объект.Наименование);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Дата", Объект.Дата);
		Исключение
		КонецПопытки;
		
		Попытка
			ДанныеОбъекта.Вставить("Номер", Объект.Номер);
		Исключение
		КонецПопытки;
		
		// Пользовательские реквизиты из метаданных
		Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
			Значение = Объект[Реквизит.Имя];
			ДанныеОбъекта.Вставить(Реквизит.Имя, ПреобразоватьЗначениеДляJSON(Значение));
		КонецЦикла;
		
		// Табличные части
		Для Каждого ТабличнаяЧасть Из МетаданныеОбъекта.ТабличныеЧасти Цикл
			МассивСтрок = Новый Массив;
			
			Для Каждого СтрокаТЧ Из Объект[ТабличнаяЧасть.Имя] Цикл
				ДанныеСтроки = Новый Структура;
				ДанныеСтроки.Вставить("НомерСтроки", СтрокаТЧ.НомерСтроки);
				
				Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
					Значение = СтрокаТЧ[Реквизит.Имя];
					ДанныеСтроки.Вставить(Реквизит.Имя, ПреобразоватьЗначениеДляJSON(Значение));
				КонецЦикла;
				
				МассивСтрок.Добавить(ДанныеСтроки);
			КонецЦикла;
			
			ДанныеОбъекта.Вставить(ТабличнаяЧасть.Имя, МассивСтрок);
		КонецЦикла;
		
		Возврат Новый Структура("success, data", Истина, ДанныеОбъекта);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПреобразоватьЗначениеДляJSON
// Преобразует значение 1С в формат, совместимый с JSON
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   Значение - Произвольный - значение для преобразования
//
// Возвращаемое значение:
//   Произвольный - преобразованное значение:
//     * Ссылки (СправочникСсылка, ДокументСсылка и т.д.) -> Строка (представление)
//     * Дата -> Дата (без изменений, JSON сериализатор обработает)
//     * Строка, Число, Булево -> без изменений
//     * Неопределено -> Неопределено (JSON сериализатор преобразует в null)
//     * Прочие типы -> Строка (строковое представление)
//
// Требования: 5.4
//
&НаСервереБезКонтекста
Функция ПреобразоватьЗначениеДляJSON(Значение)
	
	// Неопределено -> оставляем как есть (JSON сериализатор преобразует в null)
	Если Значение = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТипЗначения = ТипЗнч(Значение);
	
	// Примитивные типы - оставляем без изменений
	Если ТипЗначения = Тип("Строка") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Булево") Тогда
		Возврат Значение;
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		// Дата - оставляем как есть, JSON сериализатор обработает
		Возврат Значение;
	КонецЕсли;
	
	// Проверка на ссылочные типы
	// Ссылки имеют метод Пустая() и Метаданные()
	Попытка
		Если Значение.Пустая() Тогда
			// Пустая ссылка - возвращаем пустую строку
			Возврат "";
		КонецЕсли;
		// Непустая ссылка - возвращаем строковое представление
		Возврат Строка(Значение);
	Исключение
		// Не ссылочный тип - продолжаем проверку
	КонецПопытки;
	
	// Перечисления - преобразуем в строку
	ОписаниеТипа = Строка(ТипЗначения);
	Если Найти(ОписаниеТипа, "ПеречислениеСсылка") > 0 Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
	// ФиксированныйМассив - преобразуем в обычный Массив
	Если ТипЗначения = Тип("ФиксированныйМассив") Тогда
		РезультатМассив = Новый Массив;
		Для Каждого Элемент Из Значение Цикл
			РезультатМассив.Добавить(ПреобразоватьЗначениеДляJSON(Элемент));
		КонецЦикла;
		Возврат РезультатМассив;
	КонецЕсли;
	
	// ОписаниеЗащитыОтОпасныхДействий (UnsafeOperationProtectionDescription) -> Булево
	// Возвращаем флаг ПредупреждатьОбОпасныхДействиях, чтобы в JSON было true/false
	Если ОписаниеТипа = "ОписаниеЗащитыОтОпасныхДействий" Тогда
		Попытка
			Возврат Значение.ПредупреждатьОбОпасныхДействиях;
		Исключение
			Возврат Строка(Значение);
		КонецПопытки;
	КонецЕсли;
	
	// Все остальные типы - преобразуем в строку
	Возврат Строка(Значение);
	
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// ПолучитьОбъектПоНавигационнойСсылке
// Главная функция для получения данных объекта 1С по навигационной ссылке
// Совместимость: 1С:Предприятие 8.2.13+
// ─────────────────────────────────────────────────────────────────────────────────
//
// Параметры:
//   НавигационнаяСсылка - Строка - навигационная ссылка в формате
//                                  e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID
//                                  Пример: "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
//
// Возвращаемое значение:
//   Структура - результат операции:
//     * success - Булево - признак успешного выполнения
//     * data    - Структура - данные объекта (при success = Истина):
//       * _type         - Строка - полное имя типа объекта
//       * _presentation - Строка - строковое представление ссылки
//       * <Реквизиты>   - Произвольный - значения реквизитов объекта
//       * <ТабличныеЧасти> - Массив - строки табличных частей
//     * error   - Строка - описание ошибки (при success = Ложь)
//
// Алгоритм работы:
//   1. Использует ручной парсинг через НайтиОбъектВручную (универсальный метод)
//   2. Получает данные объекта через ПолучитьДанныеОбъекта
//   3. Обрабатывает ошибки и возвращает результат в стандартном формате
//
// Примечание:
//   Встроенный метод НайтиПоНавигационнойСсылке недоступен в контексте
//   &НаСервереБезКонтекста, поэтому используется универсальный ручной парсинг,
//   который работает на всех версиях платформы и во всех контекстах.
//
// Требования: 3.2, 3.3, 6.3, 6.4
//
&НаСервереБезКонтекста
Функция ПолучитьОбъектПоНавигационнойСсылке(НавигационнаяСсылка)
	
	Попытка
		// Парсинг ссылки для отладки
		РезультатПарсинга = РазобратьНавигационнуюСсылку(НавигационнаяСсылка);
		ТипОбъекта = РезультатПарсинга.ТипОбъекта;
		ИмяОбъекта = РезультатПарсинга.ИмяОбъекта;
		HexGUID = РезультатПарсинга.HexGUID;

		// Используем метод через внутреннее представление ссылки
		Ссылка = НайтиОбъектВручную(НавигационнаяСсылка);

		// Проверка результата поиска
		Если Ссылка = Неопределено Тогда
			Возврат Новый Структура("success, error, debug", Ложь,
				"Объект не найден по указанной ссылке / Object not found by specified link",
				Новый Структура("ТипОбъекта, ИмяОбъекта, HexGUID", ТипОбъекта, ИмяОбъекта, HexGUID));
		КонецЕсли;

		// Проверка на пустую ссылку
		Попытка
			Если Ссылка.Пустая() Тогда
				Возврат Новый Структура("success, error, debug", Ложь,
					"Ссылка пустая / Reference is empty",
					Новый Структура("ТипОбъекта, ИмяОбъекта, HexGUID", ТипОбъекта, ИмяОбъекта, HexGUID));
			КонецЕсли;
		Исключение
			// Если метод Пустая() недоступен, продолжаем
		КонецПопытки;

		// Получение данных объекта
		Возврат ПолучитьДанныеОбъекта(Ссылка);
		
	Исключение
		Возврат Новый Структура("success, error", Ложь, ОписаниеОшибки());
	КонецПопытки;
	
КонецФункции


// ═══════════════════════════════════════════════════════════════════════════════
// JSON ПАРСЕР И СЕРИАЛИЗАТОР
// Встроенный модуль для совместимости с режимом 8.2.13
// Основан на модуле Александра Переверзева (MIT License)
// ═══════════════════════════════════════════════════════════════════════════════

// JSON парсер
&НаКлиентеНаСервереБезКонтекста
Функция ПрочитатьJSON2(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь)
	
	Возврат jsonПрочитатьИнициализация(Значение, Стандарт, ПредставленияСсылок);
	
КонецФункции

// JSON сериализатор
&НаКлиентеНаСервереБезКонтекста
Функция ЗаписатьJSON2(Значение, Стандарт = Истина, ПредставленияСсылок = Ложь)

	Возврат jsonЗаписатьИнициализация(Значение, Стандарт, ПредставленияСсылок);

КонецФункции

// Нормализация параметра-массива: строка вида ["X","Y"] → Массив.
// REST- или MCP-клиент может передать JSON-массив сериализованным в строку.
// Python-прокси обрабатывал это через Pydantic; здесь делаем то же самое.
&НаКлиентеНаСервереБезКонтекста
Функция НормализоватьМассивПараметра(Значение)

	Если ТипЗнч(Значение) = Тип("Строка") И Лев(СокрЛП(Значение), 1) = "[" Тогда
		Попытка
			Разобранный = ПрочитатьJSON2(Значение);
			Если ТипЗнч(Разобранный) = Тип("Массив") Тогда
				Возврат Разобранный;
			КонецЕсли;
		Исключение
			// Оставляем как есть — ошибка выйдет позднее с понятным сообщением
		КонецПопытки;
	КонецЕсли;

	Возврат Значение;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// НАСТРОЙКИ JSON
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре()
	Возврат Истина;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаПолноеМаскированиеСимволов()
	Возврат Истина;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаМаскированиеКириллицы()
	Возврат Ложь;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НастройкаНеявноеПриведениеПримитивныхЗначенийКлюча()
	Возврат Ложь;
КонецФункции


// ─────────────────────────────────────────────────────────────────────────────────
// JSON ПАРСЕР
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	Альтернативный = (Стандарт = Неопределено) Или (Не Стандарт);
	Стандарт = (Стандарт = Неопределено) Или Стандарт;
	ПредставленияСсылок = (ПредставленияСсылок = Неопределено) Или ПредставленияСсылок;
	
	// Схема подстановок шестнадцатиричной системы
	СхемаПодстановок = Новый Соответствие;
	ШестнадцатиричнаяСистема = "0123456789abcdef";
	ДесятичноеЧисло = 0;
	Для ВторойРазряд = 1 По 16 Цикл
		Для ПервыйРазряд = 1 По 16 Цикл
			СхемаПодстановок.Вставить(Сред(ШестнадцатиричнаяСистема, ВторойРазряд, 1) + Сред(ШестнадцатиричнаяСистема, ПервыйРазряд, 1), ДесятичноеЧисло);
			ДесятичноеЧисло = ДесятичноеЧисло + 1;
		КонецЦикла;
	КонецЦикла;
	
	ВспомогательныеДанные = Новый Структура("ТипСтроки,СхемаПодстановок,АвтоматическиПриводитьКСтруктуре",
		Тип("Строка"),
		СхемаПодстановок,
		(НастройкаАвтоматическоеПриведениеОбъектаКСтруктуре() = Истина));
	
	Индекс = 1;
	Длина = СтрДлина(Значение);
	СимволыФорматирования = " " + Символы.ВК + Символы.ПС + Символы.Таб;
	
	Если Стандарт Тогда
		jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
	КонецЕсли;
	
	Если (Индекс > Длина) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Истина);
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования)
	Пока (Индекс <= Длина) И Найти(СимволыФорматирования, Сред(Значение, Индекс, 1)) Цикл
		Индекс = Индекс + 1;
	КонецЦикла;
КонецПроцедуры


&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, ПервыйУровень)
	
	Символ = Сред(Значение, Индекс, 1);
	
	Если (Символ = """") Или (Символ = "'") Тогда
		// Строка
		Начало = Индекс;
		Пока Истина Цикл
			Подстрока = Сред(Значение, Индекс + 1, 384);
			Позиция = Найти(Подстрока, Символ);
			
			Если (Позиция > 0) Тогда
				Индекс = Индекс + Позиция;
				Откат = Индекс - 1;
				Маскировка = Ложь;
				Пока (Сред(Значение, Откат, 1) = "\") И Откат Цикл
					Маскировка = Не Маскировка;
					Откат = Откат - 1;
				КонецЦикла;
				Если НЕ Маскировка Тогда
					Прервать;
				КонецЕсли;
			Иначе
				Индекс = Индекс + 384;
				Если Индекс >= Длина Тогда
					Возврат Неопределено;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Результат = jsonПрочитатьСтроку(Сред(Значение, Начало + 1, Индекс - Начало - 1), Стандарт, Начало, ВспомогательныеДанные.СхемаПодстановок, (Символ = "'"));
		Индекс = Индекс + 1;
		
	ИначеЕсли (Символ = "[") Тогда
		// Массив
		Результат = Новый Массив;
		Индекс = Индекс + 1;
		Если Стандарт Тогда
			jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
		КонецЕсли;
		
		Символ = Сред(Значение, Индекс, 1);
		Если (Символ = "]") Тогда
			Индекс = Индекс + 1;
		Иначе
			Пока (Индекс <= Длина) Цикл
				Результат.Добавить(jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь));
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "]") Тогда
					Индекс = Индекс + 1;
					Прервать;
				ИначеЕсли (Символ = ",") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	ИначеЕсли (Символ = "{") Тогда
		// Объект
		Индекс = Индекс + 1;
		Если Стандарт Тогда
			jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
		КонецЕсли;
		
		Символ = Сред(Значение, Индекс, 1);
		Если (Символ = "}") Тогда
			Индекс = Индекс + 1;
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				Результат = Новый Структура;
			Иначе
				Результат = Новый Соответствие;
			КонецЕсли;
		Иначе
			Результат = Новый Соответствие;
			ТипСтроки = ВспомогательныеДанные.ТипСтроки;
			
			Пока (Индекс <= Длина) Цикл
				КлючЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = ":") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
				
				ЗначениеЭлемента = jsonПрочитать(Значение, Стандарт, Альтернативный, ПредставленияСсылок, Индекс, Длина, ВспомогательныеДанные, СимволыФорматирования, Ложь);
				Результат.Вставить(КлючЭлемента, ЗначениеЭлемента);
				
				Символ = Сред(Значение, Индекс, 1);
				Если (Символ = "}") Тогда
					Индекс = Индекс + 1;
					Прервать;
				ИначеЕсли (Символ = ",") Тогда
					Индекс = Индекс + 1;
					Если Стандарт Тогда
						jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
					КонецЕсли;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			// Преобразование в структуру
			Если ВспомогательныеДанные.АвтоматическиПриводитьКСтруктуре Тогда
				РезультатСтруктура = Новый Структура;
				Для Каждого Элемент Из Результат Цикл
					Попытка
						РезультатСтруктура.Вставить(Элемент.Ключ, Элемент.Значение);
					Исключение
						РезультатСтруктура = Результат;
						Прервать;
					КонецПопытки;
				КонецЦикла;
				Результат = РезультатСтруктура;
			КонецЕсли;
		КонецЕсли;
		
	Иначе
		// Примитивные типы
		Если (Символ = "n") Тогда
			Если (Сред(Значение, Индекс, 4) = "null") Тогда
				Индекс = Индекс + 4;
				Результат = Null;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли (Символ = "t") Тогда
			Если (Сред(Значение, Индекс, 4) = "true") Тогда
				Индекс = Индекс + 4;
				Результат = Истина;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		ИначеЕсли (Символ = "f") Тогда
			Если (Сред(Значение, Индекс, 5) = "false") Тогда
				Индекс = Индекс + 5;
				Результат = Ложь;
			Иначе
				Результат = Неопределено;
			КонецЕсли;
		Иначе
			// Число
			Начало = Индекс;
			Пока Найти("-+0123456789.eE", Символ) И (Индекс <= Длина) Цикл
				Индекс = Индекс + 1;
				Символ = Сред(Значение, Индекс, 1);
			КонецЦикла;
			
			Попытка
				Результат = Число(Сред(Значение, Начало, Индекс - Начало));
			Исключение
				Результат = 0;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Если Стандарт Тогда
		jsonПрочитатьПропуститьФорматирование(Значение, Стандарт, Индекс, Длина, СимволыФорматирования);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonПрочитатьСтроку(Значение, Стандарт, Индекс, СхемаПодстановок, ОдинарнаяКавычка)
	
	ПоследоавтельностьПеремаскировки = "\" + Символ(65535);
	
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение,
		"\\", ПоследоавтельностьПеремаскировки),
		"\/", "/"),
		"\b", Символ(008)),
		"\t", Символы.Таб),
		"\n", Символы.ПС),
		"\f", Символы.ПФ),
		"\r", Символы.ВК),
		"\""", """");
	
	// Демаскирование Юникод символов
	Позиция = Найти(Результат, "\u");
	Пока Позиция Цикл
		СтаршийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 2, 2))];
		МладшийБайт = СхемаПодстановок[НРег(Сред(Результат, Позиция + 4, 2))];
		Если (СтаршийБайт = Неопределено) Или (МладшийБайт = Неопределено) Тогда
			Прервать;
		КонецЕсли;
		Результат = СтрЗаменить(Результат, Сред(Результат, Позиция, 6), Символ(256 * СтаршийБайт + МладшийБайт));
		Позиция = Найти(Результат, "\u");
	КонецЦикла;
	
	Если ОдинарнаяКавычка Тогда
		Результат = СтрЗаменить(Результат, "\'", "'");
	КонецЕсли;
	
	Возврат СтрЗаменить(Результат, ПоследоавтельностьПеремаскировки, "\");
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// JSON СЕРИАЛИЗАТОР
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписатьИнициализация(Значение, Знач Стандарт, Знач ПредставленияСсылок)
	
	ВспомогательныеДанные = Новый Структура("ПримитивныеТипы,Массивы,Структуры,Соответсвия,ТипДопустимыхКлючей",
		Новый ОписаниеТипов("Null,Булево,Число,Дата,УникальныйИдентификатор"),
		Новый ОписаниеТипов("Массив,ФиксированныйМассив"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура"),
		Новый ОписаниеТипов("Структура,ФиксированнаяСтруктура,Соответствие,ФиксированноеСоответствие"),
		Новый ОписаниеТипов("Строка"));
	
	Если Стандарт Тогда
		Смещение = "";
		Отступ = " ";
		Табуляция = "    ";
		ПереносСтроки = Символы.ПС;
	Иначе
		Смещение = "";
		Отступ = "";
		Табуляция = "";
		ПереносСтроки = "";
	КонецЕсли;
	
	Возврат jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, Смещение, Отступ, Табуляция, ПереносСтроки, (НастройкаПолноеМаскированиеСимволов() = Истина), (НастройкаМаскированиеКириллицы() = Истина));
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписать(Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Колонки, Смещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	Тип = ТипЗнч(Значение);
	
	// Строка
	Если (Тип = Тип("Строка")) Тогда
		Возврат jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	КонецЕсли;
	
	// Неопределено и примитивные типы
	Если ВспомогательныеДанные.ПримитивныеТипы.СодержитТип(Тип) Тогда
		Если (Значение = Null) Или (Значение = Неопределено) Тогда
			Возврат "null";
		ИначеЕсли (Тип = Тип("Дата")) Тогда
			Возврат """" + Формат(Значение, "ДФ=yyyy-MM-ddTHH:mm:ss; ДП=") + "Z""";
		ИначеЕсли (Тип = Тип("УникальныйИдентификатор")) Тогда
			Возврат """" + Значение + """";
		Иначе
			Возврат Формат(Значение, "ЧРД=.; ЧН=; ЧГ=; БЛ=false; БИ=true");
		КонецЕсли;
	КонецЕсли;
	
	// Структуры
	Если ВспомогательныеДанные.Структуры.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + """" + Элемент.Ключ + """:" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
		Иначе
			Возврат "{}";
		КонецЕсли;
	КонецЕсли;
	
	// Соответствия
	Если ВспомогательныеДанные.Соответсвия.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			ТипДопустимыхКлючей = ВспомогательныеДанные.ТипДопустимыхКлючей;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Ключ = Элемент.Ключ;
				Если ТипДопустимыхКлючей.СодержитТип(ТипЗнч(Ключ)) Тогда
					Ключ = jsonЗаписатьСтроку(Строка(Ключ), ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				Иначе
					Ключ = """" + Ключ + """";
				КонецЕсли;
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + Ключ + ":" + Отступ + jsonЗаписать(Элемент.Значение, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "{" + Результат + ПереносСтроки + Смещение + "}";
		Иначе
			Возврат "{}";
		КонецЕсли;
	КонецЕсли;
	
	// Массивы
	Если ВспомогательныеДанные.Массивы.СодержитТип(Тип) Тогда
		Если Значение.Количество() Тогда
			СледующееСмещение = Смещение + Табуляция;
			Первый = Истина;
			Для Каждого Элемент Из Значение Цикл
				Если Первый Тогда
					Результат = ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
					Первый = Ложь;
				Иначе
					Результат = Результат + "," + ПереносСтроки + СледующееСмещение + jsonЗаписать(Элемент, Стандарт, ПредставленияСсылок, ВспомогательныеДанные, Неопределено, СледующееСмещение, Отступ, Табуляция, ПереносСтроки, ПолноеМаскированиеСимволов, МаскированиеКириллицы);
				КонецЕсли;
			КонецЦикла;
			Возврат "[" + Результат + ПереносСтроки + Смещение + "]";
		Иначе
			Возврат "[]";
		КонецЕсли;
	КонецЕсли;
	
	// Неподдерживаемые типы - преобразование в строку
	Возврат jsonЗаписатьСтроку(Строка(Значение), ПолноеМаскированиеСимволов, МаскированиеКириллицы);
	
КонецФункции


&НаКлиентеНаСервереБезКонтекста
Функция jsonЗаписатьСтроку(Значение, ПолноеМаскированиеСимволов, МаскированиеКириллицы)
	
	// Маскирование служебных символов
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Значение,
		"\", "\\"),
		Символ(008), "\b"),
		Символы.Таб, "\t"),
		Символы.ПС, "\n"),
		Символы.ПФ, "\f"),
		Символы.ВК, "\r"),
		"""", "\""");
	
	// Маскирование специальных символов
	Результат = СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(СтрЗаменить(Результат,
		Символ(00), "\u0000"),
		Символ(01), "\u0001"),
		Символ(02), "\u0002"),
		Символ(03), "\u0003"),
		Символ(04), "\u0004"),
		Символ(05), "\u0005"),
		Символ(06), "\u0006"),
		Символ(07), "\u0007"),
		Символ(11), "\u000b"),
		Символ(14), "\u000e"),
		Символ(15), "\u000f"),
		Символ(16), "\u0010"),
		Символ(17), "\u0011"),
		Символ(18), "\u0012"),
		Символ(19), "\u0013"),
		Символ(20), "\u0014"),
		Символ(21), "\u0015"),
		Символ(22), "\u0016"),
		Символ(23), "\u0017"),
		Символ(24), "\u0018"),
		Символ(25), "\u0019"),
		Символ(26), "\u001a"),
		Символ(27), "\u001b"),
		Символ(28), "\u001c"),
		Символ(29), "\u001d"),
		Символ(30), "\u001e"),
		Символ(31), "\u001f");
	
	Возврат """" + Результат + """";
	
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// КОНВЕРТАЦИЯ ССЫЛОЧНЫХ ТИПОВ
// ─────────────────────────────────────────────────────────────────────────────────

// Проверяет, является ли тип ссылочным типом данных
//
// Параметры:
//  ПроверяемыйТип - Тип - тип для проверки
//
// Возвращаемое значение:
//  Булево - Истина, если это ссылочный тип
//
&НаСервереБезКонтекста
Функция ЭтоСсылка(ПроверяемыйТип)
	
	Если ПроверяемыйТип = Тип("Неопределено") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Справочники.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Документы.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Перечисления.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыСчетов.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или БизнесПроцессы.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или Задачи.ТипВсеСсылки().СодержитТип(ПроверяемыйТип)
		Или ПланыОбмена.ТипВсеСсылки().СодержитТип(ПроверяемыйТип);
	
КонецФункции

// Возвращает строковое представление типа ссылки
//
// Параметры:
//  Тип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - строковое представление типа (например, "СправочникСсылка.Контрагенты")
//
&НаСервереБезКонтекста
Функция СтроковоеПредставлениеТипа(Тип)
	
	Если Не ЭтоСсылка(Тип) Тогда
		Возврат Строка(Тип);
	КонецЕсли;
	
	ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
	ЧастиИмени = РазделитьСтрокуПоРазделителю(ПолноеИмя, ".");
	
	Если ЧастиИмени.Количество() < 2 Тогда
		Возврат Строка(Тип);
	КонецЕсли;
	
	ИмяОбъекта = ЧастиИмени[1];
	
	Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "СправочникСсылка." + ИмяОбъекта;
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ДокументСсылка." + ИмяОбъекта;
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПеречислениеСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовХарактеристикСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланСчетовСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланВидовРасчетаСсылка." + ИмяОбъекта;
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "БизнесПроцессСсылка." + ИмяОбъекта;
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ЗадачаСсылка." + ИмяОбъекта;
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(Тип) Тогда
		Возврат "ПланОбменаСсылка." + ИмяОбъекта;
	Иначе
		Возврат Строка(Тип);
	КонецЕсли;
	
КонецФункции

// Возвращает программное имя типа прикладного объекта/менеджера (если возможно),
// например: "СправочникОбъект.Организации" или "СправочникМенеджер.Организации".
// Для примитивных типов и неподдерживаемых типов возвращает Строка(ПроверяемыйТип).
//
// Параметры:
//  ПроверяемыйТип - Тип - тип для преобразования
//
// Возвращаемое значение:
//  Строка - программное имя или строковое представление платформы
//
&НаСервереБезКонтекста
Функция СтроковоеПредставлениеПрикладногоТипа(ПроверяемыйТип)
	
	Если ПроверяемыйТип = Тип("Неопределено") Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	ПолноеИмя = "";
	Попытка
		ПолноеИмя = Метаданные.НайтиПоТипу(ПроверяемыйТип).ПолноеИмя();
	Исключение
		ПолноеИмя = "";
	КонецПопытки;
	
	Если ПустаяСтрока(ПолноеИмя) Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	ЧастиИмени = РазделитьСтрокуПоРазделителю(ПолноеИмя, ".");
	Если ЧастиИмени.Количество() < 2 Тогда
		Возврат Строка(ПроверяемыйТип);
	КонецЕсли;
	
	Префикс = ЧастиИмени[0];
	ИмяОбъекта = ЧастиИмени[1];
	
	ИмяТипаОбъекта = Префикс + "Объект." + ИмяОбъекта;
	Попытка
		Если Тип(ИмяТипаОбъекта) = ПроверяемыйТип Тогда
			Возврат ИмяТипаОбъекта;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	ИмяТипаМенеджера = Префикс + "Менеджер." + ИмяОбъекта;
	Попытка
		Если Тип(ИмяТипаМенеджера) = ПроверяемыйТип Тогда
			Возврат ИмяТипаМенеджера;
		КонецЕсли;
	Исключение
	КонецПопытки;
	
	Возврат Строка(ПроверяемыйТип);
	
КонецФункции

// Возвращает полное строковое представление ОписанияТипов реквизита
// с учётом квалификаторов и программных имён ссылочных типов
//
// Параметры:
//  ОписаниеТипов - ОписаниеТипов - описание типов реквизита (.Тип)
//
// Возвращаемое значение:
//  Строка - строковое представление типов, например:
//    "Число(15, 3)", "Строка(100)", "Дата(ДатаВремя)", "Булево",
//    "СправочникСсылка.Номенклатура",
//    "Число(10, 0), СправочникСсылка.Номенклатура, ДокументСсылка.Заказ"
//
&НаСервереБезКонтекста
Функция ПолучитьСтроковоеПредставлениеОписанияТипов(ОписаниеТипов)

	МассивТипов = ОписаниеТипов.Типы();

	Если МассивТипов.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;

	МассивПредставлений = Новый Массив;

	Для Каждого ТекущийТип Из МассивТипов Цикл

		Если ТекущийТип = Тип("Число") Тогда
			КвЧисла = ОписаниеТипов.КвалификаторыЧисла;
			ПредставлениеЧисла = "Число(" + КвЧисла.Разрядность + ", " + КвЧисла.РазрядностьДробнойЧасти;
			Если КвЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
				ПредставлениеЧисла = ПредставлениеЧисла + ", Неотрицательный";
			КонецЕсли;
			МассивПредставлений.Добавить(ПредставлениеЧисла + ")");

		ИначеЕсли ТекущийТип = Тип("Строка") Тогда
			КвСтроки = ОписаниеТипов.КвалификаторыСтроки;
			Если КвСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
				ВидДлины = "Фиксированная";
			Иначе
				ВидДлины = "Переменная";
			КонецЕсли;
			МассивПредставлений.Добавить("Строка(" + КвСтроки.Длина + ", " + ВидДлины + ")");

		ИначеЕсли ТекущийТип = Тип("Дата") Тогда
			КвДаты = ОписаниеТипов.КвалификаторыДаты;
			Если КвДаты.ЧастиДаты = ЧастиДаты.Время Тогда
				МассивПредставлений.Добавить("Дата(Время)");
			ИначеЕсли КвДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
				МассивПредставлений.Добавить("Дата(Дата)");
			Иначе
				МассивПредставлений.Добавить("Дата(ДатаВремя)");
			КонецЕсли;

		ИначеЕсли ЭтоСсылка(ТекущийТип) Тогда
			МассивПредставлений.Добавить(СтроковоеПредставлениеТипа(ТекущийТип));

		Иначе
			МассивПредставлений.Добавить(СтроковоеПредставлениеПрикладногоТипа(ТекущийТип));

		КонецЕсли;

	КонецЦикла;

	Возврат СоединитьМассив(МассивПредставлений, ", ");

КонецФункции

// Преобразует ссылку на объект в описание объекта для передачи через MCP
//
// Параметры:
//  СсылкаНаОбъект - ЛюбаяСсылка - ссылка на объект информационной базы
//
// Возвращаемое значение:
//  Структура - описание объекта с полями:
//    * _objectRef - Булево - признак описания объекта (всегда Истина)
//    * УникальныйИдентификатор - Строка - уникальный идентификатор объекта
//    * ТипОбъекта - Строка - строковое представление типа
//    * Представление - Строка - строковое представление объекта
//
&НаСервереБезКонтекста
Функция ОписаниеОбъектаПоСсылке(СсылкаНаОбъект)
	
	УникальныйИдентификатор = XMLСтрока(СсылкаНаОбъект);
	ТипОбъекта = СтроковоеПредставлениеТипа(ТипЗнч(СсылкаНаОбъект));
	Представление = Строка(СсылкаНаОбъект);
	
	ОписаниеОбъекта = Новый Структура;
	ОписаниеОбъекта.Вставить("_objectRef", Истина);
	ОписаниеОбъекта.Вставить("УникальныйИдентификатор", УникальныйИдентификатор);
	ОписаниеОбъекта.Вставить("ТипОбъекта", ТипОбъекта);
	ОписаниеОбъекта.Вставить("Представление", Представление);
	
	Возврат ОписаниеОбъекта;
	
КонецФункции

// Возвращает менеджер объекта по ссылке
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка на объект
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер и т.д. - менеджер объекта
//
&НаСервереБезКонтекста
Функция МенеджерОбъектаПоСсылке(Ссылка)
	
	ИмяОбъекта = Ссылка.Метаданные().Имя;
	ТипСсылки = ТипЗнч(Ссылка);
	
	Если Справочники.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Справочники[ИмяОбъекта];
	ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Документы[ИмяОбъекта];
	ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Перечисления[ИмяОбъекта];
	ИначеЕсли ПланыВидовХарактеристик.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовХарактеристик[ИмяОбъекта];
	ИначеЕсли ПланыСчетов.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыСчетов[ИмяОбъекта];
	ИначеЕсли ПланыВидовРасчета.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыВидовРасчета[ИмяОбъекта];
	ИначеЕсли БизнесПроцессы.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат БизнесПроцессы[ИмяОбъекта];
	ИначеЕсли Задачи.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат Задачи[ИмяОбъекта];
	ИначеЕсли ПланыОбмена.ТипВсеСсылки().СодержитТип(ТипСсылки) Тогда
		Возврат ПланыОбмена[ИмяОбъекта];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Преобразует описание объекта обратно в ссылку на объект информационной базы
//
// Параметры:
//  ОписаниеОбъекта - Структура, Произвольный - описание объекта или любое другое значение
//
// Возвращаемое значение:
//  ЛюбаяСсылка, Произвольный - ссылка на объект или исходное значение, если это не описание объекта
//
&НаСервереБезКонтекста
Функция ОбъектИнформационнойБазыПоОписанию(ОписаниеОбъекта)
	
	// Если это не структура - возвращаем как есть
	Если ТипЗнч(ОписаниеОбъекта) <> Тип("Структура") Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	// Проверяем, что это описание объекта
	Если Не ОписаниеОбъекта.Свойство("_objectRef") 
		Или ОписаниеОбъекта._objectRef <> Истина Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	// Проверяем наличие обязательных полей
	Если Не ОписаниеОбъекта.Свойство("УникальныйИдентификатор") 
		Или Не ОписаниеОбъекта.Свойство("ТипОбъекта") Тогда
		Возврат ОписаниеОбъекта;
	КонецЕсли;
	
	Попытка
		// Создаём описание типа и получаем пустое значение нужного типа
		ОписаниеТипа = Новый ОписаниеТипов(ОписаниеОбъекта.ТипОбъекта);
		ПустоеЗначение = ОписаниеТипа.ПривестиЗначение();
		
		// Получаем менеджер объекта
		МенеджерОбъекта = МенеджерОбъектаПоСсылке(ПустоеЗначение);
		
		Если МенеджерОбъекта = Неопределено Тогда
			Возврат ОписаниеОбъекта;
		КонецЕсли;
		
		// Получаем ссылку по уникальному идентификатору
		Ссылка = МенеджерОбъекта.ПолучитьСсылку(
			Новый УникальныйИдентификатор(ОписаниеОбъекта.УникальныйИдентификатор)
		);
		
		Возврат Ссылка;
		
	Исключение
		// Если не удалось преобразовать - возвращаем исходное значение
		Возврат ОписаниеОбъекта;
	КонецПопытки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПОИСК ССЫЛОК НА ОБЪЕКТ (find_references_to_object)
// ─────────────────────────────────────────────────────────────────────────────────

// Главный обработчик инструмента find_references_to_object
//
// Параметры:
//  ОписаниеЦелевогоОбъекта - Структура - описание целевого объекта (_objectRef, УникальныйИдентификатор, ТипОбъекта)
//  ОбластиПоиска - Массив - массив строк: "documents", "catalogs", "information_registers" и т.д.
//  ФильтрМетаданных - Структура, Неопределено - {names?: Массив, name_mask?: Строка}
//  ЛимитНайденных - Число - максимум находок
//  ЛимитНаМетуОбъект - Число - максимум находок на один объект метаданных
//  БюджетВремениСек - Число - бюджет времени в секундах
//
// Возвращаемое значение:
//  Структура - результат с полями success, data или error
//
&НаСервереБезКонтекста
Функция НайтиСсылкиНаОбъект(ОписаниеЦелевогоОбъекта, ОбластиПоиска, ФильтрМетаданных,
	ЛимитНайденных, ЛимитНаМетуОбъект, БюджетВремениСек)

	// Валидация входных параметров
	Если ОписаниеЦелевогоОбъекта = Неопределено Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указан целевой объект (target_object_description) / Target object description is required");
	КонецЕсли;

	Если ОбластиПоиска = Неопределено Или ОбластиПоиска.Количество() = 0 Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указаны области поиска (search_scope) / Search scope is required");
	КонецЕсли;

	// Конвертация описания объекта в ссылку
	ЦелеваяСсылка = ОбъектИнформационнойБазыПоОписанию(ОписаниеЦелевогоОбъекта);

	// Проверка, что удалось конвертировать
	Если ТипЗнч(ЦелеваяСсылка) = Тип("Структура") Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не удалось определить объект по описанию / Could not resolve object from description");
	КонецЕсли;

	// Проверка, что это ссылочный тип
	ТипЦелевойСсылки = ТипЗнч(ЦелеваяСсылка);
	Если Не ЭтоСсылка(ТипЦелевойСсылки) Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Объект не является ссылочным типом / Object is not a reference type");
	КонецЕсли;

	// Этап 1 — поиск кандидатов (полей, которые могут содержать ссылку нужного типа)
	ПропущенныеИмена = Новый Массив;
	Кандидаты = НайтиКандидатовПолей(ТипЦелевойСсылки, ОбластиПоиска, ФильтрМетаданных, ПропущенныеИмена);

	// Этап 2 — выполнение запросов по кандидатам
	Находки = Новый Массив;
	КандидатовПроверено = 0;
	ТаймаутПревышен = Ложь;
	ВремяНачала = ТекущаяУниверсальнаяДатаВМиллисекундах();
	БюджетМиллисекунд = БюджетВремениСек * 1000;

	Для Каждого Кандидат Из Кандидаты Цикл

		// Проверка таймаута
		Если (ТекущаяУниверсальнаяДатаВМиллисекундах() - ВремяНачала) >= БюджетМиллисекунд Тогда
			ТаймаутПревышен = Истина;
			Прервать;
		КонецЕсли;

		// Проверка общего лимита
		Если Находки.Количество() >= ЛимитНайденных Тогда
			Прервать;
		КонецЕсли;

		// Оставшийся лимит для этого кандидата
		ОстатокОбщий = ЛимитНайденных - Находки.Количество();
		ЛимитДляКандидата = Мин(ЛимитНаМетуОбъект, ОстатокОбщий);

		// Запрос ссылок в кандидате
		НовыеНаходки = ЗапроситьСсылкиВКандидате(ЦелеваяСсылка, Кандидат, ЛимитДляКандидата);

		Для Каждого Находка Из НовыеНаходки Цикл
			Если Находки.Количество() >= ЛимитНайденных Тогда
				Прервать;
			КонецЕсли;
			Находки.Добавить(Находка);
		КонецЦикла;

		КандидатовПроверено = КандидатовПроверено + 1;

	КонецЦикла;

	// Формирование результата
	Данные = Новый Структура;
	Данные.Вставить("hits", Находки);
	Данные.Вставить("total_hits", Находки.Количество());
	Данные.Вставить("candidates_checked", КандидатовПроверено);
	Данные.Вставить("timeout_exceeded", ТаймаутПревышен);
	Данные.Вставить("skipped_names", ПропущенныеИмена);

	Возврат Новый Структура("success, data", Истина, Данные);

КонецФункции

// Этап 1 — обход метаданных и поиск полей-кандидатов, содержащих нужный тип ссылки
//
// Параметры:
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ОбластиПоиска - Массив - массив строк областей поиска
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных {names, name_mask}
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён {name, reason}
//
// Возвращаемое значение:
//  Массив - массив структур-кандидатов {meta_name, field_name, field_kind, tabular_section, has_ref}
//
&НаСервереБезКонтекста
Функция НайтиКандидатовПолей(ТипЦелевойСсылки, ОбластиПоиска, ФильтрМетаданных, ПропущенныеИмена)

	Кандидаты = Новый Массив;

	// Формирование соответствия scope → коллекция метаданных
	Для Каждого Область Из ОбластиПоиска Цикл

		Если Область = "documents" Тогда
			ПроверитьКоллекциюМетаданных(Метаданные.Документы, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты, Истина);

		ИначеЕсли Область = "catalogs" Тогда
			ПроверитьКоллекциюМетаданных(Метаданные.Справочники, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты, Истина);

		ИначеЕсли Область = "information_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыСведений, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "accumulation_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыНакопления, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "accounting_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыБухгалтерии, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);

		ИначеЕсли Область = "calculation_registers" Тогда
			ПроверитьКоллекциюРегистров(Метаданные.РегистрыРасчета, ТипЦелевойСсылки,
				ФильтрМетаданных, ПропущенныеИмена, Кандидаты);
		КонецЕсли;

	КонецЦикла;

	// Проверка skipped_names: какие имена из meta_filter.names не найдены или не соответствуют scope
	Если ФильтрМетаданных <> Неопределено
		И ТипЗнч(ФильтрМетаданных) = Тип("Структура")
		И ФильтрМетаданных.Свойство("names")
		И ФильтрМетаданных.names <> Неопределено
		И ТипЗнч(ФильтрМетаданных.names) = Тип("Массив")
		И ФильтрМетаданных.names.Количество() > 0 Тогда

		// Соответствие типов метаданных областям поиска
		СоответствиеТиповОбластям = Новый Соответствие;
		СоответствиеТиповОбластям.Вставить("Документ", "documents");
		СоответствиеТиповОбластям.Вставить("Справочник", "catalogs");
		СоответствиеТиповОбластям.Вставить("РегистрСведений", "information_registers");
		СоответствиеТиповОбластям.Вставить("РегистрНакопления", "accumulation_registers");
		СоответствиеТиповОбластям.Вставить("РегистрБухгалтерии", "accounting_registers");
		СоответствиеТиповОбластям.Вставить("РегистрРасчета", "calculation_registers");

		// Множество запрошенных областей для быстрой проверки
		МножествоОбластей = Новый Соответствие;
		Для Каждого Область Из ОбластиПоиска Цикл
			МножествоОбластей.Вставить(Область, Истина);
		КонецЦикла;

		Для Каждого ИмяФильтра Из ФильтрМетаданных.names Цикл
			// Проверяем существование объекта в метаданных
			НайденныйОбъект = Метаданные.НайтиПоПолномуИмени(ИмяФильтра);

			Если НайденныйОбъект = Неопределено Тогда
				Пропуск = Новый Структура("name, reason", ИмяФильтра,
					"не найден в метаданных / not found in metadata");
				ПропущенныеИмена.Добавить(Пропуск);
				Продолжить;
			КонецЕсли;

			// Проверяем соответствие типа метаданных областям поиска
			ЧастиИмени = РазделитьСтрокуПоРазделителю(ИмяФильтра, ".");
			Если ЧастиИмени.Количество() >= 1 Тогда
				ПрефиксТипа = ЧастиИмени[0];
				ОбластьДляТипа = СоответствиеТиповОбластям.Получить(ПрефиксТипа);

				Если ОбластьДляТипа <> Неопределено
					И МножествоОбластей.Получить(ОбластьДляТипа) = Неопределено Тогда
					Пропуск = Новый Структура("name, reason", ИмяФильтра,
						"не соответствует области поиска (search_scope) / does not match search_scope");
					ПропущенныеИмена.Добавить(Пропуск);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

	Возврат Кандидаты;

КонецФункции

// Проверяет коллекцию метаданных документов/справочников на наличие полей с нужным типом ссылки
//
// Параметры:
//  КоллекцияМетаданных - КоллекцияОбъектовМетаданных - коллекция (Метаданные.Документы и т.п.)
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён
//  Кандидаты - Массив - (выходной) массив найденных кандидатов
//  ЕстьСсылка - Булево - имеет ли объект поле Ссылка
//
&НаСервереБезКонтекста
Процедура ПроверитьКоллекциюМетаданных(КоллекцияМетаданных, ТипЦелевойСсылки,
	ФильтрМетаданных, ПропущенныеИмена, Кандидаты, ЕстьСсылка)

	Для Каждого ОбъектМетаданных Из КоллекцияМетаданных Цикл

		// Проверка фильтра метаданных
		Если Не ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена) Тогда
			Продолжить;
		КонецЕсли;

		ПолноеИмяМета = ОбъектМетаданных.ПолноеИмя();

		// Проверка реквизитов шапки
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Реквизит.Имя, "attribute", "", ЕстьСсылка));
			КонецЕсли;
		КонецЦикла;

		// Проверка табличных частей
		Для Каждого ТабличнаяЧасть Из ОбъектМетаданных.ТабличныеЧасти Цикл
			Для Каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
				Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
					Кандидаты.Добавить(Новый Структура(
						"meta_name, field_name, field_kind, tabular_section, has_ref",
						ПолноеИмяМета, Реквизит.Имя, "tabular_section", ТабличнаяЧасть.Имя, ЕстьСсылка));
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

// Проверяет коллекцию метаданных регистров на наличие полей с нужным типом ссылки
//
// Параметры:
//  КоллекцияМетаданных - КоллекцияОбъектовМетаданных - коллекция регистров
//  ТипЦелевойСсылки - Тип - тип ссылки целевого объекта
//  ФильтрМетаданных - Структура, Неопределено - фильтр метаданных
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён
//  Кандидаты - Массив - (выходной) массив найденных кандидатов
//
&НаСервереБезКонтекста
Процедура ПроверитьКоллекциюРегистров(КоллекцияМетаданных, ТипЦелевойСсылки,
	ФильтрМетаданных, ПропущенныеИмена, Кандидаты)

	Для Каждого ОбъектМетаданных Из КоллекцияМетаданных Цикл

		// Проверка фильтра метаданных
		Если Не ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена) Тогда
			Продолжить;
		КонецЕсли;

		ПолноеИмяМета = ОбъектМетаданных.ПолноеИмя();

		// Проверка измерений
		Для Каждого Измерение Из ОбъектМетаданных.Измерения Цикл
			Если Измерение.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Измерение.Имя, "dimension", "", Ложь));
			КонецЕсли;
		КонецЦикла;

		// Проверка ресурсов
		Для Каждого Ресурс Из ОбъектМетаданных.Ресурсы Цикл
			Если Ресурс.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Ресурс.Имя, "resource", "", Ложь));
			КонецЕсли;
		КонецЦикла;

		// Проверка реквизитов регистра
		Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
			Если Реквизит.Тип.СодержитТип(ТипЦелевойСсылки) Тогда
				Кандидаты.Добавить(Новый Структура(
					"meta_name, field_name, field_kind, tabular_section, has_ref",
					ПолноеИмяМета, Реквизит.Имя, "requisite", "", Ложь));
			КонецЕсли;
		КонецЦикла;

	КонецЦикла;

КонецПроцедуры

// Проверяет, проходит ли объект метаданных фильтр поиска (meta_filter)
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - проверяемый объект метаданных
//  ФильтрМетаданных - Структура, Неопределено - фильтр {names?: Массив, name_mask?: Строка}
//  ПропущенныеИмена - Массив - (выходной) массив пропущенных имён (не используется при маске)
//
// Возвращаемое значение:
//  Булево - Истина, если объект прошёл фильтр
//
&НаСервереБезКонтекста
Функция ПрошелФильтрМетаданныхПоиска(ОбъектМетаданных, ФильтрМетаданных, ПропущенныеИмена)

	// Если фильтр не задан — проходит всё
	Если ФильтрМетаданных = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;

	Если ТипЗнч(ФильтрМетаданных) <> Тип("Структура") Тогда
		Возврат Истина;
	КонецЕсли;

	ПолноеИмяОбъекта = ОбъектМетаданных.ПолноеИмя();

	// Приоритет 1: names (точное совпадение, регистронезависимо)
	Если ФильтрМетаданных.Свойство("names") И ФильтрМетаданных.names <> Неопределено
		И ТипЗнч(ФильтрМетаданных.names) = Тип("Массив") И ФильтрМетаданных.names.Количество() > 0 Тогда

		ПолноеИмяВерх = ВРег(ПолноеИмяОбъекта);

		Для Каждого ИмяФильтра Из ФильтрМетаданных.names Цикл
			Если ВРег(ИмяФильтра) = ПолноеИмяВерх Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЦикла;

		// Не найдено в списке имён
		Возврат Ложь;
	КонецЕсли;

	// Приоритет 2: name_mask (подстрока в имени или синониме)
	Если ФильтрМетаданных.Свойство("name_mask") И ЗначениеЗаполнено(ФильтрМетаданных.name_mask) Тогда
		МаскаВерхнийРегистр = ВРег(ФильтрМетаданных.name_mask);
		Возврат ПрошелФильтрПоМаске(ОбъектМетаданных.Имя, ОбъектМетаданных.Синоним, МаскаВерхнийРегистр);
	КонецЕсли;

	// Ни names, ни name_mask не заданы — проходит всё
	Возврат Истина;

КонецФункции

// Этап 2 — выполнение запроса для одного кандидата и формирование находок
//
// Параметры:
//  ЦелеваяСсылка - ЛюбаяСсылка - ссылка на целевой объект
//  Кандидат - Структура - описание кандидата {meta_name, field_name, field_kind, tabular_section, has_ref}
//  Лимит - Число - максимальное количество находок для этого кандидата
//
// Возвращаемое значение:
//  Массив - массив структур-находок
//
&НаСервереБезКонтекста
Функция ЗапроситьСсылкиВКандидате(ЦелеваяСсылка, Кандидат, Лимит)

	Находки = Новый Массив;

	Попытка

		ИмяМета = Кандидат.meta_name;
		ИмяПоля = Кандидат.field_name;
		ВидПоля = Кандидат.field_kind;
		ТабличнаяЧасть = Кандидат.tabular_section;
		ЕстьСсылка = Кандидат.has_ref;
		ЛимитСтрока = Формат(Лимит, "ЧГ=");

		Если ВидПоля = "attribute" И ЕстьСсылка Тогда
			// Реквизит шапки документа/справочника
			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока
				+ " Т.Ссылка КАК Ссылка"
				+ " ИЗ " + ИмяМета + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл
				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", ОписаниеОбъектаПоСсылке(Выборка.Ссылка));
				Находка.Вставить("path", ИмяПоля);
				Находка.Вставить("match_kind", "attribute");
				Находка.Вставить("note", Строка(Выборка.Ссылка));
				Находки.Добавить(Находка);
			КонецЦикла;

		ИначеЕсли ВидПоля = "tabular_section" И ЕстьСсылка Тогда
			// Реквизит табличной части документа/справочника
			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока
				+ " РАЗЛИЧНЫЕ Т.Ссылка КАК Ссылка"
				+ " ИЗ " + ИмяМета + "." + ТабличнаяЧасть + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл
				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", ОписаниеОбъектаПоСсылке(Выборка.Ссылка));
				Находка.Вставить("path", ТабличнаяЧасть + "." + ИмяПоля);
				Находка.Вставить("match_kind", "tabular_section");
				Находка.Вставить("note", Строка(Выборка.Ссылка));
				Находки.Добавить(Находка);
			КонецЦикла;

		Иначе
			// Регистр (dimension, resource, requisite)
			// Определяем объект метаданных регистра для построения списка полей выборки
			ОбъектМетаданныхРегистра = Метаданные.НайтиПоПолномуИмени(ИмяМета);

			Если ОбъектМетаданныхРегистра = Неопределено Тогда
				Возврат Находки;
			КонецЕсли;

			// Формируем список полей для выборки: все измерения
			ПоляВыборки = Новый Массив;
			ИменаИзмерений = Новый Массив;

			Для Каждого Измерение Из ОбъектМетаданныхРегистра.Измерения Цикл
				ПоляВыборки.Добавить("Т." + Измерение.Имя + " КАК " + Измерение.Имя);
				ИменаИзмерений.Добавить(Измерение.Имя);
			КонецЦикла;

			// Определяем тип регистра
			ЕстьПериод = Ложь;
			ПолноеИмяЧасти = РазделитьСтрокуПоРазделителю(ИмяМета, ".");
			ТипРегистра = "";
			Если ПолноеИмяЧасти.Количество() >= 1 Тогда
				ТипРегистра = ПолноеИмяЧасти[0];
			КонецЕсли;

			// Период — для периодических регистров сведений
			Если ТипРегистра = "РегистрСведений" Тогда
				Попытка
					Если ОбъектМетаданныхРегистра.ПериодичностьРегистраСведений
						<> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
						ПоляВыборки.Добавить("Т.Период КАК Период");
						ЕстьПериод = Истина;
					КонецЕсли;
				Исключение
					// Не удалось определить периодичность — пропускаем Период
				КонецПопытки;

			// Период — для регистров накопления и бухгалтерии (всегда есть)
			ИначеЕсли ТипРегистра = "РегистрНакопления"
				Или ТипРегистра = "РегистрБухгалтерии" Тогда
				ПоляВыборки.Добавить("Т.Период КАК Период");
				ЕстьПериод = Истина;
			КонецЕсли;

			// Регистратор — для регистров накопления, бухгалтерии, расчёта
			ЕстьРегистратор = Ложь;
			Если ТипРегистра = "РегистрНакопления"
				Или ТипРегистра = "РегистрБухгалтерии"
				Или ТипРегистра = "РегистрРасчета" Тогда
				ПоляВыборки.Добавить("Т.Регистратор КАК Регистратор");
				ЕстьРегистратор = Истина;
			КонецЕсли;

			Если ПоляВыборки.Количество() = 0 Тогда
				Возврат Находки;
			КонецЕсли;

			ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ " + ЛимитСтрока + " "
				+ СоединитьМассив(ПоляВыборки, ", ")
				+ " ИЗ " + ИмяМета + " КАК Т"
				+ " ГДЕ Т." + ИмяПоля + " = &ЦельПоиска";

			Запрос = Новый Запрос(ТекстЗапроса);
			Запрос.УстановитьПараметр("ЦельПоиска", ЦелеваяСсылка);
			Результат = Запрос.Выполнить();
			Выборка = Результат.Выбрать();

			Пока Выборка.Следующий() Цикл

				// Формируем record_key
				КлючЗаписи = Новый Структура;
				ЧастиПримечания = Новый Массив;

				Для Каждого ИмяИзмерения Из ИменаИзмерений Цикл
					ЗначениеИзмерения = Выборка[ИмяИзмерения];
					ТипЗначенияИзм = ТипЗнч(ЗначениеИзмерения);

					Если ЭтоСсылка(ТипЗначенияИзм) И ЗначениеЗаполнено(ЗначениеИзмерения) Тогда
						КлючЗаписи.Вставить(ИмяИзмерения, ОписаниеОбъектаПоСсылке(ЗначениеИзмерения));
					Иначе
						КлючЗаписи.Вставить(ИмяИзмерения, БезопасноеЗначениеДляПередачи(ЗначениеИзмерения));
					КонецЕсли;

					ЧастиПримечания.Добавить(ИмяИзмерения + "=" + Строка(ЗначениеИзмерения));
				КонецЦикла;

				// Период
				Если ЕстьПериод Тогда
					ЗначениеПериода = Выборка.Период;
					КлючЗаписи.Вставить("Период", БезопасноеЗначениеДляПередачи(ЗначениеПериода));
					ЧастиПримечания.Добавить("Период=" + Строка(ЗначениеПериода));
				КонецЕсли;

				// Регистратор
				Если ЕстьРегистратор Тогда
					ЗначениеРегистратора = Выборка.Регистратор;
					Если ЗначениеЗаполнено(ЗначениеРегистратора) Тогда
						КлючЗаписи.Вставить("Регистратор", ОписаниеОбъектаПоСсылке(ЗначениеРегистратора));
					Иначе
						КлючЗаписи.Вставить("Регистратор", Неопределено);
					КонецЕсли;
					ЧастиПримечания.Добавить("Регистратор=" + Строка(ЗначениеРегистратора));
				КонецЕсли;

				Находка = Новый Структура;
				Находка.Вставить("found_in_meta", ИмяМета);
				Находка.Вставить("found_in_object", Неопределено);
				Находка.Вставить("record_key", КлючЗаписи);
				Находка.Вставить("path", ИмяПоля);
				Находка.Вставить("match_kind", ВидПоля);
				Находка.Вставить("note", СоединитьМассив(ЧастиПримечания, "; "));
				Находки.Добавить(Находка);

			КонецЦикла;

		КонецЕсли;

	Исключение
		// Ошибка выполнения запроса — пропускаем этого кандидата
	КонецПопытки;

	Возврат Находки;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ПРАВА ДОСТУПА (get_access_rights)
// ─────────────────────────────────────────────────────────────────────────────────

// Главная функция инструмента get_access_rights
//
// Параметры:
//  ИмяОбъектаМетаданных - Строка - полное имя объекта метаданных (например, "Справочник.Контрагенты")
//  ИмяПользователяИБ - Строка, Неопределено - имя пользователя для эффективных прав
//  ФильтрПрав - Массив, Неопределено - список прав для отображения
//  ФильтрРолей - Массив, Неопределено - список ролей для отображения
//
// Возвращаемое значение:
//  Структура - результат с полями success, data или error
//
&НаСервереБезКонтекста
Функция ПолучитьПраваДоступа(ИмяОбъектаМетаданных, ИмяПользователяИБ, ФильтрПрав, ФильтрРолей)

	// 1. Проверка привилегированного режима
	Если ПривилегированныйРежим() Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Инструмент не работает в привилегированном режиме / Tool does not work in privileged mode");
	КонецЕсли;

	// 2. Валидация обязательных параметров
	Если Не ЗначениеЗаполнено(ИмяОбъектаМетаданных) Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Не указан объект метаданных (metadata_object) / Metadata object is required");
	КонецЕсли;

	// 3. Поиск объекта метаданных
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяОбъектаМетаданных);
	Если ОбъектМетаданных = Неопределено Тогда
		Возврат Новый Структура("success, error", Ложь,
			"Объект метаданных не найден: " + ИмяОбъектаМетаданных +
			" / Metadata object not found: " + ИмяОбъектаМетаданных);
	КонецЕсли;

	// 4. Определение типа метаданных
	ТипМетаданных = ОпределитьТипМетаданных(ОбъектМетаданных);
	Если ТипМетаданных = "Unknown" Тогда
		// Для поддержки всех типов метаданных не заваливаемся ошибкой.
		// В этом случае возвращаем тип как префикс из metadata_object и используем права по умолчанию.
		ТипМетаданных = ПолучитьПрефиксМетаданныхИзИмени(ИмяОбъектаМетаданных);
		Если ТипМетаданных = "Unknown" Тогда
			ТипМетаданных = "Другое";
		КонецЕсли;
	КонецЕсли;

	// 5. Получение применимых прав
	ПрименимыеПрава = ПолучитьПраваПоТипам();
	ПраваПоТипу = ПрименимыеПрава.Получить(ТипМетаданных);
	Если ПраваПоТипу = Неопределено Тогда
		// Права не определены для этого типа — используем универсальный список по умолчанию
		ПраваПоТипу = ПолучитьПраваПоУмолчанию();
	КонецЕсли;

	// 6. Применение фильтра прав
	ПраваДляПроверки = Новый Массив;
	Если ФильтрПрав <> Неопределено И ЭтоКоллекция(ФильтрПрав) И ФильтрПрав.Количество() > 0 Тогда
		Для Каждого ПравоИзФильтра Из ФильтрПрав Цикл
			ПравоИзФильтра = СокрЛП(ПравоИзФильтра);
			Если ПравоИзФильтра <> "" Тогда
				ПраваДляПроверки.Добавить(ПравоИзФильтра);
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Используем дефолтный список по типу
		Для Каждого Право Из ПраваПоТипу Цикл
			ПраваДляПроверки.Добавить(Право);
		КонецЦикла;
	КонецЕсли;

	// 6.1 Предварительная проверка админ-прав
	//
	// Вызовы ПравоДоступа() с 3-м параметром (роль/пользователь) требуют административных прав.
	// Чтобы не "тихо" получить все false (из-за Исключение), проверяем это заранее на заведомо
	// корректном праве из дефолтного списка.
	ПроверочноеПраво = "";
	Если ПраваПоТипу <> Неопределено И ЭтоКоллекция(ПраваПоТипу) И ПраваПоТипу.Количество() > 0 Тогда
		ПроверочноеПраво = ПраваПоТипу[0];
	ИначеЕсли ПраваДляПроверки <> Неопределено И ПраваДляПроверки.Количество() > 0 Тогда
		ПроверочноеПраво = ПраваДляПроверки[0];
	КонецЕсли;

	Если ЗначениеЗаполнено(ПроверочноеПраво) Тогда
		ПерваяРоль = Неопределено;
		Для Каждого Роль0 Из Метаданные.Роли Цикл
			ПерваяРоль = Роль0;
			Прервать;
		КонецЦикла;

		Если ПерваяРоль <> Неопределено Тогда
			ПравоКорректно = Истина;
			Попытка
				// Без 3-го параметра исключений быть не должно (проверка на корректность права/объекта)
				ПравоДоступа(ПроверочноеПраво, ОбъектМетаданных);
			Исключение
				ПравоКорректно = Ложь;
			КонецПопытки;

			Если ПравоКорректно Тогда
				Попытка
					// Проверка наличия админ-прав (с 3-м параметром)
					ПравоДоступа(ПроверочноеПраво, ОбъектМетаданных, ПерваяРоль);
				Исключение
					Возврат Новый Структура("success, error", Ложь,
						"Требуются административные права / Admin rights required");
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// 7. Получение прав ролей
	МассивРолей = Новый Массив;
	ИспользованФильтрРолей = (ФильтрРолей <> Неопределено И ЭтоКоллекция(ФильтрРолей) И ФильтрРолей.Количество() > 0);
	ЕстьЯвноеЗначениеРолейФильтр = Ложь;

	Для Каждого РольМетаданных Из Метаданные.Роли Цикл
		ИмяРоли = РольМетаданных.Имя;

		// Применение фильтра ролей
		Если ИспользованФильтрРолей Тогда
			НайденоВФильтре = Ложь;
			Для Каждого ИмяИзФильтра Из ФильтрРолей Цикл
				Если ВРег(СокрЛП(ИмяИзФильтра)) = ВРег(ИмяРоли) Тогда
					НайденоВФильтре = Истина;
					ЕстьЯвноеЗначениеРолейФильтр = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не НайденоВФильтре Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Проверка прав роли на объект
		ПраваРоли = Новый Структура;
		ЕстьХотяБыОдноПраво = Ложь;
		РольИмеетПраваНаОбъект = Ложь;

		Для Каждого ИмяПрава Из ПраваДляПроверки Цикл
			ЕстьПравоНаМетаданные = Ложь;
			Попытка
				// Проверка права для роли (требует админ-прав!)
				ЕстьПравоНаМетаданные = ПравоДоступа(ИмяПрава, ОбъектМетаданных, РольМетаданных);
				ПраваРоли.Вставить(ИмяПрава, ЕстьПравоНаМетаданные);
				Если ЕстьПравоНаМетаданные Тогда
					ЕстьХотяБыОдноПраво = Истина;
					РольИмеетПраваНаОбъект = Истина;
				КонецЕсли;
			Исключение
				// Любая ошибка проверки конкретного права трактуется как отсутствие права
				// (в т.ч. неприменимое право или неизвестное имя права).
				ПраваРоли.Вставить(ИмяПрава, Ложь);
			КонецПопытки;
		КонецЦикла;

		// Добавление роли в результат
		// Без фильтра: только роли с правами
		// С фильтром: все роли из фильтра (даже если все false)
		Если ЕстьХотяБыОдноПраво Или (ИспользованФильтрРолей И ЕстьЯвноеЗначениеРолейФильтр) Тогда
			СтруктураРоли = Новый Структура;
			СтруктураРоли.Вставить("name", ИмяРоли);
			СтруктураРоли.Вставить("synonym", РольМетаданных.Синоним);
			СтруктураРоли.Вставить("rights", ПраваРоли);
			МассивРолей.Добавить(СтруктураРоли);
		КонецЕсли;
	КонецЦикла;

	// 8. Подсчёт статистики
	ВсегоРолей = МассивРолей.Количество();
	РолейСПравами = 0;
	Для Каждого ДанныеРоли Из МассивРолей Цикл
		Для Каждого КлючЗначение Из ДанныеРоли.rights Цикл
			Если КлючЗначение.Значение = Истина Тогда
				РолейСПравами = РолейСПравами + 1;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	// 9. Сортировка ролей по имени
	МассивРолей = СортироватьМассивСтруктурПоПолю(МассивРолей, "name");

	// 10. Формирование результата
	Данные = Новый Структура;
	Данные.Вставить("metadata_object", ИмяОбъектаМетаданных);
	Данные.Вставить("metadata_type", ТипМетаданных);
	// applicable_rights соответствует ключам в rights/effective_rights (с учётом rights_filter)
	Данные.Вставить("applicable_rights", ПраваДляПроверки);
	Данные.Вставить("roles", МассивРолей);
	Данные.Вставить("total_roles", ВсегоРолей);
	Данные.Вставить("roles_with_rights", РолейСПравами);

	// 11. Права пользователя (если указан)
	Если ЗначениеЗаполнено(ИмяПользователяИБ) Тогда
		ПользовательИБ = НайтиПользователяИБПоИмени(ИмяПользователяИБ);
		Если ПользовательИБ = Неопределено Тогда
			Возврат Новый Структура("success, error", Ложь,
				"Пользователь не найден: " + ИмяПользователяИБ +
				" / User not found in infobase: " + ИмяПользователяИБ);
		КонецЕсли;

		// Роли пользователя
		РолиПользователя = Новый Массив;
		Для Каждого РольИБ Из ПользовательИБ.Роли Цикл
			РолиПользователя.Добавить(РольИБ.Имя);
		КонецЦикла;

		// Эффективные права через пользователя
		ЭффективныеПрава = Новый Структура;
		Для Каждого ИмяПрава Из ПраваДляПроверки Цикл
			Попытка
				// Проверка права для пользователя (требует админ-прав!)
				ЕстьПраво = ПравоДоступа(ИмяПрава, ОбъектМетаданных, ПользовательИБ);
				ЭффективныеПрава.Вставить(ИмяПрава, ЕстьПраво);
			Исключение
				ЭффективныеПрава.Вставить(ИмяПрава, Ложь);
			КонецПопытки;
		КонецЦикла;

		// Данные о пользователе
		ДанныеПользователя = Новый Структура;
		ДанныеПользователя.Вставить("name", ИмяПользователяИБ);

		// Полное имя (если доступно)
		ПолноеИмя = "";
		Попытка
			ПолноеИмя = ПользовательИБ.ПолноеИмя;
		Исключение
			// Полное имя может быть недоступно
		КонецПопытки;
		Если ЗначениеЗаполнено(ПолноеИмя) Тогда
			ДанныеПользователя.Вставить("full_name", ПолноеИмя);
		КонецЕсли;

		ДанныеПользователя.Вставить("roles", РолиПользователя);
		ДанныеПользователя.Вставить("effective_rights", ЭффективныеПрава);

		Данные.Вставить("user", ДанныеПользователя);
	КонецЕсли;

	Возврат Новый Структура("success, data", Истина, Данные);

КонецФункции

// Определение типа метаданных (на русском)
//
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданных - объект метаданных
//
// Возвращаемое значение:
//  Строка - тип метаданных на русском
//
&НаСервереБезКонтекста
Функция ОпределитьТипМетаданных(ОбъектМетаданных)

	Если Метаданные.Справочники.Содержит(ОбъектМетаданных) Тогда
		Возврат "Справочник";
	ИначеЕсли Метаданные.Документы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Документ";
	ИначеЕсли Метаданные.Перечисления.Содержит(ОбъектМетаданных) Тогда
		Возврат "Перечисление";
	ИначеЕсли Метаданные.РегистрыСведений.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрСведений";
	ИначеЕсли Метаданные.РегистрыНакопления.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрНакопления";
	ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрБухгалтерии";
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегистрРасчета";
	ИначеЕсли Метаданные.Обработки.Содержит(ОбъектМетаданных) Тогда
		Возврат "Обработка";
	ИначеЕсли Метаданные.Отчеты.Содержит(ОбъектМетаданных) Тогда
		Возврат "Отчет";
	ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланВидовХарактеристик";
	ИначеЕсли Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланСчетов";
	ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланВидовРасчета";
	ИначеЕсли Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПланОбмена";
	ИначеЕсли Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных) Тогда
		Возврат "БизнесПроцесс";
	ИначеЕсли Метаданные.Задачи.Содержит(ОбъектМетаданных) Тогда
		Возврат "Задача";
	ИначеЕсли Метаданные.ГруппыКоманд.Содержит(ОбъектМетаданных) Тогда
		Возврат "ГруппаКоманд";
	ИначеЕсли Метаданные.ЖурналыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат "ЖурналДокументов";
	ИначеЕсли Метаданные.Константы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Константа";
	ИначеЕсли Метаданные.КритерииОтбора.Содержит(ОбъектМетаданных) Тогда
		Возврат "КритерийОтбора";
	ИначеЕсли Метаданные.НумераторыДокументов.Содержит(ОбъектМетаданных) Тогда
		Возврат "Нумератор";
	ИначеЕсли Метаданные.ОбщиеКоманды.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщаяКоманда";
	ИначеЕсли Метаданные.ОбщиеМодули.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщийМодуль";
	ИначеЕсли Метаданные.ОбщиеРеквизиты.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщийРеквизит";
	ИначеЕсли Метаданные.ОпределяемыеТипы.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОпределяемыйТип";
	ИначеЕсли Метаданные.ПараметрыФункциональныхОпций.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПараметрФункциональныхОпций";
	ИначеЕсли Метаданные.Подсистемы.Содержит(ОбъектМетаданных) Тогда
		Возврат "Подсистема";
	ИначеЕсли Метаданные.Последовательности.Содержит(ОбъектМетаданных) Тогда
		Возврат "Последовательность";
	ИначеЕсли Метаданные.РегламентныеЗадания.Содержит(ОбъектМетаданных) Тогда
		Возврат "РегламентноеЗадание";
	ИначеЕсли Метаданные.ФункциональныеОпции.Содержит(ОбъектМетаданных) Тогда
		Возврат "ФункциональнаяОпция";
	ИначеЕсли Метаданные.HTTPСервисы.Содержит(ОбъектМетаданных) Тогда
		Возврат "HTTPСервис";
	ИначеЕсли Метаданные.WebСервисы.Содержит(ОбъектМетаданных) Тогда
		Возврат "WebСервис";
	ИначеЕсли Метаданные.WSСсылки.Содержит(ОбъектМетаданных) Тогда
		Возврат "WSСсылка";
	ИначеЕсли Метаданные.WebSocketКлиенты.Содержит(ОбъектМетаданных) Тогда
		Возврат "WebSocketКлиент";
	ИначеЕсли Метаданные.ВнешниеИсточникиДанных.Содержит(ОбъектМетаданных) Тогда
		Возврат "ВнешнийИсточникДанных";
	ИначеЕсли Метаданные.ПараметрыСеанса.Содержит(ОбъектМетаданных) Тогда
		Возврат "ПараметрСеанса";
	ИначеЕсли Метаданные.Роли.Содержит(ОбъектМетаданных) Тогда
		Возврат "Роль";
	ИначеЕсли Метаданные.ХранилищаНастроек.Содержит(ОбъектМетаданных) Тогда
		Возврат "ХранилищеНастроек";
	ИначеЕсли Метаданные.ОбщиеФормы.Содержит(ОбъектМетаданных) Тогда
		Возврат "ОбщаяФорма";
	ИначеЕсли Метаданные.СервисыИнтеграции.Содержит(ОбъектМетаданных) Тогда
		Возврат "СервисИнтеграции";
	ИначеЕсли Метаданные.Боты.Содержит(ОбъектМетаданных) Тогда
		Возврат "Бот";
	Иначе
		Возврат "Unknown";
	КонецЕсли;

КонецФункции

// Получить префикс типа метаданных из полного имени объекта (часть до первой точки).
//
// Параметры:
//  ПолноеИмя - Строка - например "Справочник.Контрагенты"
//
// Возвращаемое значение:
//  Строка - префикс (например "Справочник") или "Unknown"
//
&НаСервереБезКонтекста
Функция ПолучитьПрефиксМетаданныхИзИмени(ПолноеИмя)

	Если Не ЗначениеЗаполнено(ПолноеИмя) Тогда
		Возврат "Unknown";
	КонецЕсли;

	ПолноеИмя = СокрЛП(ПолноеИмя);
	ПозицияТочки = Найти(ПолноеИмя, ".");
	Если ПозицияТочки <= 0 Тогда
		Возврат "Unknown";
	КонецЕсли;

	Префикс = Лев(ПолноеИмя, ПозицияТочки - 1);
	Префикс = СокрЛП(Префикс);
	Если Префикс = "" Тогда
		Возврат "Unknown";
	КонецЕсли;

	Возврат Префикс;

КонецФункции

// Универсальный список прав по умолчанию для типов метаданных,
// для которых нет специфического списка в ПолучитьПраваПоТипам().
//
// Возвращаемое значение:
//  Массив - список прав для проверки
//
&НаСервереБезКонтекста
Функция ПолучитьПраваПоУмолчанию()

	Права = Новый Массив;

	// Базовые права, которые чаще всего применимы к большинству объектов
	Права.Добавить("Чтение");
	Права.Добавить("Просмотр");
	Права.Добавить("Использование");
	Права.Добавить("Добавление");
	Права.Добавить("Изменение");
	Права.Добавить("Удаление");
	Права.Добавить("Редактирование");

	// Часто встречающиеся "служебные" права
	Права.Добавить("Получение");
	Права.Добавить("Установка");
	Права.Добавить("Вывод");
	Права.Добавить("ВводПоСтроке");
	Права.Добавить("СохранениеДанныхПользователя");
	Права.Добавить("ИзменениеСтандартнойАутентификации");

	// Документные права (для большинства типов будут просто false)
	Права.Добавить("Проведение");
	Права.Добавить("ОтменаПроведения");
	Права.Добавить("ИнтерактивноеПроведение");
	Права.Добавить("ИнтерактивноеПроведениеНеОперативное");
	Права.Добавить("ИнтерактивнаяОтменаПроведения");
	Права.Добавить("ИнтерактивноеИзменениеПроведенных");

	// Интерактивные права редактирования (для многих типов будут false)
	Права.Добавить("ИнтерактивноеДобавление");
	Права.Добавить("ИнтерактивноеУдаление");
	Права.Добавить("ИнтерактивнаяПометкаУдаления");
	Права.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	Права.Добавить("ИнтерактивноеУдалениеПомеченных");
	Права.Добавить("ИнтерактивноеУдалениеПредопределенныхДанных");
	Права.Добавить("ИнтерактивнаяПометкаУдаленияПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	Права.Добавить("ИнтерактивноеОткрытиеВнешнихОбработок");
	Права.Добавить("ИнтерактивноеОткрытиеВнешнихОтчетов");

	// Права для отдельных подсистем (для большинства типов будут просто false)
	Права.Добавить("УправлениеИтогами");
	Права.Добавить("Администрирование");
	Права.Добавить("АдминистрированиеДанных");
	Права.Добавить("РежимВсеФункции");
	Права.Добавить("Старт");
	Права.Добавить("ИнтерактивныйСтарт");
	Права.Добавить("Выполнение");
	Права.Добавить("ИнтерактивноеВыполнение");

	Возврат Права;

КонецФункции

// Получить справочник прав по типам метаданных
//
// Возвращаемое значение:
//  Соответствие - тип метаданных -> массив прав
//
&НаСервереБезКонтекста
Функция ПолучитьПраваПоТипам()

	ПраваПоТипам = Новый Соответствие;

	// Справочники
	ПраваСправочника = Новый Массив;
	ПраваСправочника.Добавить("Чтение");
	ПраваСправочника.Добавить("Добавление");
	ПраваСправочника.Добавить("Изменение");
	ПраваСправочника.Добавить("Удаление");
	ПраваСправочника.Добавить("Просмотр");
	ПраваСправочника.Добавить("ИнтерактивноеДобавление");
	ПраваСправочника.Добавить("Редактирование");
	ПраваСправочника.Добавить("ИнтерактивноеУдаление");
	ПраваСправочника.Добавить("ИнтерактивнаяПометкаУдаления");
	ПраваСправочника.Добавить("ИнтерактивноеСнятиеПометкиУдаления");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПомеченных");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивнаяПометкаУдаленияПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивноеСнятиеПометкиУдаленияПредопределенныхДанных");
	ПраваСправочника.Добавить("ИнтерактивноеУдалениеПомеченныхПредопределенныхДанных");
	ПраваПоТипам.Вставить("Справочник", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланВидовХарактеристик", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланСчетов", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланВидовРасчета", ПраваСправочника);
	ПраваПоТипам.Вставить("ПланОбмена", ПраваСправочника);

	// Документы
	ПраваДокумента = Новый Массив;
	Для Каждого Право Из ПраваСправочника Цикл
		ПраваДокумента.Добавить(Право);
	КонецЦикла;
	ПраваДокумента.Добавить("Проведение");
	ПраваДокумента.Добавить("ОтменаПроведения");
	ПраваДокумента.Добавить("ИнтерактивноеПроведение");
	ПраваДокумента.Добавить("ИнтерактивноеПроведениеНеОперативное");
	ПраваДокумента.Добавить("ИнтерактивнаяОтменаПроведения");
	ПраваДокумента.Добавить("ИнтерактивноеИзменениеПроведенных");
	ПраваДокумента.Добавить("ИнтерактивноеУдалениеПомеченных");
	ПраваПоТипам.Вставить("Документ", ПраваДокумента);

	// Бизнес-процессы: документные права + старт
	ПраваБизнесПроцесса = Новый Массив;
	Для Каждого ПравоБП Из ПраваДокумента Цикл
		ПраваБизнесПроцесса.Добавить(ПравоБП);
	КонецЦикла;
	ПраваБизнесПроцесса.Добавить("Старт");
	ПраваБизнесПроцесса.Добавить("ИнтерактивныйСтарт");
	ПраваПоТипам.Вставить("БизнесПроцесс", ПраваБизнесПроцесса);

	// Задачи: документные права + выполнение
	ПраваЗадачи = Новый Массив;
	Для Каждого ПравоЗад Из ПраваДокумента Цикл
		ПраваЗадачи.Добавить(ПравоЗад);
	КонецЦикла;
	ПраваЗадачи.Добавить("Выполнение");
	ПраваЗадачи.Добавить("ИнтерактивноеВыполнение");
	ПраваПоТипам.Вставить("Задача", ПраваЗадачи);

	// Регистры
	ПраваРегистраБазовые = Новый Массив;
	ПраваРегистраБазовые.Добавить("Чтение");
	ПраваРегистраБазовые.Добавить("Изменение");
	ПраваРегистраБазовые.Добавить("Просмотр");
	ПраваРегистраБазовые.Добавить("Редактирование");
	ПраваПоТипам.Вставить("РегистрСведений", ПраваРегистраБазовые);
	ПраваПоТипам.Вставить("РегистрРасчета", ПраваРегистраБазовые);

	// УправлениеИтогами применимо к регистрам накопления и бухгалтерии
	ПраваРегистраСИтогами = Новый Массив;
	Для Каждого ПравоРег Из ПраваРегистраБазовые Цикл
		ПраваРегистраСИтогами.Добавить(ПравоРег);
	КонецЦикла;
	ПраваРегистраСИтогами.Добавить("УправлениеИтогами");
	ПраваПоТипам.Вставить("РегистрНакопления", ПраваРегистраСИтогами);
	ПраваПоТипам.Вставить("РегистрБухгалтерии", ПраваРегистраСИтогами);

	// Обработки и отчёты
	ПраваОбработки = Новый Массив;
	ПраваОбработки.Добавить("Использование");
	ПраваОбработки.Добавить("Просмотр");
	ПраваПоТипам.Вставить("Обработка", ПраваОбработки);
	ПраваПоТипам.Вставить("Отчет", ПраваОбработки);

	Возврат ПраваПоТипам;

КонецФункции

// Найти пользователя ИБ по имени (с case-insensitive fallback)
//
// Параметры:
//  ИмяПользователя - Строка - имя пользователя для поиска
//
// Возвращаемое значение:
//  ПользовательИнформационнойБазы - пользователь или Неопределено
//
&НаСервереБезКонтекста
Функция НайтиПользователяИБПоИмени(ИмяПользователя)

	ИмяПользователя = СокрЛП(ИмяПользователя);
	Если Не ЗначениеЗаполнено(ИмяПользователя) Тогда
		Возврат Неопределено;
	КонецЕсли;

	// 1. Пытаемся найти через НайтиПоИмени (прямой поиск по имени пользователя ИБ)
	ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоИмени(ИмяПользователя);
	Если ПользовательИБ <> Неопределено Тогда
		Возврат ПользовательИБ;
	КонецЕсли;

	// 2. Поиск через справочник Пользователи (переданное имя может быть наименованием из справочника)
	Если Метаданные.Справочники.Найти("Пользователи") <> Неопределено Тогда
		Попытка
			ЭлементСправочника = Справочники.Пользователи.НайтиПоНаименованию(ИмяПользователя, Истина);
			Если ЭлементСправочника <> Справочники.Пользователи.ПустаяСсылка() Тогда
				ИдПользователяИБ = ЭлементСправочника.ИдентификаторПользователяИБ;
				Если ТипЗнч(ИдПользователяИБ) = Тип("Строка") Тогда
					ИдПользователяИБ = Новый УникальныйИдентификатор(СокрЛП(ИдПользователяИБ));
				КонецЕсли;
				Если ЗначениеЗаполнено(ИдПользователяИБ) Тогда
					ПользовательИБ = ПользователиИнформационнойБазы.НайтиПоУникальномуИдентификатору(ИдПользователяИБ);
					Если ПользовательИБ <> Неопределено Тогда
						Возврат ПользовательИБ;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		Исключение
			// Справочник Пользователи существует, но реквизит ИдентификаторПользователяИБ
			// может отсутствовать или быть недоступен — пропускаем этот шаг.
		КонецПопытки;
	КонецЕсли;

	// 3. Fallback: ручной перебор с case-insensitive сравнением
	ИмяПользователяВерх = ВРег(ИмяПользователя);
	// В некоторых режимах/версиях платфомы менеджер ПользователиИнформационнойБазы
	// не является итерируемой коллекцией (ошибка "Итератор для значения не определен").
	// Поэтому перебор делаем в Попытка/Исключение, чтобы не падать инструментом целиком.
	Попытка
		Для Каждого Пользователь Из ПользователиИнформационнойБазы Цикл
			Если ВРег(Пользователь.Имя) = ИмяПользователяВерх Тогда
				Возврат Пользователь;
			КонецЕсли;
		КонецЦикла;
	Исключение
		// Fallback перебора пользователей недоступен в текущем окружении.
		// Возвращаем Неопределено, чтобы вызывающий код вернул понятную ошибку "Пользователь не найден".
	КонецПопытки;

	Возврат Неопределено;

КонецФункции

// Сортировать массив структур по полю
//
// Параметры:
//  МассивСтруктур - Массив - массив структур для сортировки
//  ИмяПоля - Строка - имя поля для сортировки
//
// Возвращаемое значение:
//  Массив - отсортированный массив
//
&НаСервереБезКонтекста
Функция СортироватьМассивСтруктурПоПолю(МассивСтруктур, ИмяПоля)

	// Простой алгоритм сортировки пузырьком
	Результат = Новый Массив;
	Для Каждого Элемент Из МассивСтруктур Цикл
		Результат.Добавить(Элемент);
	КонецЦикла;

	Если Результат.Количество() <= 1 Тогда
		Возврат Результат;
	КонецЕсли;

	Для н = 0 По Результат.Количество() - 2 Цикл
		Для м = 0 По Результат.Количество() - 2 - н Цикл
			Элемент1 = Результат[м];
			Элемент2 = Результат[м + 1];

			Значение1 = Неопределено;
			Значение2 = Неопределено;

			Если Элемент1.Свойство(ИмяПоля) Тогда
				Значение1 = Элемент1[ИмяПоля];
			КонецЕсли;
			Если Элемент2.Свойство(ИмяПоля) Тогда
				Значение2 = Элемент2[ИмяПоля];
			КонецЕсли;

			// Сравнение с учётом типа
			Сравнение = 0;
			Если ЗначениеЗаполнено(Значение1) И ЗначениеЗаполнено(Значение2) Тогда
				Строка1 = Строка(Значение1);
				Строка2 = Строка(Значение2);
				Если Строка1 > Строка2 Тогда
					Сравнение = 1;
				ИначеЕсли Строка1 < Строка2 Тогда
					Сравнение = -1;
				Иначе
					Сравнение = 0;
				КонецЕсли;
			ИначеЕсли Не ЗначениеЗаполнено(Значение1) И ЗначениеЗаполнено(Значение2) Тогда
				Сравнение = 1; // Пустые в конце
			ИначеЕсли ЗначениеЗаполнено(Значение1) И Не ЗначениеЗаполнено(Значение2) Тогда
				Сравнение = -1; // Пустые в конце
			КонецЕсли;

			Если Сравнение > 0 Тогда
				Результат.Установить(м, Элемент2);
				Результат.Установить(м + 1, Элемент1);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// ═══════════════════════════════════════════════════════════════════════════════
// ВСТРОЕННЫЙ HTTP-СЕРВЕР (Native API компонента MCPHttpTransport)
// MCP Streamable HTTP + REST API
// ═══════════════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────────────────
// ПЕРЕКЛЮЧЕНИЕ РЕЖИМА (UI)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ПриИзмененииРежимаПодключения(Элемент)

	ПроксиРежим = (РежимПодключения = 0);

	// Видимость групп
	Элементы.ГруппаПроксиНастройки.Видимость = ПроксиРежим;
	Элементы.ГруппаВстроенныйСервер.Видимость = НЕ ПроксиРежим;

	// Заголовки кнопок
	Если ПроксиРежим Тогда
		Элементы.КнопкаПодключиться.Заголовок = "Подключиться";
		Элементы.КнопкаОтключиться.Заголовок = "Отключиться";
	Иначе
		Элементы.КнопкаПодключиться.Заголовок = "Запустить сервер";
		Элементы.КнопкаОтключиться.Заголовок = "Остановить сервер";
	КонецЕсли;

КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ЗАПУСК / ОСТАНОВКА ВСТРОЕННОГО СЕРВЕРА
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ЗапуститьВстроенныйСервер()
	Если ВстроенныйСерверЗапущен ИЛИ ЗапускСервераВПроцессе Тогда
		ДобавитьВЛог("Сервер уже запущен или запускается");
		Возврат;
	КонецЕсли;

	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		ЗапускСервераВПроцессе = Истина;
		НачатьАсинхронноеПодключениеКомпоненты(
			Новый ОписаниеОповещения("ПослеПодключенияМакетаМСП_ЗапускСервера", ЭтаФорма),
			"ВнешняяОбработка.MCPToolkit.Макет.MCPHttpTransport", "MCPHttp");
	Иначе
		ЗапуститьВстроенныйСерверСинхронно(); // 8.2.x / "Использовать"
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура НачатьАсинхронноеПодключениеКомпоненты(ОписаниеОповещения, Местоположение, Имя)
	Выполнить("НачатьПодключениеВнешнейКомпоненты(ОписаниеОповещения, Местоположение, Имя, ТипВнешнейКомпоненты.Native)");
КонецПроцедуры

// Колбэки async-цепочки запуска сервера

&НаКлиенте
Процедура ПослеПодключенияМакетаМСП_ЗапускСервера(Подключено, ДопПар) Экспорт
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Если Подключено Тогда
		ЗапускСервера_ПодключитьТун();
	Иначе
		// Fallback: получить .dll с сервера, записать во временный файл
		ДвоичныеДанные = ПолучитьМакетНаСервере();
		ИмяФайла = ПолучитьИмяВременногоФайла("dll");
		ДвоичныеДанные.Записать(ИмяФайла);
		НачатьАсинхронноеПодключениеКомпоненты(
			Новый ОписаниеОповещения("ПослеПодключенияФайлаМСП_ЗапускСервера", ЭтаФорма),
			ИмяФайла, "MCPHttp");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПослеПодключенияФайлаМСП_ЗапускСервера(Подключено, ДопПар) Экспорт
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Если НЕ Подключено Тогда
		ЗапускСервераВПроцессе = Ложь;
		ДобавитьВЛог("Не удалось подключить внешнюю компоненту MCPHttp");
		Возврат;
	КонецЕсли;
	ЗапускСервера_ПодключитьТун();
КонецПроцедуры

&НаКлиенте
Процедура ЗапускСервера_ПодключитьТун()
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Компонента = Новый("AddIn.MCPHttp.MCPHttpTransport");
	НачатьАсинхронноеПодключениеКомпоненты(
		Новый ОписаниеОповещения("ПослеПодключенияМакетаТун_ЗапускСервера", ЭтаФорма),
		"ВнешняяОбработка.MCPToolkit.Макет.ToonConverter", "ToonConv");
КонецПроцедуры

&НаКлиенте
Процедура ПослеПодключенияМакетаТун_ЗапускСервера(Подключено, ДопПар) Экспорт
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Если Подключено Тогда
		ЗапускСервера_Финал(Истина);
	Иначе
		// Fallback: ToonConverter из файла
		ДвоичныеДанные = ПолучитьМакетТунКонвертераНаСервере();
		ИмяФайла = ПолучитьИмяВременногоФайла("dll");
		ДвоичныеДанные.Записать(ИмяФайла);
		НачатьАсинхронноеПодключениеКомпоненты(
			Новый ОписаниеОповещения("ПослеПодключенияФайлаТун_ЗапускСервера", ЭтаФорма),
			ИмяФайла, "ToonConv");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПослеПодключенияФайлаТун_ЗапускСервера(Подключено, ДопПар) Экспорт
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	ЗапускСервера_Финал(Подключено); // ToonConverter некритична: даже если нет — продолжаем
КонецПроцедуры

&НаКлиенте
Процедура ЗапускСервера_Финал(ТунПодключён)
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Если ТунПодключён Тогда
		КомпонентаТун = Новый("AddIn.ToonConv.ToonConverter");
	КонецЕсли;
	Компонента.НачатьВызовStart(
		Новый ОписаниеОповещения("ПослеЗапускаВстроенногоСервера", ЭтаФорма),
		ПортВстроенногоСервера);
КонецПроцедуры

&НаКлиенте
Процедура ПослеЗапускаВстроенногоСервера(РезВызова, ПарВызова, ДопПар) Экспорт
	Если НЕ ЗапускСервераВПроцессе Тогда Возврат; КонецЕсли;
	Если РезВызова = Истина Тогда
		ВстроенныйСерверЗапущен = Истина;
		МСПСессии = Новый Соответствие;
		SSEПотоки = Новый Соответствие;
		ЛегасиССЕПотоки = Новый Соответствие;
		ОжидающиеПодтверждения = Новый Соответствие;
		ЗапускСервераВПроцессе = Ложь;
		УстановитьСтатус("Сервер запущен (порт " + Формат(ПортВстроенногоСервера, "ЧГ=") + ")", Истина);
		ДобавитьВЛог("Встроенный HTTP-сервер запущен на порту " + Формат(ПортВстроенногоСервера, "ЧГ="));
	Иначе
		ЗапускСервераВПроцессе = Ложь;
		Компонента = Неопределено;
		ДобавитьВЛог("Не удалось запустить сервер на порту " + Формат(ПортВстроенногоСервера, "ЧГ="));
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ЗапуститьВстроенныйСерверСинхронно()

	Если ВстроенныйСерверЗапущен Тогда
		ДобавитьВЛог("Сервер уже запущен");
		Возврат;
	КонецЕсли;

	// Подключение компоненты
	Попытка
		Результат = ПодключитьВнешнююКомпоненту(
			"ВнешняяОбработка.MCPToolkit.Макет.MCPHttpTransport",
			"MCPHttp", ТипВнешнейКомпоненты.Native);
		Если НЕ Результат Тогда
			// Fallback: загрузка из макета через файл
			ДвоичныеДанные = ПолучитьМакетНаСервере();
			ИмяФайла = ПолучитьИмяВременногоФайла("dll");
			ДвоичныеДанные.Записать(ИмяФайла);
			ПодключитьВнешнююКомпоненту(ИмяФайла, "MCPHttp", ТипВнешнейКомпоненты.Native);
		КонецЕсли;
		Компонента = Новый("AddIn.MCPHttp.MCPHttpTransport");
	Исключение
		ДобавитьВЛог("Ошибка подключения компоненты: " + ОписаниеОшибки());
		Возврат;
	КонецПопытки;

	// Подключение ToonConverter
	КомпонентаТун = Неопределено;
	Попытка
		РезТун = ПодключитьВнешнююКомпоненту(
			"ВнешняяОбработка.MCPToolkit.Макет.ToonConverter",
			"ToonConv", ТипВнешнейКомпоненты.Native);
		Если НЕ РезТун Тогда
			ДвоичныеДанные = ПолучитьМакетТунКонвертераНаСервере();
			ИмяФайла = ПолучитьИмяВременногоФайла("dll");
			ДвоичныеДанные.Записать(ИмяФайла);
			ПодключитьВнешнююКомпоненту(ИмяФайла, "ToonConv", ТипВнешнейКомпоненты.Native);
		КонецЕсли;
		КомпонентаТун = Новый("AddIn.ToonConv.ToonConverter");
	Исключение
		ДобавитьВЛог("Предупреждение: ToonConverter не загружена. TOON-формат недоступен. " + ОписаниеОшибки());
	КонецПопытки;

	// Запуск HTTP-сервера
	Если Компонента.Start(ПортВстроенногоСервера) Тогда
		ВстроенныйСерверЗапущен = Истина;
		МСПСессии = Новый Соответствие;
		SSEПотоки = Новый Соответствие;
		ЛегасиССЕПотоки = Новый Соответствие;
		ОжидающиеПодтверждения = Новый Соответствие;
		УстановитьСтатус("Сервер запущен (порт " + Формат(ПортВстроенногоСервера, "ЧГ=") + ")", Истина);
		ДобавитьВЛог("Встроенный HTTP-сервер запущен на порту " + Формат(ПортВстроенногоСервера, "ЧГ="));
	Иначе
		ДобавитьВЛог("Не удалось запустить сервер на порту " + Формат(ПортВстроенногоСервера, "ЧГ="));
		Компонента = Неопределено;
	КонецЕсли;

КонецПроцедуры

&НаСервере
Функция ПолучитьМакетНаСервере()
	Обработка = РеквизитФормыВЗначение("Объект");
	Возврат Обработка.ПолучитьМакет("MCPHttpTransport");
КонецФункции

&НаСервере
Функция ПолучитьМакетТунКонвертераНаСервере()
	Обработка = РеквизитФормыВЗначение("Объект");
	Возврат Обработка.ПолучитьМакет("ToonConverter");
КонецФункции

&НаСервере
Функция ПроверитьНужноАсинхронноеПодключениеКомпонент()
	// Читаем настройку через Выполнить, чтобы избежать ошибки компиляции на 8.2.x:
	// прямое обращение Метаданные.РежимИспользованияСинхронныхВызовов
	// может не компилироваться на платформах, где это свойство не определено.
	//
	// Значения РежимИспользованияСинхронныхВызовов:
	//   "Использовать"                  — sync ОК, async не нужен
	//   "ИспользоватьСПредупреждениями" — sync пишет предупреждения → лучше async
	//   "НеИспользовать"               — sync ЗАБЛОКИРОВАН → async обязателен
	// Полное имя свойства (из документации ОбъектМетаданныхКонфигурация):
	// РежимИспользованияСинхронныхВызововРасширенийПлатформыИВнешнихКомпонент
	// Доступность: Сервер, толстый клиент, внешнее соединение.
	// Через Выполнить — чтобы не дать compile error на 8.2.x.
	Попытка
		Рез = "";
		Выполнить("Рез = Строка(Метаданные.РежимИспользованияСинхронныхВызововРасширенийПлатформыИВнешнихКомпонент)");
		Возврат Рез <> "Использовать";
	Исключение
		Возврат Ложь; // 8.2.x или старые 8.3.x: свойства нет → синхронный вызов безопасен
	КонецПопытки;
КонецФункции

&НаКлиенте
Процедура ОстановитьВстроенныйСервер()

	Если НЕ ВстроенныйСерверЗапущен Тогда
		Возврат;
	КонецЕсли;

	// Весь teardown-код ДО вызова Stop
	SSEПотоки = Новый Соответствие;
	ЛегасиССЕПотоки = Новый Соответствие;
	МСПСессии = Новый Соответствие;
	ОжидающиеПодтверждения = Новый Соответствие;
	ВстроенныйСерверЗапущен = Ложь;
	УстановитьСтатус("Отключено", Ложь);
	ДобавитьВЛог("Встроенный HTTP-сервер остановлен");

	Если Компонента <> Неопределено Тогда
		Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
			Компонента.НачатьВызовStop(
				Новый ОписаниеОповещения("ИгнорироватьРезультатКомпоненты", ЭтаФорма));
		Иначе
			Компонента.Stop();
		КонецЕсли;
	КонецЕсли;

	Компонента = Неопределено;
	КомпонентаТун = Неопределено;

КонецПроцедуры

// Пустой колбэк для fire-and-forget вызовов компоненты
&НаКлиенте
Процедура ИгнорироватьРезультатКомпоненты(РезВызова, ПарВызова, ДопПар) Экспорт
КонецПроцедуры

// Обёртка SendResponse
&НаКлиенте
Процедура КомпонентаSendResponse(РзId, КодОтвета, Заголовки, Тело)
	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		Компонента.НачатьВызовSendResponse(
			Новый ОписаниеОповещения("ИгнорироватьРезультатКомпоненты", ЭтаФорма),
			РзId, КодОтвета, Заголовки, Тело);
	Иначе
		Компонента.SendResponse(РзId, КодОтвета, Заголовки, Тело);
	КонецЕсли;
КонецПроцедуры

// Обёртка SendSSEEvent
&НаКлиенте
Процедура КомпонентаSendSSEEvent(РзId, Данные, Заголовки, ТипСобытия = "message")
	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		Компонента.НачатьВызовSendSSEEvent(
			Новый ОписаниеОповещения("ИгнорироватьРезультатКомпоненты", ЭтаФорма),
			РзId, Данные, Заголовки, ТипСобытия);
	Иначе
		Компонента.SendSSEEvent(РзId, Данные, Заголовки, ТипСобытия);
	КонецЕсли;
КонецПроцедуры

// Обёртка CloseSSEStream
&НаКлиенте
Процедура КомпонентаCloseSSEStream(РзId)
	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		Компонента.НачатьВызовCloseSSEStream(
			Новый ОписаниеОповещения("ИгнорироватьРезультатКомпоненты", ЭтаФорма),
			РзId);
	Иначе
		Компонента.CloseSSEStream(РзId);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПрименитьТунКонвертацию(Результат)
	Если ТипЗнч(Результат) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	Если ФорматОтветаВстроенный <> 1 Или КомпонентаТун = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если НЕ Результат.Свойство("success") Или НЕ Результат.success Тогда
		Возврат;
	КонецЕсли;
	Если НЕ Результат.Свойство("data") Тогда
		Возврат;
	КонецЕсли;
	ДанныеТун = КомпонентаТун.JsonToToon(ЗаписатьJSON2(Результат.data));
	Если ЗначениеЗаполнено(ДанныеТун) Тогда
		Результат.data = ДанныеТун;
	КонецЕсли;
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ОБРАБОТКА ВНЕШНИХ СОБЫТИЙ (диспетчер)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ОбработкаВнешнегоСобытия(Источник, Событие, Данные)

	Если Источник <> "MCPHttpTransport" Тогда Возврат КонецЕсли;

	ДанныеЗапроса = ПрочитатьJSON2(Данные);

	// SSE_CLOSED обрабатываем ДО bodyTruncated — у SSE_CLOSED нет этого поля
	Если Событие = "SSE_CLOSED" Тогда
		// Удаляем из SSEПотоки по requestId (идемпотентно)
		Для Каждого КлючЗначение Из SSEПотоки Цикл
			Если КлючЗначение.Значение = ДанныеЗапроса.id Тогда
				SSEПотоки.Удалить(КлючЗначение.Ключ);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		// Удаляем из ЛегасиССЕПотоки по requestId GET-потока
		Для Каждого КлючЗначение Из ЛегасиССЕПотоки Цикл
			Если КлючЗначение.Значение = ДанныеЗапроса.id Тогда
				ЛегасиССЕПотоки.Удалить(КлючЗначение.Ключ);
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Возврат;
	КонецЕсли;

	// bodyTruncated — только для HTTP-запросов (REQUEST, MCP_POST, SSE_CONNECT)
	// Сохраняем Событие в ДанныеЗапроса для передачи в async-колбэк
	ДанныеЗапроса.Вставить("_событие", Событие);

	БольшоеТело = Ложь;
	Если ДанныеЗапроса.Свойство("bodyTruncated", БольшоеТело) И БольшоеТело = Истина Тогда
		Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
			// async-ветка: получаем тело через колбэк, маршрутизация в колбэке
			Компонента.НачатьВызовGetRequestBody(
				Новый ОписаниеОповещения("ПослеПолученияТелаЗапроса", ЭтаФорма, ДанныеЗапроса),
				ДанныеЗапроса.id);
			Возврат;
		Иначе
			ДанныеЗапроса.body = Компонента.GetRequestBody(ДанныеЗапроса.id);
		КонецЕсли;
	КонецЕсли;

	ПродолжитьОбработкуЗапроса(ДанныеЗапроса);

КонецПроцедуры

&НаКлиенте
Процедура ПослеПолученияТелаЗапроса(РезВызова, ПарВызова, ДопПар) Экспорт
	// ДопПар = ДанныеЗапроса (Структура/Соответствие)
	// НЕ использовать ЗапускСервераВПроцессе — это не startup chain!
	ДопПар.body = РезВызова;
	ПродолжитьОбработкуЗапроса(ДопПар);
КонецПроцедуры

&НаКлиенте
Процедура ПродолжитьОбработкуЗапроса(ДанныеЗапроса)
	Событие = "";
	ДанныеЗапроса.Свойство("_событие", Событие);
	Если Событие = "SSE_CONNECT" Тогда
		ОбработатьSSEConnect(ДанныеЗапроса);
	ИначеЕсли Событие = "SSE_LEGACY_CONNECT" Тогда
		ОбработатьSSELegacyConnect(ДанныеЗапроса);
	ИначеЕсли Событие = "SSE_LEGACY_MESSAGE" Тогда
		ОбработатьSSELegacyMessage(ДанныеЗапроса);
	ИначеЕсли Событие = "MCP_POST" Тогда
		ОбработатьMCPPost(ДанныеЗапроса);
	Иначе // "REQUEST"
		ОбработатьОбычныйЗапрос(ДанныеЗапроса);
	КонецЕсли;
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ОБРАБОТКА ОБЫЧНЫХ ЗАПРОСОВ (REST, health, DELETE /mcp)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ОбработатьОбычныйЗапрос(ДанныеЗапроса)

	Путь = ДанныеЗапроса.path;

	Если Путь = "/health" Тогда
		КомпонентаSendResponse(ДанныеЗапроса.id, 200,
			ЗаголовкиJSON(), СформироватьОтветHealth());

	ИначеЕсли Лев(Путь, 5) = "/api/" Тогда
		Ответ = ОбработатьRESTЗапрос(ДанныеЗапроса);
		Если Ответ <> Неопределено Тогда
			КомпонентаSendResponse(ДанныеЗапроса.id,
				Ответ.КодОтвета, ЗаголовкиJSON(), Ответ.Тело);
		КонецЕсли;

	ИначеЕсли Путь = "/mcp" И ДанныеЗапроса.method = "DELETE" Тогда
		ОбработатьDeleteСессии(ДанныеЗапроса);

	Иначе
		КомпонентаSendResponse(ДанныеЗапроса.id, 404,
			ЗаголовкиJSON(), "{""error"":""Not Found""}");
	КонецЕсли;

КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// MCP POST /mcp (Streamable HTTP)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ОбработатьMCPPost(ДанныеЗапроса)

	// 1. Content-Type
	КонтентТип = ДанныеЗапроса.headers["content-type"];
	Если КонтентТип = Неопределено
		ИЛИ НЕ (Лев(НРег(КонтентТип), 16) = "application/json") Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 415,
			"Unsupported Media Type: Content-Type must be application/json",
			-32600);
		Возврат;
	КонецЕсли;

	// 2. Accept: оба application/json И text/event-stream
	Если НЕ ПроверитьAcceptPOST(ДанныеЗапроса) Тогда Возврат КонецЕсли;

	// 4. Парсинг JSON body
	Попытка
		ТелоJSON = ПрочитатьJSON2(ДанныеЗапроса.body);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 400,
			"Parse error: " + ТекстОшибки,
			-32700);
		Возврат;
	КонецПопытки;

	Если ТипЗнч(ТелоJSON) <> Тип("Структура") Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 400,
			"Validation error: JSON body must be an object",
			-32602);
		Возврат;
	КонецЕсли;

	// 5. Определяем тип JSON-RPC: Request / Notification / Response
	Метод = Неопределено;
	Ид = Неопределено;
	ЕстьМетод = ТелоJSON.Свойство("method", Метод);
	ЕстьИд = ТелоJSON.Свойство("id", Ид) И (Ид <> Null);

	// 6. Notification или Response → 202
	Если НЕ ЕстьМетод ИЛИ НЕ ЕстьИд Тогда
		// Для non-request сообщений требуется валидная сессия/версия протокола
		// (initialize сюда не попадает, т.к. initialize всегда request).
		Если НЕ ПроверитьПротоколВерсию(ДанныеЗапроса) Тогда Возврат КонецЕсли;
		Если НЕ ПроверитьСессию(ДанныеЗапроса) Тогда Возврат КонецЕсли;
		КомпонентаSendResponse(ДанныеЗапроса.id, 202, ЗаголовкиJSON(), "");
		Возврат;
	КонецЕсли;

	// === 7. JSON-RPC Request (method + id) → SSE-ответ ===

	// 8. mcp-session-id / mcp-protocol-version:
	// В streamable_http initialize договаривается по protocolVersion в params,
	// поэтому версию из заголовка для initialize НЕ валидируем.
	Если Метод <> "initialize" Тогда
		Если НЕ ПроверитьПротоколВерсию(ДанныеЗапроса) Тогда Возврат КонецЕсли;
		Если НЕ ПроверитьСессию(ДанныеЗапроса) Тогда Возврат КонецЕсли;
	КонецЕсли;

	Если Метод = "initialize" Тогда
		РезультатInit = ОбработатьInitialize(ТелоJSON, ДанныеЗапроса);
		ОтправитьSSEОтвет(ДанныеЗапроса,
			СформироватьJSONRPCОтвет(Ид, РезультатInit.Результат),
			РезультатInit.ИдСессии);
		Возврат;

	ИначеЕсли Метод = "tools/list" Тогда
		Результат = ПолучитьСхемыИнструментов();

	ИначеЕсли Метод = "tools/call" Тогда
		Результат = ОбработатьToolsCall(ДанныеЗапроса, ТелоJSON, Ид);
		Если Результат = Неопределено Тогда Возврат КонецЕсли; // async approval

	ИначеЕсли Метод = "ping" Тогда
		Результат = Новый Структура;

	Иначе
		ОтправитьSSEОтвет(ДанныеЗапроса,
			СформироватьJSONRPCОшибку(Ид, -32601, "Method not found"));
		Возврат;
	КонецЕсли;

	ОтправитьSSEОтвет(ДанныеЗапроса,
		СформироватьJSONRPCОтвет(Ид, Результат));

КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// GET /mcp (SSE notification stream)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ОбработатьSSEConnect(ДанныеЗапроса)

	Если НЕ ПроверитьAcceptSSE(ДанныеЗапроса) Тогда Возврат КонецЕсли;
	Если НЕ ПроверитьПротоколВерсию(ДанныеЗапроса) Тогда Возврат КонецЕсли;

	// mcp-session-id опционален: клиент открывает SSE до initialize (до получения session ID)
	ИдСессии = ДанныеЗапроса.headers["mcp-session-id"];

	Если ИдСессии <> Неопределено Тогда
		// Session ID предоставлен — проверяем валидность
		Если НЕ ВалидныйФорматСессии(ИдСессии) ИЛИ МСПСессии.Получить(ИдСессии) = Неопределено Тогда
			ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 404,
				"Not Found: Invalid or expired session ID",
				-32600);
			Возврат;
		КонецЕсли;
		// Проверка: один GET stream на сессию
		Если SSEПотоки.Получить(ИдСессии) <> Неопределено Тогда
			ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 409,
				"Conflict: Only one SSE stream is allowed per session",
				-32600);
			Возврат;
		КонецЕсли;
	КонецЕсли;

	// Стартуем SSE-поток (пустой eventData = только заголовки)
	КомпонентаSendSSEEvent(ДанныеЗапроса.id, "",
		СформироватьSSEЗаголовки(ДанныеЗапроса));

	// Ключ: session ID если есть, иначе request ID (очистка по SSE_CLOSED работает по значению)
	КлючПотока = ?(ИдСессии <> Неопределено, ИдСессии, ДанныеЗапроса.id);
	SSEПотоки.Вставить(КлючПотока, ДанныеЗапроса.id);

КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ОБРАБОТКА LEGACY SSE (MCP 2024-11-05 transport type = "sse")
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Процедура ОбработатьSSELegacyConnect(ДанныеЗапроса)
	Если НЕ ПроверитьAcceptSSE(ДанныеЗапроса) Тогда Возврат КонецЕсли;

	// Открываем SSE-поток (Content-Type выставит C++ через set_chunked_content_provider)
	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		// async-ветка: первый SendSSEEvent с колбэком, логика маппинга и второй SendSSEEvent — в колбэке
		Компонента.НачатьВызовSendSSEEvent(
			Новый ОписаниеОповещения("ПослеОткрытияSSELegacyПотока", ЭтаФорма, ДанныеЗапроса),
			ДанныеЗапроса.id, "", СформироватьSSEЗаголовки(ДанныеЗапроса), "message");
		Возврат;
	КонецЕсли;

	// sync-ветка: оригинальный код
	КомпонентаSendSSEEvent(ДанныеЗапроса.id, "", СформироватьSSEЗаголовки(ДанныеЗапроса));

	// Генерируем transport session_id (hex без дефисов)
	ТрИдСессии = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");

	// Маппинг: transport session → request ID GET-потока
	ЛегасиССЕПотоки.Вставить(ТрИдСессии, ДанныеЗапроса.id);

	// Шлём event: endpoint — клиент будет постить на этот URL
	УРЛ = "/mcp/message?session_id=" + ТрИдСессии;
	КомпонентаSendSSEEvent(ДанныеЗапроса.id, УРЛ, "{}", "endpoint");
КонецПроцедуры

&НаКлиенте
Процедура ПослеОткрытияSSELegacyПотока(РезВызова, ПарВызова, ДопПар) Экспорт
	// ДопПар = ДанныеЗапроса
	// Генерируем transport session_id (hex без дефисов)
	ТрИдСессии = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");

	// Маппинг: transport session → request ID GET-потока
	ЛегасиССЕПотоки.Вставить(ТрИдСессии, ДопПар.id);

	// Шлём event: endpoint — клиент будет постить на этот URL
	УРЛ = "/mcp/message?session_id=" + ТрИдСессии;
	КомпонентаSendSSEEvent(ДопПар.id, УРЛ, "{}", "endpoint");
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьSSELegacyMessage(ДанныеЗапроса)
	// Найти GET-поток по session_id из query
	МассивSessionId = ДанныеЗапроса.query["session_id"];
	Если МассивSessionId = Неопределено ИЛИ МассивSessionId.Количество() = 0 Тогда Возврат КонецЕсли;
	ТрИдСессии = МассивSessionId[0];

	ИдПотока = ЛегасиССЕПотоки.Получить(ТрИдСессии);
	Если ИдПотока = Неопределено Тогда Возврат КонецЕсли; // 202 уже отправлен C++

	// Разобрать JSON тело
	ТелоJSON = ПрочитатьJSON2(ДанныеЗапроса.body);
	Если ТелоJSON = Неопределено Тогда Возврат КонецЕсли;

	Метод = "";
	ТелоJSON.Свойство("method", Метод);
	Ид = Неопределено;
	ТелоJSON.Свойство("id", Ид);

	// Нотификации (нет id или id = null) — ничего не отвечаем
	Если Ид = Неопределено ИЛИ Ид = Null Тогда Возврат КонецЕсли;

	ОтветJSON = Неопределено;
	Если Метод = "initialize" Тогда
		ОтветJSON = ОбработатьLegacyInitialize(ТелоJSON, Ид);
	ИначеЕсли Метод = "tools/list" Тогда
		ОтветJSON = СформироватьJSONRPCОтвет(Ид, ПолучитьСхемыИнструментов());
	ИначеЕсли Метод = "tools/call" Тогда
		РезультатВызова = ОбработатьToolsCall(ДанныеЗапроса, ТелоJSON, Ид, ИдПотока);
		Если РезультатВызова <> Неопределено Тогда
			ОтветJSON = СформироватьJSONRPCОтвет(Ид, РезультатВызова);
		КонецЕсли; // Неопределено = async, диалог пришлёт сам через ИдПотокаSSE
	ИначеЕсли Метод = "ping" Тогда
		ОтветJSON = СформироватьJSONRPCОтвет(Ид, Новый Структура);
	Иначе
		ОтветJSON = СформироватьJSONRPCОшибку(Ид, -32601, "Method not found");
	КонецЕсли;

	Если ОтветJSON <> Неопределено Тогда
		КомпонентаSendSSEEvent(ИдПотока, ОтветJSON, "{}", "message");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Функция ОбработатьLegacyInitialize(ТелоJSON, Ид)
	// Аналог ОбработатьInitialize, но без создания MCP-сессии и без mcp-session-id в ответе.
	// Всегда используем протокол 2024-11-05 (legacy SSE transport)

	Результат = Новый Структура;
	Результат.Вставить("protocolVersion", "2024-11-05");
	Результат.Вставить("capabilities", Новый Структура("tools",
		Новый Структура("listChanged", Ложь)));
	Результат.Вставить("serverInfo", Новый Структура("name, version",
		"1C MCP Toolkit (Native)", "1.0.0"));

	Возврат СформироватьJSONRPCОтвет(Ид, Результат);
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ВАЛИДАЦИЯ ЗАГОЛОВКОВ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьТелоJSONRPCОшибка(Сообщение, КодОшибки)
	
	// Формат ошибок как в streamable_http (python mcp):
	// {"jsonrpc":"2.0","id":"server-error","error":{"code":-32600,"message":"..."}}
	
	Тело = Новый Структура;
	Тело.Вставить("jsonrpc", "2.0");
	Тело.Вставить("id", "server-error");
	Тело.Вставить("error", Новый Структура("code, message", КодОшибки, Сообщение));
	Возврат ЗаписатьJSON2(Тело);
	
КонецФункции

&НаКлиенте
Функция ЗаголовкиJSONMCP(ДанныеЗапроса)
	
	// Как в streamable_http: Content-Type: application/json + (если сессия валидна) mcp-session-id.
	
	Если МСПСессии = Неопределено Тогда
		Возврат ЗаголовкиJSON();
	КонецЕсли;
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/json");
	
	ИдСессии = ДанныеЗапроса.headers["mcp-session-id"];
	Если ИдСессии <> Неопределено
		И ВалидныйФорматСессии(ИдСессии)
		И МСПСессии.Получить(ИдСессии) <> Неопределено Тогда
		Заголовки.Вставить("mcp-session-id", ИдСессии);
	КонецЕсли;
	
	Возврат ЗаписатьJSON2(Заголовки);
	
КонецФункции

&НаКлиенте
Процедура ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, КодОтветаHTTP, Сообщение, КодОшибки = -32600)

	КомпонентаSendResponse(ДанныеЗапроса.id, КодОтветаHTTP,
		ЗаголовкиJSONMCP(ДанныеЗапроса),
		СформироватьТелоJSONRPCОшибка(Сообщение, КодОшибки));

КонецПроцедуры

&НаКлиенте
Функция ПроверитьAcceptPOST(ДанныеЗапроса)
	Акцепт = ДанныеЗапроса.headers["accept"];
	Если Акцепт = Неопределено Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 406,
			"Not Acceptable: Client must accept both application/json and text/event-stream",
			-32600);
		Возврат Ложь;
	КонецЕсли;
	АкцептНР = НРег(СокрЛП(Акцепт));
	Если Найти(АкцептНР, "application/json") = 0
		ИЛИ Найти(АкцептНР, "text/event-stream") = 0 Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 406,
			"Not Acceptable: Client must accept both application/json and text/event-stream",
			-32600);
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

&НаКлиенте
Функция ПроверитьAcceptSSE(ДанныеЗапроса)
	Акцепт = ДанныеЗапроса.headers["accept"];
	Если Акцепт = Неопределено
		ИЛИ Найти(НРег(СокрЛП(Акцепт)), "text/event-stream") = 0 Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 406,
			"Not Acceptable: Client must accept text/event-stream",
			-32600);
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

&НаКлиенте
Функция ПроверитьПротоколВерсию(ДанныеЗапроса)
	Версия = ДанныеЗапроса.headers["mcp-protocol-version"];
	Если Версия = Неопределено Тогда Возврат Истина КонецЕсли;
	Если Версия <> "2024-11-05" И Версия <> "2025-03-26"
		И Версия <> "2025-06-18" И Версия <> "2025-11-25" Тогда
		ПоддерживаемыеВерсии = "2024-11-05, 2025-03-26, 2025-06-18, 2025-11-25";
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 400,
			"Bad Request: Unsupported protocol version: " + Версия + ". Supported versions: " + ПоддерживаемыеВерсии,
			-32600);
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

&НаКлиенте
Функция ПроверитьСессию(ДанныеЗапроса)
	ИдСессии = ДанныеЗапроса.headers["mcp-session-id"];
	Если ИдСессии = Неопределено Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 400,
			"Bad Request: Missing session ID",
			-32600);
		Возврат Ложь;
	КонецЕсли;
	Если НЕ ВалидныйФорматСессии(ИдСессии) ИЛИ МСПСессии.Получить(ИдСессии) = Неопределено Тогда
		ОтправитьMCPОшибкаJSONRPC(ДанныеЗапроса, 404,
			"Not Found: Invalid or expired session ID",
			-32600);
		Возврат Ложь;
	КонецЕсли;
	Возврат Истина;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ВалидныйФорматСессии(ИдСессии)
	// Только ASCII 0x21-0x7E (видимые, без пробелов)
	Если ПустаяСтрока(ИдСессии) Тогда Возврат Ложь КонецЕсли;
	Для Позиция = 1 По СтрДлина(ИдСессии) Цикл
		Код = КодСимвола(ИдСессии, Позиция);
		Если Код < 33 ИЛИ Код > 126 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат Истина;
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// УПРАВЛЕНИЕ СЕССИЯМИ MCP
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция СоздатьМСПСессию()
	// Лимит: 5 сессий, удаляем самую старую
	Если МСПСессии.Количество() >= 5 Тогда
		УдалитьСамуюСтаруюСессию();
	КонецЕсли;

	ИдСессии = Строка(Новый УникальныйИдентификатор);
	МСПСессии.Вставить(ИдСессии, ТекущаяДата());

	Возврат ИдСессии;
КонецФункции

&НаКлиенте
Процедура УдалитьСамуюСтаруюСессию()
	СтарыйКлюч = Неопределено;
	СтараяДата = Неопределено;
	Для Каждого КлючЗначение Из МСПСессии Цикл
		ДатаСоздания = КлючЗначение.Значение;
		Если СтараяДата = Неопределено ИЛИ ДатаСоздания < СтараяДата Тогда
			СтараяДата = ДатаСоздания;
			СтарыйКлюч = КлючЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;

	Если СтарыйКлюч <> Неопределено Тогда
		УдалитьМСПСессию(СтарыйКлюч);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура УдалитьМСПСессию(ИдСессии)
	// Удалить SSE поток синхронно ДО CloseSSEStream
	ИдПотока = SSEПотоки.Получить(ИдСессии);
	SSEПотоки.Удалить(ИдСессии);
	Если ИдПотока <> Неопределено Тогда
		КомпонентаCloseSSEStream(ИдПотока);
	КонецЕсли;
	МСПСессии.Удалить(ИдСессии);
КонецПроцедуры

&НаКлиенте
Процедура ОчиститьВсеМСПСессии()
	SSEПотоки = Новый Соответствие;
	МСПСессии = Новый Соответствие;
КонецПроцедуры

&НаКлиенте
Процедура ОбработатьDeleteСессии(ДанныеЗапроса)
	Если НЕ ПроверитьПротоколВерсию(ДанныеЗапроса) Тогда Возврат КонецЕсли;
	Если НЕ ПроверитьСессию(ДанныеЗапроса) Тогда Возврат КонецЕсли;

	ИдСессии = ДанныеЗапроса.headers["mcp-session-id"];
	УдалитьМСПСессию(ИдСессии);

	// В proxy streamable_http DELETE /mcp возвращает 200 OK с пустым телом.
	КомпонентаSendResponse(ДанныеЗапроса.id, 200, ЗаголовкиJSON(), "");
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// MCP INITIALIZE / TOOLS/LIST
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция ОбработатьInitialize(ТелоJSON, ДанныеЗапроса)

	ИдСессии = СоздатьМСПСессию();

	// protocolVersion: как в MCP SDK — возвращаем запрошенную версию, если поддерживается,
	// иначе отдаём latest.
	ЗапрошеннаяВерсия = Неопределено;
	ПарамИнициализации = Неопределено;
	Если ТелоJSON <> Неопределено
		И ТипЗнч(ТелоJSON) = Тип("Структура")
		И ТелоJSON.Свойство("params", ПарамИнициализации)
		И ТипЗнч(ПарамИнициализации) = Тип("Структура") Тогда
		ПарамИнициализации.Свойство("protocolVersion", ЗапрошеннаяВерсия);
	КонецЕсли;
	
	ЗапрошеннаяВерсия = СокрЛП(Строка(ЗапрошеннаяВерсия));
	Если ПустаяСтрока(ЗапрошеннаяВерсия) Тогда
		ЗапрошеннаяВерсия = Неопределено;
	КонецЕсли;
	
	ВерсияОтвета = "2025-11-25";
	Если ЗапрошеннаяВерсия = "2024-11-05"
		Или ЗапрошеннаяВерсия = "2025-03-26"
		Или ЗапрошеннаяВерсия = "2025-06-18"
		Или ЗапрошеннаяВерсия = "2025-11-25" Тогда
		ВерсияОтвета = ЗапрошеннаяВерсия;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("protocolVersion", ВерсияОтвета);
	Результат.Вставить("capabilities", Новый Структура("tools",
		Новый Структура("listChanged", Ложь)));
	Результат.Вставить("serverInfo", Новый Структура("name, version",
		"1C MCP Toolkit (Native)", "1.0.0"));

	Возврат Новый Структура("Результат, ИдСессии", Результат, ИдСессии);

КонецФункции

&НаКлиенте
Функция ПолучитьСхемыИнструментов()

	Если КэшСхемИнструментов <> Неопределено Тогда
		Возврат КэшСхемИнструментов;
	КонецЕсли;

	Инструменты = Новый Массив;

	// execute_query
	Инструменты.Добавить(СоздатьСхемуИнструмента("execute_query",
		ОписаниеToolExecuteQuery(),
		СхемаExecuteQuery()));

	// execute_code
	Инструменты.Добавить(СоздатьСхемуИнструмента("execute_code",
		ОписаниеToolExecuteCode(),
		СхемаExecuteCode()));

	// get_metadata
	Инструменты.Добавить(СоздатьСхемуИнструмента("get_metadata",
		ОписаниеToolGetMetadata(),
		СхемаGetMetadata()));

	// get_event_log
	Инструменты.Добавить(СоздатьСхемуИнструмента("get_event_log",
		ОписаниеToolGetEventLog(),
		СхемаGetEventLog()));

	// get_object_by_link
	Инструменты.Добавить(СоздатьСхемуИнструмента("get_object_by_link",
		ОписаниеToolGetObjectByLink(),
		СхемаGetObjectByLink()));

	// get_link_of_object
	Инструменты.Добавить(СоздатьСхемуИнструмента("get_link_of_object",
		ОписаниеToolGetLinkOfObject(),
		СхемаGetLinkOfObject()));

	// find_references_to_object
	Инструменты.Добавить(СоздатьСхемуИнструмента("find_references_to_object",
		ОписаниеToolFindReferencesToObject(),
		СхемаFindReferencesToObject()));

	// get_access_rights
	Инструменты.Добавить(СоздатьСхемуИнструмента("get_access_rights",
		ОписаниеToolGetAccessRights(),
		СхемаGetAccessRights()));

	КэшСхемИнструментов = Новый Структура("tools", Инструменты);
	Возврат КэшСхемИнструментов;

КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// ОПИСАНИЯ ИНСТРУМЕНТОВ (полные docstring из Python-прокси — mcp_handler.py)
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolExecuteQuery()
	М = Новый Массив;
	М.Добавить("Execute a query in 1C query language and return the results.");
	М.Добавить("");
	М.Добавить("This tool executes queries on the 1C:Enterprise database using the 1C query language.");
	М.Добавить("Results are returned as JSON or TOON format.");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    query: The query text in 1C query language (e.g., ""ВЫБРАТЬ * ИЗ Справочник.Номенклатура"")");
	М.Добавить("    params: Optional dictionary of query parameters (e.g., {""Param1"": ""value1""}).");
	М.Добавить("           Parameter values can be:");
	М.Добавить("           - Simple values (string, number, boolean, date)");
	М.Добавить("           - Object references in format: {""_objectRef"": true, ""УникальныйИдентификатор"": ""uuid-string"", ""ТипОбъекта"": ""СправочникСсылка.Контрагенты""}");
	М.Добавить("             Object references are automatically converted to actual 1C references before query execution.");
	М.Добавить("    limit: Maximum number of rows to return (default: 100, max: 1000)");
	М.Добавить("    include_schema: Include column type schema in response (default: False)");
	М.Добавить("    ");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the query executed successfully");
	М.Добавить("    - data: Array of result objects in JSON or TOON format (if successful)");
	М.Добавить("    - schema: Column type information (if include_schema=True and successful)");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("    ");
	М.Добавить("Examples:");
	М.Добавить("    # Simple parameter");
	М.Добавить("    execute_query(");
	М.Добавить("        query=""ВЫБРАТЬ Код, Наименование ИЗ Справочник.Номенклатура ГДЕ Код = &КодТовара"",");
	М.Добавить("        params={""КодТовара"": ""001""},");
	М.Добавить("        limit=100,");
	М.Добавить("        include_schema=True");
	М.Добавить("    )");
	М.Добавить("    ");
	М.Добавить("    # Object reference parameter (from previous execute_query result)");
	М.Добавить("    execute_query(");
	М.Добавить("        query=""ВЫБРАТЬ * ИЗ Документ.РеализацияТоваровУслуг ГДЕ Контрагент = &МойКонтрагент"",");
	М.Добавить("        params={");
	М.Добавить("            ""МойКонтрагент"": {");
	М.Добавить("                ""_objectRef"": true,");
	М.Добавить("                ""УникальныйИдентификатор"": ""a1b2c3d4-e5f6-7890-1234-567890abcdef"",");
	М.Добавить("                ""ТипОбъекта"": ""СправочникСсылка.Контрагенты""");
	М.Добавить("            }");
	М.Добавить("        },");
	М.Добавить("        limit=50");
	М.Добавить("    )");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolExecuteCode()
	М = Новый Массив;
	М.Добавить("Execute arbitrary code in 1C language.");
	М.Добавить("");
	М.Добавить("This tool executes code on the 1C:Enterprise server using the Execute() operator.");
	М.Добавить("The result is returned from the 'Результат' (Result) variable as JSON or TOON format.");
	М.Добавить("");
	М.Добавить("Important limitations (code is executed as a statement block, not a full module):");
	М.Добавить("- Do NOT declare procedures/functions (`Процедура/Функция`) inside the snippet.");
	М.Добавить("- Do NOT use `Возврат` (Return). Instead assign a value to `Результат`.");
	М.Добавить("");
	М.Добавить("WARNING: Some dangerous operations are blocked for safety reasons.");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    code: The 1C code to execute. Use 'Результат = ...' to return a value.");
	М.Добавить("    ");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the code executed successfully");
	М.Добавить("    - data: The value of 'Результат' variable in JSON or TOON format (if successful)");
	М.Добавить("    - error: Error message with line number (if failed)");
	М.Добавить("    ");
	М.Добавить("Example:");
	М.Добавить("    execute_code(code=""Результат = ТекущаяДата();"")");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolGetMetadata()
	М = Новый Массив;
	М.Добавить("Get metadata information about 1C database objects.");
	М.Добавить("");
	М.Добавить("This tool returns information about the structure of the 1C database in JSON format.");
	М.Добавить("");
	М.Добавить("Usage modes:");
	М.Добавить("1. Summary (root types): No parameters (filter/meta_type/name_mask not provided)");
	М.Добавить("   Returns:");
	М.Добавить("     - data: list of root metadata types with counts (Тип, Количество)");
	М.Добавить("     - configuration: configuration/platform info (when available) as a top-level field");
	М.Добавить("");
	М.Добавить("2. Filtered list: Use 'meta_type' and/or 'name_mask' parameters");
	М.Добавить("   Example: meta_type=""Документ"", name_mask=""реализ""");
	М.Добавить("   Returns: List of objects matching the criteria.");
	М.Добавить("   Each item includes: ПолноеИмя, Синоним.");
	М.Добавить("   List results are sorted by ПолноеИмя and support pagination via offset.");
	М.Добавить("   List mode response always includes pagination metadata:");
	М.Добавить("     - truncated, limit, returned, count, offset, has_more, next_offset");
	М.Добавить("   Fields truncated/has_more indicate whether more results exist.");
	М.Добавить("");
	М.Добавить("3. Detailed structure: Use 'filter' parameter with exact full name");
	М.Добавить("   Example: filter=""Справочник.Номенклатура""");
	М.Добавить("   Returns: Full structure with attributes, dimensions, resources, tabular sections");
	М.Добавить("");
	М.Добавить("3a. Specific collection element: Use 'filter' with full path to element");
	М.Добавить("   Collection names are in singular (platform ПолноеИмя() format):");
	М.Добавить("     filter=""Справочник.Контрагенты.Реквизит.ИНН""");
	М.Добавить("     filter=""РегистрНакопления.Остатки.Измерение.Номенклатура""");
	М.Добавить("     filter=""РегистрНакопления.Остатки.Ресурс.Количество""");
	М.Добавить("     filter=""Задача.Задача.РеквизитАдресации.Исполнитель""");
	М.Добавить("     filter=""Справочник.Контрагенты.СтандартныйРеквизит.Наименование""");
	М.Добавить("     filter=""Документ.Реализация.ТабличнаяЧасть.Товары""");
	М.Добавить("     filter=""Документ.Реализация.ТабличнаяЧасть.Товары.Реквизит.Номенклатура""");
	М.Добавить("   Use with sections=[""properties""] to get extended element properties");
	М.Добавить("   (ПроверкаЗаполнения, ЗначениеЗаполнения, Ведущее, Использование, etc.)");
	М.Добавить("");
	М.Добавить("4. Extensions support: Use 'extension_name' parameter");
	М.Добавить("   - extension_name not provided: work with main configuration (default)");
	М.Добавить("   - extension_name="""": get list of all connected extensions");
	М.Добавить("   - extension_name=""ExtensionName"": work with objects inside the specified extension");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    filter: Full name of object (e.g., ""Справочник.Номенклатура"") or full path to collection element");
	М.Добавить("           (e.g., ""Справочник.Контрагенты.Реквизит.ИНН"",");
	М.Добавить("           ""РегистрНакопления.Остатки.Измерение.Номенклатура"",");
	М.Добавить("           ""Документ.Реализация.ТабличнаяЧасть.Товары.Реквизит.Номенклатура"")");
	М.Добавить("    meta_type: Object type filter for list (string or list). Use ""*"" to list across all root types.");
	М.Добавить("    name_mask: Search mask for name/synonym (case-insensitive substring search)");
	М.Добавить("    limit: Maximum number of objects in list (default: 100, max: 1000)");
	М.Добавить("    sections: Detail sections to include (works only with filter). Supported: properties, forms, commands, layouts, predefined, movements, characteristics (movements is only available for Документ objects)");
	М.Добавить("    offset: Offset for pagination in list mode (default: 0)");
	М.Добавить("    extension_name: Extension name (None=main config, """"=list extensions, ""Name""=extension objects).");
	М.Добавить("                   Whitespace-only values are rejected.");
	М.Добавить("");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("     - data: Metadata information in JSON format:");
	М.Добавить("         - Summary: array data of {Тип, Количество} plus optional top-level field configuration");
	М.Добавить("         - List: array of {ПолноеИмя, Синоним}");
	М.Добавить("         - Details: object structure; sections like Реквизиты/ТабличныеЧасти/Измерения/Ресурсы may be omitted if not applicable for the metadata object type (if applicable, they are returned as arrays and may be empty)");
	М.Добавить("         - Extensions list: array of extension properties (ConfigurationExtension), e.g. {Имя, Синоним, Активно, БезопасныйРежим, Версия, УникальныйИдентификатор, Назначение, ОбластьДействия, ...}");
	М.Добавить("    - extension: Extension name (when working with extension objects)");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("");
	М.Добавить("Examples:");
	М.Добавить("    # Get summary of root metadata types (counts)");
	М.Добавить("    get_metadata()");
	М.Добавить("");
	М.Добавить("    # Get only documents");
	М.Добавить("    get_metadata(meta_type=""Документ"")");
	М.Добавить("");
	М.Добавить("    # Search for objects with ""реализ"" in name (across all types)");
	М.Добавить("    get_metadata(name_mask=""реализ"")");
	М.Добавить("");
	М.Добавить("    # Get mixed list across all root types");
	М.Добавить("    get_metadata(meta_type=""*"", limit=50)");
	М.Добавить("");
	М.Добавить("    # Get details about a specific catalog");
	М.Добавить("    get_metadata(filter=""Справочник.Номенклатура"")");
	М.Добавить("");
	М.Добавить("    # Get extended properties of a specific attribute");
	М.Добавить("    get_metadata(filter=""Справочник.Контрагенты.Реквизит.ИНН"", sections=[""properties""])");
	М.Добавить("");
	М.Добавить("    # Get extended properties of a dimension");
	М.Добавить("    get_metadata(filter=""РегистрНакопления.Остатки.Измерение.Номенклатура"", sections=[""properties""])");
	М.Добавить("");
	М.Добавить("    # Get info about a tabular section with its attributes");
	М.Добавить("    get_metadata(filter=""Документ.Реализация.ТабличнаяЧасть.Товары"")");
	М.Добавить("");
	М.Добавить("    # Get extended properties of a tabular section attribute");
	М.Добавить("    get_metadata(filter=""Документ.Реализация.ТабличнаяЧасть.Товары.Реквизит.Номенклатура"", sections=[""properties""])");
	М.Добавить("");
	М.Добавить("    # Get extended properties of a standard attribute");
	М.Добавить("    get_metadata(filter=""Справочник.Контрагенты.СтандартныйРеквизит.Наименование"", sections=[""properties""])");
	М.Добавить("");
	М.Добавить("    # Get list of all connected extensions");
	М.Добавить("    get_metadata(extension_name="""")");
	М.Добавить("");
	М.Добавить("    # Get objects from a specific extension");
	М.Добавить("    get_metadata(extension_name=""MyExtension"", meta_type=""Справочник"")");
	М.Добавить("");
	М.Добавить("    # Get details about an object in extension");
	М.Добавить("    get_metadata(extension_name=""MyExtension"", filter=""Справочник.МойСправочник"")");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolGetEventLog()
	М = Новый Массив;
	М.Добавить("Get event log entries from 1C database with filtering options and cursor pagination.");
	М.Добавить("");
	М.Добавить("This tool retrieves entries from the 1C event log (Журнал регистрации)");
	М.Добавить("with optional filtering by date range, importance level, event type,");
	М.Добавить("and additional filters for data object, metadata type, user, session, etc.");
	М.Добавить("Results are returned as JSON or TOON format.");
	М.Добавить("");
	М.Добавить("Supports cursor pagination for iterating through large result sets:");
	М.Добавить("- Response includes last_date, next_same_second_offset, and has_more");
	М.Добавить("- For next page: use last_date as start_date and next_same_second_offset as same_second_offset");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    start_date: Start date in ISO 8601 format (YYYY-MM-DDTHH:MM:SS).");
	М.Добавить("               If not provided, no start date filter is applied.");
	М.Добавить("               For pagination: use last_date from previous response.");
	М.Добавить("    end_date: End date in ISO 8601 format (YYYY-MM-DDTHH:MM:SS).");
	М.Добавить("             If not provided, no end date filter is applied.");
	М.Добавить("    levels: List of importance levels to filter by.");
	М.Добавить("           Valid values: ""Information"", ""Warning"", ""Error"", ""Note"".");
	М.Добавить("           If not provided, all levels are returned.");
	М.Добавить("    events: List of event types to filter by (e.g., ""_$Data$_.New"", ""_$Session$_.Start"").");
	М.Добавить("           If not provided, all event types are returned.");
	М.Добавить("    limit: Maximum number of records to return (default: 100, max: 1000).");
	М.Добавить("    object_description: Object description from execute_query results.");
	М.Добавить("                      Priority: object_description > link > data.");
	М.Добавить("                      Example: {""_objectRef"": true, ""УникальныйИдентификатор"": ""..."", ""ТипОбъекта"": ""...""}");
	М.Добавить("    link: Navigation link in format e1cib/data/Type.Name?ref=HexGUID.");
	М.Добавить("         Priority: object_description > link > data.");
	М.Добавить("         Example: ""e1cib/data/Документ.РеализацияТоваровУслуг?ref=...""");
	М.Добавить("    data: Reference to data object (navigation link) - for backward compatibility.");
	М.Добавить("          Priority: object_description > link > data.");
	М.Добавить("          Example: ""e1cib/data/Документ.РеализацияТоваровУслуг?ref=...""");
	М.Добавить("    metadata_type: List of metadata object types to filter by.");
	М.Добавить("                   Example: [""Документ.РеализацияТоваровУслуг"", ""Справочник.Номенклатура""].");
	М.Добавить("    user: List of user names to filter by.");
	М.Добавить("    session: List of session numbers to filter by.");
	М.Добавить("    application: List of application types to filter by.");
	М.Добавить("                Valid values: ""ThinClient"", ""WebClient"", ""ThickClient"",");
	М.Добавить("                ""BackgroundJob"", ""Designer"", ""COMConnection"",");
	М.Добавить("                ""Server"", ""WebService"", ""HTTPService"", ""ODataInterface"",");
	М.Добавить("                ""MobileAppClient"", ""MobileAppServer"", ""MobileAppBackgroundJob"",");
	М.Добавить("                ""MobileClient"", ""MobileStandaloneServer"",");
	М.Добавить("                ""FileVariantBackgroundJob"", ""FileVariantServerSide"",");
	М.Добавить("                ""WebSocket"", ""FileVariantWebSocket"",");
	М.Добавить("                ""1CV8C"", ""1CV8"".");
	М.Добавить("    computer: Computer name to filter by.");
	М.Добавить("    comment_contains: Substring to search in comment (case-insensitive).");
	М.Добавить("    transaction_status: Transaction status to filter by.");
	М.Добавить("                       Valid values: ""Committed"", ""RolledBack"", ""NotApplicable"", ""Unfinished"".");
	М.Добавить("    same_second_offset: Skip N records with the same second as start_date (for pagination).");
	М.Добавить("                       For pagination: use next_same_second_offset from previous response.");
	М.Добавить("                       Requires start_date to be specified.");
	М.Добавить("");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("    - data: Array of event log entries in JSON or TOON format (if successful), each containing:");
	М.Добавить("        - date: Event timestamp");
	М.Добавить("        - level: Importance level (Information, Warning, Error, Note)");
	М.Добавить("        - event: Event type");
	М.Добавить("        - comment: Event description/comment");
	М.Добавить("        - user: User name");
	М.Добавить("        - metadata: Metadata object name");
	М.Добавить("        - data_presentation: Data presentation string");
	М.Добавить("        - session: Session number");
	М.Добавить("        - application: Application type");
	М.Добавить("        - computer: Computer name");
	М.Добавить("        - transaction_status: Transaction status");
	М.Добавить("    - count: Number of returned records");
	М.Добавить("    - last_date: ISO 8601 date of last record (cursor for pagination, only with date filter)");
	М.Добавить("    - next_same_second_offset: Accumulated offset for next page (only with date filter)");
	М.Добавить("    - has_more: Boolean indicating if there are more records (only with date filter)");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("");
	М.Добавить("Example:");
	М.Добавить("    # Get all errors from the last day");
	М.Добавить("    get_event_log(");
	М.Добавить("        start_date=""2024-01-15T00:00:00"",");
	М.Добавить("        end_date=""2024-01-15T23:59:59"",");
	М.Добавить("        levels=[""Error"", ""Warning""],");
	М.Добавить("        limit=100");
	М.Добавить("    )");
	М.Добавить("");
	М.Добавить("    # Pagination example - page 1");
	М.Добавить("    result = get_event_log(");
	М.Добавить("        start_date=""2024-01-01T00:00:00"",");
	М.Добавить("        end_date=""2024-01-31T23:59:59"",");
	М.Добавить("        levels=[""Error""],");
	М.Добавить("        limit=100");
	М.Добавить("    )");
	М.Добавить("    # Response: last_date=""2024-01-15T14:30:45"", next_same_second_offset=3, has_more=true");
	М.Добавить("");
	М.Добавить("    # Pagination example - page 2");
	М.Добавить("    result = get_event_log(");
	М.Добавить("        start_date=""2024-01-15T14:30:45"",  # last_date from page 1");
	М.Добавить("        end_date=""2024-01-31T23:59:59"",");
	М.Добавить("        levels=[""Error""],");
	М.Добавить("        limit=100,");
	М.Добавить("        same_second_offset=3  # next_same_second_offset from page 1");
	М.Добавить("    )");
	М.Добавить("");
	М.Добавить("    # Get entries for specific object using object_description");
	М.Добавить("    get_event_log(");
	М.Добавить("        object_description={");
	М.Добавить("            ""_objectRef"": True,");
	М.Добавить("            ""УникальныйИдентификатор"": ""ba7e5a3d-1234-5678-9abc-def012345678"",");
	М.Добавить("            ""ТипОбъекта"": ""ДокументСсылка.РеализацияТоваровУслуг""");
	М.Добавить("        }");
	М.Добавить("    )");
	М.Добавить("");
	М.Добавить("    # Get entries for specific metadata type and user");
	М.Добавить("    get_event_log(");
	М.Добавить("        metadata_type=[""Документ.РеализацияТоваровУслуг""],");
	М.Добавить("        user=[""Иванов""],");
	М.Добавить("        application=[""ThinClient"", ""WebClient""],");
	М.Добавить("        comment_contains=""ошибка""");
	М.Добавить("    )");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolGetObjectByLink()
	М = Новый Массив;
	М.Добавить("Get 1C object data by navigation link.");
	М.Добавить("");
	М.Добавить("This tool retrieves complete object data from the 1C:Enterprise database");
	М.Добавить("using a navigation link. The link format is e1cib/data/Type.Name?ref=HexGUID.");
	М.Добавить("Results are returned as JSON or TOON format.");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    link: Navigation link in format e1cib/data/Type.Name?ref=HexGUID");
	М.Добавить("          (e.g., ""e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"")");
	М.Добавить("          ");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("    - data: Object data in JSON or TOON format (if successful), containing:");
	М.Добавить("        - _type: Full metadata type name");
	М.Добавить("        - _presentation: String representation of the object");
	М.Добавить("        - Standard attributes (Код, Наименование, Дата, Номер if applicable)");
	М.Добавить("        - Custom attributes defined in metadata");
	М.Добавить("        - Tabular sections with all rows");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("    ");
	М.Добавить("Example:");
	М.Добавить("    get_object_by_link(");
	М.Добавить("        link=""e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5""");
	М.Добавить("    )");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolGetLinkOfObject()
	М = Новый Массив;
	М.Добавить("Generate a 1C navigation link from an object description.");
	М.Добавить("");
	М.Добавить("This tool converts an object description (returned by execute_query) into a clickable");
	М.Добавить("navigation link that can be used to open the object directly in 1C.");
	М.Добавить("");
	М.Добавить("Use this tool to provide users with clickable links to 1C objects after finding them");
	М.Добавить("with execute_query.");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    object_description: Object description from execute_query results with fields:");
	М.Добавить("                      - _objectRef: must be true");
	М.Добавить("                      - УникальныйИдентификатор: UUID string");
	М.Добавить("                      - ТипОбъекта: object type (e.g., ""СправочникСсылка.Контрагенты"")");
	М.Добавить("                      - Представление: string representation (optional)");
	М.Добавить("                      ");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("    - data: Navigation link string (e.g., ""e1cib/data/Справочник.Контрагенты?ref=..."")");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("    ");
	М.Добавить("Example:");
	М.Добавить("    # After finding an object with execute_query");
	М.Добавить("    result = execute_query(""SELECT Ref FROM Catalog.Customers WHERE Code = '001'"")");
	М.Добавить("    # result.data[0][""Ref""] contains object description");
	М.Добавить("    ");
	М.Добавить("    # Generate link");
	М.Добавить("    link_result = get_link_of_object(result.data[0][""Ref""])");
	М.Добавить("    # link_result.link = ""e1cib/data/Справочник.Контрагенты?ref=80c6cc1a...""");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolFindReferencesToObject()
	М = Новый Массив;
	М.Добавить("Find references to a given object across specified metadata collections.");
	М.Добавить("");
	М.Добавить("This tool searches for references to the target object in documents, catalogs,");
	М.Добавить("and registers. It checks all fields whose type can contain a reference to the");
	М.Добавить("target object type, then queries for actual matches.");
	М.Добавить("");
	М.Добавить("The search is performed in two stages:");
	М.Добавить("1. Candidate discovery: metadata traversal to find fields that can hold the target type");
	М.Добавить("2. Query execution: actual queries to find objects/records referencing the target");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    target_object_description: Object description from execute_query results with fields:");
	М.Добавить("                              - _objectRef: must be true");
	М.Добавить("                              - УникальныйИдентификатор: UUID string");
	М.Добавить("                              - ТипОбъекта: object type (e.g., ""СправочникСсылка.Контрагенты"")");
	М.Добавить("                              - Представление: string representation (optional)");
	М.Добавить("    search_scope: List of search scopes to check. Valid values:");
	М.Добавить("                 ""documents"", ""catalogs"", ""information_registers"",");
	М.Добавить("                 ""accumulation_registers"", ""accounting_registers"", ""calculation_registers"".");
	М.Добавить("    meta_filter: Optional metadata filter dict with fields:");
	М.Добавить("                - names: list of exact metadata object names (e.g., [""Документ.РеализацияТоваровУслуг""])");
	М.Добавить("                - name_mask: search mask for name/synonym (case-insensitive)");
	М.Добавить("                If names is provided, name_mask is ignored.");
	М.Добавить("    limit_hits: Maximum total number of hits (default: 200, max: 10000).");
	М.Добавить("    limit_per_meta: Maximum hits per metadata object (default: 20, max: 1000).");
	М.Добавить("    timeout_budget_sec: Time budget in seconds for the search (default: 30, min: 5, max: 300).");
	М.Добавить("");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("    - data: Object containing:");
	М.Добавить("        - hits: Array of found references, each with:");
	М.Добавить("            - found_in_meta: metadata object name (e.g., ""Документ.РеализацияТоваровУслуг"")");
	М.Добавить("            - found_in_object: object_description of the owner (for documents/catalogs) or null (for registers)");
	М.Добавить("            - record_key: dimension values (for registers only)");
	М.Добавить("            - path: field path (e.g., ""Контрагент"" or ""Товары.Номенклатура"")");
	М.Добавить("            - match_kind: field type (attribute, tabular_section, dimension, resource, requisite)");
	М.Добавить("            - note: human-readable description");
	М.Добавить("        - total_hits: number of hits found");
	М.Добавить("        - candidates_checked: number of candidate fields checked");
	М.Добавить("        - timeout_exceeded: true if time budget was exhausted");
	М.Добавить("        - skipped_names: names from meta_filter.names that were skipped");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("");
	М.Добавить("Example:");
	М.Добавить("    find_references_to_object(");
	М.Добавить("        target_object_description={");
	М.Добавить("            ""_objectRef"": True,");
	М.Добавить("            ""УникальныйИдентификатор"": ""ba7e5a3d-1234-5678-9abc-def012345678"",");
	М.Добавить("            ""ТипОбъекта"": ""СправочникСсылка.Контрагенты"",");
	М.Добавить("            ""Представление"": ""ООО Рога и Копыта""");
	М.Добавить("        },");
	М.Добавить("        search_scope=[""documents""],");
	М.Добавить("        limit_hits=10");
	М.Добавить("    )");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ОписаниеToolGetAccessRights()
	М = Новый Массив;
	М.Добавить("Get role permissions for a metadata object and optionally effective rights for a user.");
	М.Добавить("");
	М.Добавить("This tool retrieves information about what rights each role grants for the specified");
	М.Добавить("metadata object. If a user name is provided, it also calculates the effective rights");
	М.Добавить("for that user (sum of all their roles).");
	М.Добавить("");
	М.Добавить("IMPORTANT limitations:");
	М.Добавить("- effective_rights is ""rights by sum of roles"", NOT a guarantee of real access");
	М.Добавить("- RLS (Row Level Security) is NOT taken into account");
	М.Добавить("- Contextual restrictions (by organizations, departments) are NOT taken into account");
	М.Добавить("- This is a check of ""what is allowed by roles"", not ""what the user will actually see""");
	М.Добавить("");
	М.Добавить("Runtime requirements:");
	М.Добавить("- Admin rights are required: AccessRight() with 3rd parameter (Role/User) requires admin rights");
	М.Добавить("- Privileged mode is forbidden: if enabled, AccessRight() always returns True, result is meaningless");
	М.Добавить("");
	М.Добавить("Args:");
	М.Добавить("    ctx: MCP Context (injected automatically)");
	М.Добавить("    metadata_object: Full metadata object name (e.g., ""Справочник.Контрагенты"", ""Документ.РеализацияТоваровУслуг"")");
	М.Добавить("    user_name: Optional user name for effective rights calculation (case-insensitive search)");
	М.Добавить("    rights_filter: Optional list of rights to show in result (default: all applicable rights for type)");
	М.Добавить("    roles_filter: Optional list of roles to show (default: all roles with rights)");
	М.Добавить("");
	М.Добавить("Returns:");
	М.Добавить("    Dictionary with:");
	М.Добавить("    - success: Boolean indicating if the request was successful");
	М.Добавить("    - data: Object containing:");
	М.Добавить("        - metadata_object: full metadata object name");
	М.Добавить("        - metadata_type: object type (e.g., ""Справочник"", ""Документ"", ""РегистрСведений"")");
	М.Добавить("        - applicable_rights: array of applicable rights for this object type");
	М.Добавить("        - roles: array of roles with their rights, sorted by name");
	М.Добавить("        - total_roles: number of roles in result (after roles_filter)");
	М.Добавить("        - roles_with_rights: number of roles that have at least one right (after rights_filter)");
	М.Добавить("        - user: (if user_name provided) object with:");
	М.Добавить("            - name: user name");
	М.Добавить("            - full_name: user's full name (optional, may not be available)");
	М.Добавить("            - roles: array of role names assigned to the user");
	М.Добавить("            - effective_rights: object with right names as keys and boolean values");
	М.Добавить("    - error: Error message (if failed)");
	М.Добавить("");
	М.Добавить("Example:");
	М.Добавить("    # Get all role permissions for a catalog");
	М.Добавить("    get_access_rights(metadata_object=""Справочник.Контрагенты"")");
	М.Добавить("");
	М.Добавить("    # Get specific rights for a user");
	М.Добавить("    get_access_rights(");
	М.Добавить("        metadata_object=""Справочник.Контрагенты"",");
	М.Добавить("        user_name=""Иванов"",");
	М.Добавить("        rights_filter=[""Чтение"", ""Изменение""]");
	М.Добавить("    )");
	Возврат СоединитьМассив(М, Символы.ПС);
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция СоздатьСхемуИнструмента(Имя, Описание, ВходнаяСхема)
	Результат = Новый Структура;
	Результат.Вставить("name", Имя);
	Результат.Вставить("description", Описание);
	Результат.Вставить("inputSchema", ВходнаяСхема);
	Возврат Результат;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаExecuteQuery()
	Свойства = Новый Структура;
	Свойства.Вставить("query", Новый Структура("type, description", "string", "The query text in 1C query language (e.g., ""ВЫБРАТЬ * ИЗ Справочник.Номенклатура"")"));
	Свойства.Вставить("params", Новый Структура("type, description", "object", "Optional dictionary of query parameters (e.g., {""Param1"": ""value1""}). Object references use format {""_objectRef"": true, ""УникальныйИдентификатор"": ""uuid"", ""ТипОбъекта"": ""СправочникСсылка.X""}"));
	Свойства.Вставить("limit", Новый Структура("type, description, default", "integer", "Maximum number of rows to return (default: 100, max: 1000)", 100));
	Свойства.Вставить("include_schema", Новый Структура("type, description, default", "boolean", "Include column type schema in response (default: False)", Ложь));

	Требуемые = Новый Массив;
	Требуемые.Добавить("query");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаExecuteCode()
	Свойства = Новый Структура;
	Свойства.Вставить("code", Новый Структура("type, description", "string",
		"The 1C code to execute. Use 'Результат = ...' to return a value."));

	Требуемые = Новый Массив;
	Требуемые.Добавить("code");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаGetMetadata()
	Свойства = Новый Структура;
	Свойства.Вставить("filter", Новый Структура("type, description", "string", "Full name of object (e.g., ""Справочник.Номенклатура"") or full path to collection element (e.g., ""Справочник.Контрагенты.Реквизит.ИНН"", ""РегистрНакопления.Остатки.Измерение.Номенклатура"")"));

	// meta_type: string | array of string (anyOf как у Pydantic v2)
	СвойствоМетаТип = Новый Структура;
	СвойствоМетаТип.Вставить("description", "Object type filter for list (string or list). Use ""*"" to list across all root types.");
	МассивВариантов = Новый Массив;
	МассивВариантов.Добавить(Новый Структура("type", "string"));
	МассивВариантов.Добавить(Новый Структура("type, items", "array", Новый Структура("type", "string")));
	СвойствоМетаТип.Вставить("anyOf", МассивВариантов);
	Свойства.Вставить("meta_type", СвойствоМетаТип);

	Свойства.Вставить("name_mask", Новый Структура("type, description", "string", "Search mask for name/synonym (case-insensitive substring search)"));
	Свойства.Вставить("limit", Новый Структура("type, description, default", "integer", "Maximum number of objects in list (default: 100, max: 1000)", 100));
	Свойства.Вставить("offset", Новый Структура("type, description, default", "integer", "Offset for pagination in list mode (default: 0)", 0));

	// sections: array of string
	СвойствоСекции = Новый Структура;
	СвойствоСекции.Вставить("type", "array");
	СвойствоСекции.Вставить("items", Новый Структура("type", "string"));
	СвойствоСекции.Вставить("description", "Detail sections to include (works only with filter). Supported: properties, forms, commands, layouts, predefined, movements, characteristics (movements is only available for Документ objects)");
	Свойства.Вставить("sections", СвойствоСекции);

	Свойства.Вставить("extension_name", Новый Структура("type, description", "string", "Extension name (None=main config, """"=list extensions, ""Name""=extension objects). Whitespace-only values are rejected."));

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаGetEventLog()
	Свойства = Новый Структура;
	ИтемСтр = Новый Структура("type", "string");
	ИтемЦел = Новый Структура("type", "integer");

	Свойства.Вставить("start_date", Новый Структура("type, description", "string", "Start date in ISO 8601 format (YYYY-MM-DDTHH:MM:SS). For pagination: use last_date from previous response."));
	Свойства.Вставить("end_date",   Новый Структура("type, description", "string", "End date in ISO 8601 format (YYYY-MM-DDTHH:MM:SS). If not provided, no end date filter is applied."));
	Свойства.Вставить("limit",      Новый Структура("type, description, default", "integer", "Maximum number of records to return (default: 100, max: 1000).", 100));

	// levels: array of string
	СвЛевелс = Новый Структура;
	СвЛевелс.Вставить("type", "array");
	СвЛевелс.Вставить("items", ИтемСтр);
	СвЛевелс.Вставить("description", "List of importance levels to filter by. Valid values: ""Information"", ""Warning"", ""Error"", ""Note"". If not provided, all levels are returned.");
	Свойства.Вставить("levels", СвЛевелс);

	// events: array of string
	СвЭвентс = Новый Структура;
	СвЭвентс.Вставить("type", "array");
	СвЭвентс.Вставить("items", ИтемСтр);
	СвЭвентс.Вставить("description", "List of event types to filter by (e.g., ""_$Data$_.New"", ""_$Session$_.Start""). If not provided, all event types are returned.");
	Свойства.Вставить("events", СвЭвентс);

	Свойства.Вставить("object_description", Новый Структура("type, description", "object", "Object description from execute_query results. Priority: object_description > link > data. Example: {""_objectRef"": true, ""УникальныйИдентификатор"": ""..."", ""ТипОбъекта"": ""...""}"));
	Свойства.Вставить("link", Новый Структура("type, description", "string", "Navigation link in format e1cib/data/Type.Name?ref=HexGUID. Priority: object_description > link > data."));
	Свойства.Вставить("data", Новый Структура("type, description", "string", "Reference to data object (navigation link) - for backward compatibility. Priority: object_description > link > data."));

	// metadata_type: array of string
	СвМетаТип = Новый Структура;
	СвМетаТип.Вставить("type", "array");
	СвМетаТип.Вставить("items", ИтемСтр);
	СвМетаТип.Вставить("description", "List of metadata object types to filter by. Example: [""Документ.РеализацияТоваровУслуг"", ""Справочник.Номенклатура""].");
	Свойства.Вставить("metadata_type", СвМетаТип);

	// user: array of string
	СвЮзер = Новый Структура;
	СвЮзер.Вставить("type", "array");
	СвЮзер.Вставить("items", ИтемСтр);
	СвЮзер.Вставить("description", "List of user names to filter by.");
	Свойства.Вставить("user", СвЮзер);

	// session: array of integer
	СвСессион = Новый Структура;
	СвСессион.Вставить("type", "array");
	СвСессион.Вставить("items", ИтемЦел);
	СвСессион.Вставить("description", "List of session numbers to filter by.");
	Свойства.Вставить("session", СвСессион);

	// application: array of string
	СвАпп = Новый Структура;
	СвАпп.Вставить("type", "array");
	СвАпп.Вставить("items", ИтемСтр);
	СвАпп.Вставить("description", "List of application types to filter by. Valid values: ""ThinClient"", ""WebClient"", ""ThickClient"", ""BackgroundJob"", ""Designer"", ""COMConnection"", ""Server"", ""WebService"", ""HTTPService"", ""ODataInterface"", ""MobileAppClient"", ""MobileAppServer"", ""1CV8C"", ""1CV8"", etc.");
	Свойства.Вставить("application", СвАпп);

	Свойства.Вставить("computer",          Новый Структура("type, description", "string", "Computer name to filter by."));
	Свойства.Вставить("comment_contains",   Новый Структура("type, description", "string", "Substring to search in comment (case-insensitive)."));
	Свойства.Вставить("transaction_status", Новый Структура("type, description", "string", "Transaction status to filter by. Valid values: ""Committed"", ""RolledBack"", ""NotApplicable"", ""Unfinished""."));
	Свойства.Вставить("same_second_offset", Новый Структура("type, description, default", "integer", "Skip N records with the same second as start_date (for pagination). Use next_same_second_offset from previous response. Requires start_date.", 0));

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаGetObjectByLink()
	Свойства = Новый Структура;
	Свойства.Вставить("link", Новый Структура("type, description", "string", "Navigation link in format e1cib/data/Type.Name?ref=HexGUID (e.g., ""e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"")"));

	Требуемые = Новый Массив;
	Требуемые.Добавить("link");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаGetLinkOfObject()
	Свойства = Новый Структура;
	Свойства.Вставить("object_description", Новый Структура("type, description", "object", "Object description from execute_query results with fields: _objectRef (must be true), УникальныйИдентификатор (UUID), ТипОбъекта (e.g., ""СправочникСсылка.Контрагенты""), Представление (optional)"));

	Требуемые = Новый Массив;
	Требуемые.Добавить("object_description");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаFindReferencesToObject()
	Свойства = Новый Структура;
	ИтемСтр = Новый Структура("type", "string");

	Свойства.Вставить("target_object_description", Новый Структура("type, description", "object", "Object description from execute_query results with fields: _objectRef (must be true), УникальныйИдентификатор (UUID), ТипОбъекта (e.g., ""СправочникСсылка.Контрагенты""), Представление (optional)"));

	// search_scope: array of string (required — ранее отсутствовал в properties, что делало схему невалидной)
	СвСкоп = Новый Структура;
	СвСкоп.Вставить("type", "array");
	СвСкоп.Вставить("items", ИтемСтр);
	СвСкоп.Вставить("description", "List of search scopes to check. Valid values: ""documents"", ""catalogs"", ""information_registers"", ""accumulation_registers"", ""accounting_registers"", ""calculation_registers"".");
	Свойства.Вставить("search_scope", СвСкоп);

	Свойства.Вставить("meta_filter",       Новый Структура("type, description", "object", "Optional metadata filter dict with fields: names (list of exact metadata object names) and name_mask (case-insensitive search mask). If names is provided, name_mask is ignored."));
	Свойства.Вставить("limit_hits",        Новый Структура("type, description, default", "integer", "Maximum total number of hits (default: 200, max: 10000).", 200));
	Свойства.Вставить("limit_per_meta",    Новый Структура("type, description, default", "integer", "Maximum hits per metadata object (default: 20, max: 1000).", 20));
	Свойства.Вставить("timeout_budget_sec", Новый Структура("type, description, default", "integer", "Time budget in seconds for the search (default: 30, min: 5, max: 300).", 30));

	Требуемые = Новый Массив;
	Требуемые.Добавить("target_object_description");
	Требуемые.Добавить("search_scope");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СхемаGetAccessRights()
	Свойства = Новый Структура;
	ИтемСтр = Новый Структура("type", "string");

	Свойства.Вставить("metadata_object", Новый Структура("type, description", "string", "Full metadata object name (e.g., ""Справочник.Контрагенты"", ""Документ.РеализацияТоваровУслуг"")"));
	Свойства.Вставить("user_name",       Новый Структура("type, description", "string", "Optional user name for effective rights calculation (case-insensitive search)"));

	// rights_filter: array of string
	СвРайтс = Новый Структура;
	СвРайтс.Вставить("type", "array");
	СвРайтс.Вставить("items", ИтемСтр);
	СвРайтс.Вставить("description", "Optional list of rights to show in result (default: all applicable rights for type)");
	Свойства.Вставить("rights_filter", СвРайтс);

	// roles_filter: array of string
	СвРолс = Новый Структура;
	СвРолс.Вставить("type", "array");
	СвРолс.Вставить("items", ИтемСтр);
	СвРолс.Вставить("description", "Optional list of roles to show (default: all roles with rights)");
	Свойства.Вставить("roles_filter", СвРолс);

	Требуемые = Новый Массив;
	Требуемые.Добавить("metadata_object");

	Схема = Новый Структура;
	Схема.Вставить("type", "object");
	Схема.Вставить("properties", Свойства);
	Схема.Вставить("required", Требуемые);
	Возврат Схема;
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// TOOLS/CALL
// ─────────────────────────────────────────────────────────────────────────────────

// ─────────────────────────────────────────────────────────────────────────────────
// НОРМАЛИЗАЦИЯ И ВАЛИДАЦИЯ ПАРАМЕТРОВ ДЛЯ ВСТРОЕННОГО HTTP-СЕРВЕРА
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, ИмяПоля, ЗначениеПоУмолчанию, МинЗначение, МаксЗначение)
	
	// Возвращает Неопределено при успехе или строку error_detail при ошибке.
	// error_detail формируем в стиле прокси: "Field '<name>': ..."
	
	Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid integer";
	КонецЕсли;
	
	// Default
	Если НЕ АргументыЗапроса.Свойство(ИмяПоля) Тогда
		АргументыЗапроса.Вставить(ИмяПоля, ЗначениеПоУмолчанию);
		Возврат Неопределено;
	КонецЕсли;
	
	СыройЗначение = АргументыЗапроса[ИмяПоля];
	Если СыройЗначение = Null Или СыройЗначение = Неопределено Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid integer";
	КонецЕсли;
	
	ЧислоЗначение = Неопределено;
	Если ТипЗнч(СыройЗначение) = Тип("Число") Тогда
		ЧислоЗначение = СыройЗначение;
	ИначеЕсли ТипЗнч(СыройЗначение) = Тип("Строка") Тогда
		СтрЗначение = СокрЛП(СыройЗначение);
		Если ПустаяСтрока(СтрЗначение) Тогда
			Возврат "Field '" + ИмяПоля + "': Input should be a valid integer";
		КонецЕсли;
		Попытка
			ЧислоЗначение = Число(СтрЗначение);
		Исключение
			ЧислоЗначение = Неопределено;
		КонецПопытки;
	КонецЕсли;
	
	Если ЧислоЗначение = Неопределено Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid integer";
	КонецЕсли;
	
	Если ЧислоЗначение <> Цел(ЧислоЗначение) Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid integer";
	КонецЕсли;
	
	ЦелоеЗначение = Цел(ЧислоЗначение);
	
	Если ЦелоеЗначение < МинЗначение Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be greater than or equal to " + Строка(МинЗначение);
	КонецЕсли;
	
	Если ЦелоеЗначение > МаксЗначение Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be less than or equal to " + Строка(МаксЗначение);
	КонецЕсли;
	
	АргументыЗапроса.Вставить(ИмяПоля, ЦелоеЗначение);
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьИНормализоватьБулевоПоле(АргументыЗапроса, ИмяПоля, ЗначениеПоУмолчанию)
	
	// StrictBool-логика как в прокси: принимаем ТОЛЬКО JSON boolean (Булево в 1С).
	// Любые строки/числа и т.п. → ошибка валидации (не пытаемся конвертировать).
	// Возвращает Неопределено при успехе или строку error_detail при ошибке.
	
	Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid boolean";
	КонецЕсли;
	
	// Default
	Если НЕ АргументыЗапроса.Свойство(ИмяПоля) Тогда
		АргументыЗапроса.Вставить(ИмяПоля, ЗначениеПоУмолчанию);
		Возврат Неопределено;
	КонецЕсли;
	
	СыройЗначение = АргументыЗапроса[ИмяПоля];
	Если СыройЗначение = Null Или СыройЗначение = Неопределено Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid boolean";
	КонецЕсли;
	
	Если ТипЗнч(СыройЗначение) <> Тип("Булево") Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid boolean";
	КонецЕсли;
	
	АргументыЗапроса.Вставить(ИмяПоля, СыройЗначение);
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Процедура УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяПоля)
	Если АргументыЗапроса = Неопределено Тогда
		Возврат;
	КонецЕсли;
	Если ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	Если НЕ АргументыЗапроса.Свойство(ИмяПоля) Тогда
		Возврат;
	КонецЕсли;
	Попытка
		АргументыЗапроса.Удалить(ИмяПоля);
	Исключение
		// На всякий случай: если Удалить недоступен, оставляем как есть.
	КонецПопытки;
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция СтрокаСоответствуетISO8601ДатаВремя(СтрокаДаты)
	
	// Проверяем только формат (как в прокси): YYYY-MM-DDTHH:MM:SS
	Если ТипЗнч(СтрокаДаты) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если СтрДлина(СтрокаДаты) <> 19 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Сред(СтрокаДаты, 5, 1) <> "-" Или Сред(СтрокаДаты, 8, 1) <> "-"
		Или Сред(СтрокаДаты, 11, 1) <> "T"
		Или Сред(СтрокаДаты, 14, 1) <> ":"
		Или Сред(СтрокаДаты, 17, 1) <> ":" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем что остальные символы - цифры
	ПозицииНеЦифры = Новый Массив;
	ПозицииНеЦифры.Добавить(1);  // YYYY
	ПозицииНеЦифры.Добавить(2);
	ПозицииНеЦифры.Добавить(3);
	ПозицииНеЦифры.Добавить(4);
	ПозицииНеЦифры.Добавить(6);  // MM
	ПозицииНеЦифры.Добавить(7);
	ПозицииНеЦифры.Добавить(9);  // DD
	ПозицииНеЦифры.Добавить(10);
	ПозицииНеЦифры.Добавить(12); // HH
	ПозицииНеЦифры.Добавить(13);
	ПозицииНеЦифры.Добавить(15); // mm
	ПозицииНеЦифры.Добавить(16);
	ПозицииНеЦифры.Добавить(18); // ss
	ПозицииНеЦифры.Добавить(19);
	
	Для Каждого Позиция Из ПозицииНеЦифры Цикл
		Символ = Сред(СтрокаДаты, Позиция, 1);
		Если Символ < "0" Или Символ > "9" Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СтрокаСостоитИзHexСимволов(Текст)
	
	Если ТипЗнч(Текст) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Позиция = 1 По СтрДлина(Текст) Цикл
		Символ = Сред(Текст, Позиция, 1);
		Если НЕ (
			(Символ >= "0" И Символ <= "9")
			Или (Символ >= "a" И Символ <= "f")
			Или (Символ >= "A" И Символ <= "F")
		) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СтрокаСоответствуетUUID(Текст)
	
	// Формат UUID как в прокси: 8-4-4-4-12
	Если ТипЗнч(Текст) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Текст = СокрЛП(Текст);
	Если СтрДлина(Текст) <> 36 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Сред(Текст, 9, 1) <> "-" Или Сред(Текст, 14, 1) <> "-"
		Или Сред(Текст, 19, 1) <> "-" Или Сред(Текст, 24, 1) <> "-" Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем что остальные символы - hex
	Для Позиция = 1 По 36 Цикл
		Если Позиция = 9 Или Позиция = 14 Или Позиция = 19 Или Позиция = 24 Тогда
			Продолжить;
		КонецЕсли;
		Символ = Сред(Текст, Позиция, 1);
		Если НЕ (
			(Символ >= "0" И Символ <= "9")
			Или (Символ >= "a" И Символ <= "f")
			Или (Символ >= "A" И Символ <= "F")
		) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьИНормализоватьНепустуюСтроку(АргументыЗапроса, ИмяПоля, СообщениеПустое)
	
	Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
		Возврат "Field '" + ИмяПоля + "': Field required";
	КонецЕсли;
	
	Если НЕ АргументыЗапроса.Свойство(ИмяПоля) Тогда
		Возврат "Field '" + ИмяПоля + "': Field required";
	КонецЕсли;
	
	СыройЗначение = АргументыЗапроса[ИмяПоля];
	Если СыройЗначение = Null Или СыройЗначение = Неопределено Тогда
		Возврат "Field '" + ИмяПоля + "': Input should be a valid string";
	КонецЕсли;
	
	// Pydantic (str) по умолчанию приводит многие типы к строке. Делаем так же.
	НормСтрока = СокрЛП(Строка(СыройЗначение));
	Если ПустаяСтрока(НормСтрока) Тогда
		Возврат "Field '" + ИмяПоля + "': " + СообщениеПустое;
	КонецЕсли;
	
	АргументыЗапроса.Вставить(ИмяПоля, НормСтрока);
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьОписаниеОбъекта(ОписаниеОбъекта)
	
	// Порт validate_object_description_data из прокси (сообщения стараемся сохранить).
	
	Если ОписаниеОбъекта = Неопределено Тогда
		Возврат "object_description must be a dictionary";
	КонецЕсли;
	Если ТипЗнч(ОписаниеОбъекта) <> Тип("Структура") Тогда
		Возврат "object_description must be a dictionary";
	КонецЕсли;
	
	Если НЕ ОписаниеОбъекта.Свойство("_objectRef") Тогда
		Возврат "object_description must contain '_objectRef' field";
	КонецЕсли;
	Если ОписаниеОбъекта._objectRef <> Истина Тогда
		Возврат "object_description._objectRef must be true";
	КонецЕсли;
	
	Если НЕ ОписаниеОбъекта.Свойство("УникальныйИдентификатор") Тогда
		Возврат "object_description must contain 'УникальныйИдентификатор' field";
	КонецЕсли;
	UUIDЗначение = ОписаниеОбъекта.УникальныйИдентификатор;
	Если ТипЗнч(UUIDЗначение) <> Тип("Строка") Или ПустаяСтрока(СокрЛП(UUIDЗначение)) Тогда
		Возврат "УникальныйИдентификатор must be a non-empty string";
	КонецЕсли;
	Если НЕ СтрокаСоответствуетUUID(UUIDЗначение) Тогда
		Возврат "УникальныйИдентификатор must be a valid UUID (format: 8-4-4-4-12), got: '" + UUIDЗначение + "'";
	КонецЕсли;
	
	Если НЕ ОписаниеОбъекта.Свойство("ТипОбъекта") Тогда
		Возврат "object_description must contain 'ТипОбъекта' field";
	КонецЕсли;
	ТипОбъекта = ОписаниеОбъекта.ТипОбъекта;
	Если ТипЗнч(ТипОбъекта) <> Тип("Строка") Или ПустаяСтрока(СокрЛП(ТипОбъекта)) Тогда
		Возврат "ТипОбъекта must be a non-empty string";
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьФорматНавигационнойСсылки(Ссылка, ПрефиксСообщения)
	
	// ПрефиксСообщения: "Link" или "link" (как в сообщениях прокси в разных моделях).
	Ссылка = СокрЛП(Строка(Ссылка));
	
	Префикс = "e1cib/data/";
	Если Лев(Ссылка, СтрДлина(Префикс)) <> Префикс Тогда
		Возврат ПрефиксСообщения + " must start with 'e1cib/data/'";
	КонецЕсли;
	
	ПозицияRef = Найти(Ссылка, "?ref=");
	Если ПозицияRef = 0 Тогда
		Возврат ПрефиксСообщения + " must contain '?ref=' parameter";
	КонецЕсли;
	
	ЧастьRef = Сред(Ссылка, ПозицияRef + 5);
	Если СтрДлина(ЧастьRef) <> 32 Тогда
		Возврат "ref parameter must be exactly 32 hexadecimal characters, got " + Строка(СтрДлина(ЧастьRef));
	КонецЕсли;
	
	Если НЕ СтрокаСостоитИзHexСимволов(ЧастьRef) Тогда
		Возврат "ref parameter must contain only hexadecimal characters";
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьИНормализоватьЛимитыИнструмента(ИмяИнструмента, АргументыЗапроса)
	
	// Возвращает Неопределено или строку error_detail (без двуязычной обёртки).
	
	ИмяИнструмента = СокрЛП(Строка(ИмяИнструмента));
	
	Если ИмяИнструмента = "execute_query" Тогда
		Возврат ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "limit", 100, 1, 1000);
		
	ИначеЕсли ИмяИнструмента = "get_metadata" Тогда
		ДетальОшибки = ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "limit", 100, 1, 1000);
		Если ДетальОшибки <> Неопределено Тогда Возврат ДетальОшибки КонецЕсли;
		Возврат ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "offset", 0, 0, 1000000);
		
	ИначеЕсли ИмяИнструмента = "get_event_log" Тогда
		ДетальОшибки = ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "limit", 100, 1, 1000);
		Если ДетальОшибки <> Неопределено Тогда Возврат ДетальОшибки КонецЕсли;
		
		ДетальОшибки = ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "same_second_offset", 0, 0, 10000);
		Если ДетальОшибки <> Неопределено Тогда Возврат ДетальОшибки КонецЕсли;
		
		// same_second_offset requires start_date (как в Python-прокси GetEventLogParams.model_validator)
		СмещениеВСекунде = 0;
		Если АргументыЗапроса <> Неопределено И ТипЗнч(АргументыЗапроса) = Тип("Структура") Тогда
			Если АргументыЗапроса.Свойство("same_second_offset") Тогда
				СмещениеВСекунде = АргументыЗапроса.same_second_offset;
			КонецЕсли;
		КонецЕсли;
		
		Если СмещениеВСекунде > 0 Тогда
			ДатаНачалаСтрока = "";
			Если АргументыЗапроса <> Неопределено И ТипЗнч(АргументыЗапроса) = Тип("Структура") Тогда
				Если АргументыЗапроса.Свойство("start_date") Тогда
					ДатаНачалаСтрока = СокрЛП(Строка(АргументыЗапроса.start_date));
				КонецЕсли;
			КонецЕсли;
			
			Если ПустаяСтрока(ДатаНачалаСтрока) Тогда
				Возврат "Field 'same_second_offset': same_second_offset requires start_date to be specified";
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "find_references_to_object" Тогда
		ДетальОшибки = ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "limit_hits", 200, 1, 10000);
		Если ДетальОшибки <> Неопределено Тогда Возврат ДетальОшибки КонецЕсли;
		
		ДетальОшибки = ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "limit_per_meta", 20, 1, 1000);
		Если ДетальОшибки <> Неопределено Тогда Возврат ДетальОшибки КонецЕсли;
		
		Возврат ПроверитьИНормализоватьЦелоеПоле(АргументыЗапроса, "timeout_budget_sec", 30, 5, 300);
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПроверитьИНормализоватьАргументыИнструмента(ИмяИнструмента, АргументыЗапроса)
	
	// Централизованная валидация аргументов инструментов для встроенного HTTP-сервера.
	// Возвращает Неопределено или строку error_detail (без двуязычной обёртки).
	
	ДетальОшибки = ПроверитьИНормализоватьЛимитыИнструмента(ИмяИнструмента, АргументыЗапроса);
	Если ДетальОшибки <> Неопределено Тогда
		Возврат ДетальОшибки;
	КонецЕсли;
	
	ИмяИнструмента = СокрЛП(Строка(ИмяИнструмента));
	
	Если ИмяИнструмента = "execute_query" Тогда
		
		// query: обязательная непустая строка
		ДетальОшибки = ПроверитьИНормализоватьНепустуюСтроку(АргументыЗапроса, "query", "Query cannot be empty or whitespace only");
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		// params: optional dict
		Если АргументыЗапроса <> Неопределено И ТипЗнч(АргументыЗапроса) = Тип("Структура") Тогда
			Если АргументыЗапроса.Свойство("params") Тогда
				ПарамЗапроса = АргументыЗапроса.params;
				Если ПарамЗапроса = Null Или ПарамЗапроса = Неопределено Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "params");
				ИначеЕсли ТипЗнч(ПарамЗапроса) <> Тип("Структура") Тогда
					Возврат "Field 'params': Params must be a dictionary";
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// include_schema: в прокси StrictBool (только boolean), default=False.
		Возврат ПроверитьИНормализоватьБулевоПоле(АргументыЗапроса, "include_schema", Ложь);
		
	ИначеЕсли ИмяИнструмента = "execute_code" Тогда
		
		// code: обязательная непустая строка
		Возврат ПроверитьИНормализоватьНепустуюСтроку(АргументыЗапроса, "code", "Code cannot be empty or whitespace only");
		
	ИначеЕсли ИмяИнструмента = "get_metadata" Тогда
		
		Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		// filter: Optional[str], "" или whitespace -> None
		Если АргументыЗапроса.Свойство("filter") Тогда
			ФильтрЗначение = АргументыЗапроса.filter;
			Если ФильтрЗначение = Null Или ФильтрЗначение = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "filter");
			Иначе
				ФильтрЗначение = СокрЛП(Строка(ФильтрЗначение));
				Если ПустаяСтрока(ФильтрЗначение) Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "filter");
				Иначе
					АргументыЗапроса.Вставить("filter", ФильтрЗначение);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// meta_type: Optional[Union[str, List[str]]]
		Если АргументыЗапроса.Свойство("meta_type") Тогда
			ТипыМета = АргументыЗапроса.meta_type;
			Если ТипыМета = Null Или ТипыМета = Неопределено Или ТипыМета = "" Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "meta_type");
			ИначеЕсли ТипЗнч(ТипыМета) = Тип("Строка") Тогда
				ТипыМета = СокрЛП(ТипыМета);
				Если ПустаяСтрока(ТипыМета) Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "meta_type");
				Иначе
					АргументыЗапроса.Вставить("meta_type", ТипыМета);
				КонецЕсли;
			ИначеЕсли ТипЗнч(ТипыМета) = Тип("Массив") Или ТипЗнч(ТипыМета) = Тип("ФиксированныйМассив") Тогда
				Очищенные = Новый Массив;
				Для Каждого Элемент Из ТипыМета Цикл
					Если Элемент = Null Или Элемент = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					ЭлСтрока = СокрЛП(Строка(Элемент));
					Если ПустаяСтрока(ЭлСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Очищенные.Добавить(ЭлСтрока);
				КонецЦикла;
				Если Очищенные.Количество() = 0 Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "meta_type");
				Иначе
					АргументыЗапроса.Вставить("meta_type", Очищенные);
				КонецЕсли;
			Иначе
				// Anything else (e.g. int) -> coerce to string
				ТипыМета = СокрЛП(Строка(ТипыМета));
				Если ПустаяСтрока(ТипыМета) Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "meta_type");
				Иначе
					АргументыЗапроса.Вставить("meta_type", ТипыМета);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// name_mask: Optional[str], whitespace-only запрещён
		Если АргументыЗапроса.Свойство("name_mask") Тогда
			Маска = АргументыЗапроса.name_mask;
			Если Маска = Null Или Маска = Неопределено Или Маска = "" Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "name_mask");
			Иначе
				Маска = СокрЛП(Строка(Маска));
				Если ПустаяСтрока(Маска) Тогда
					Возврат "name_mask cannot be empty or whitespace only";
				КонецЕсли;
				АргументыЗапроса.Вставить("name_mask", Маска);
			КонецЕсли;
		КонецЕсли;
		
		// extension_name: whitespace-only запрещён, "" разрешено, """"/'' -> ""
		Если АргументыЗапроса.Свойство("extension_name") Тогда
			ИмяРасширения = АргументыЗапроса.extension_name;
			Если ИмяРасширения = Null Или ИмяРасширения = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "extension_name");
			ИначеЕсли Строка(ИмяРасширения) = "" Тогда
				// валидно: список расширений
			Иначе
				Стрип = СокрЛП(Строка(ИмяРасширения));
				Если Стрип = """""" Или Стрип = "''" Тогда
					АргументыЗапроса.Вставить("extension_name", "");
				ИначеЕсли Стрип = "" Тогда
					Возврат "extension_name cannot be whitespace-only; use empty string '' for extensions list";
				Иначе
					АргументыЗапроса.Вставить("extension_name", Стрип);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// sections: Optional[List[str]], enum, только вместе с filter
		Если АргументыЗапроса.Свойство("sections") Тогда
			Секции = АргументыЗапроса.sections;
			Если Секции = Null Или Секции = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "sections");
			ИначеЕсли ТипЗнч(Секции) <> Тип("Массив") И ТипЗнч(Секции) <> Тип("ФиксированныйМассив") Тогда
				Возврат "Field 'sections': Input should be a valid list";
			Иначе
				// sections requires filter (после нормализации filter)
				ЕстьФильтр = АргументыЗапроса.Свойство("filter") И НЕ ПустаяСтрока(СокрЛП(Строка(АргументыЗапроса.filter)));
				Если НЕ ЕстьФильтр Тогда
					Возврат "sections parameter requires filter parameter";
				КонецЕсли;
				
				Допустимые = Новый Соответствие;
				Допустимые.Вставить("properties", Истина);
				Допустимые.Вставить("forms", Истина);
				Допустимые.Вставить("commands", Истина);
				Допустимые.Вставить("layouts", Истина);
				Допустимые.Вставить("predefined", Истина);
				Допустимые.Вставить("movements", Истина);
				Допустимые.Вставить("characteristics", Истина);
				
				ОчищенныеСекции = Новый Массив;
				НаборУникальных = Новый Соответствие;
				Неверные = Новый Массив;
				
				Для Каждого ЭлементСекции Из Секции Цикл
					Если ЭлементСекции = Null Или ЭлементСекции = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					СекцияСтрока = СокрЛП(Строка(ЭлементСекции));
					СекцияСтрокаНиж = НРег(СекцияСтрока);
					Если ПустаяСтрока(СекцияСтрокаНиж) Тогда
						Продолжить;
					КонецЕсли;
					Если Допустимые.Получить(СекцияСтрокаНиж) = Неопределено Тогда
						Неверные.Добавить(Строка(ЭлементСекции));
						Продолжить;
					КонецЕсли;
					Если НаборУникальных.Получить(СекцияСтрокаНиж) = Неопределено Тогда
						НаборУникальных.Вставить(СекцияСтрокаНиж, Истина);
						ОчищенныеСекции.Добавить(СекцияСтрокаНиж);
					КонецЕсли;
				КонецЦикла;
				
				Если Неверные.Количество() > 0 Тогда
					Возврат "Invalid sections: " + ЗаписатьJSON2(Неверные)
						+ ". Allowed values: properties, forms, commands, layouts, predefined, movements, characteristics";
				КонецЕсли;
				
				Если ОчищенныеСекции.Количество() = 0 Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "sections");
				Иначе
					АргументыЗапроса.Вставить("sections", ОчищенныеСекции);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "get_event_log" Тогда
		
		Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		// start_date/end_date: ISO 8601 strict (YYYY-MM-DDTHH:MM:SS)
		ПоляДаты = Новый Массив;
		ПоляДаты.Добавить("start_date");
		ПоляДаты.Добавить("end_date");
		Для Каждого ИмяПоляДаты Из ПоляДаты Цикл
			Если АргументыЗапроса.Свойство(ИмяПоляДаты) Тогда
				ЗначениеДаты = АргументыЗапроса[ИмяПоляДаты];
				Если ЗначениеДаты = Null Или ЗначениеДаты = Неопределено Или ЗначениеДаты = "" Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяПоляДаты);
				Иначе
					ЗначениеДаты = СокрЛП(Строка(ЗначениеДаты));
					Если ПустаяСтрока(ЗначениеДаты) Тогда
						УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяПоляДаты);
					ИначеЕсли НЕ СтрокаСоответствуетISO8601ДатаВремя(ЗначениеДаты) Тогда
						Возврат "Invalid date format: '" + ЗначениеДаты + "'. Expected ISO 8601 format: YYYY-MM-DDTHH:MM:SS";
					Иначе
						АргументыЗапроса.Вставить(ИмяПоляДаты, ЗначениеДаты);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		// levels: Optional[List[str]] with enum
		Если АргументыЗапроса.Свойство("levels") Тогда
			Уровни = АргументыЗапроса.levels;
			Если Уровни = Null Или Уровни = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "levels");
			ИначеЕсли ТипЗнч(Уровни) <> Тип("Массив") И ТипЗнч(Уровни) <> Тип("ФиксированныйМассив") Тогда
				Возврат "Levels must be a list";
			ИначеЕсли Уровни.Количество() = 0 Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "levels");
			Иначе
				ДопустимыеУровни = Новый Соответствие;
				ДопустимыеУровни.Вставить("Information", Истина);
				ДопустимыеУровни.Вставить("Warning", Истина);
				ДопустимыеУровни.Вставить("Error", Истина);
				ДопустимыеУровни.Вставить("Note", Истина);
				
				НеверныеУровни = Новый Массив;
				ОчищенныеУровни = Новый Массив;
				Для Каждого Уровень Из Уровни Цикл
					Если ТипЗнч(Уровень) <> Тип("Строка") Тогда
						Возврат "Level must be a string, got: " + ТипЗнч(Уровень).Имя();
					КонецЕсли;
					УровеньСтрока = СокрЛП(Уровень);
					Если ПустаяСтрока(УровеньСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если ДопустимыеУровни.Получить(УровеньСтрока) = Неопределено Тогда
						НеверныеУровни.Добавить(УровеньСтрока);
					Иначе
						ОчищенныеУровни.Добавить(УровеньСтрока);
					КонецЕсли;
				КонецЦикла;
				
				Если НеверныеУровни.Количество() > 0 Тогда
					Возврат "Invalid level(s): " + ЗаписатьJSON2(НеверныеУровни)
						+ ". Valid levels are: " + "['Error', 'Information', 'Note', 'Warning']";
				КонецЕсли;
				
				Если ОчищенныеУровни.Количество() = 0 Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "levels");
				Иначе
					АргументыЗапроса.Вставить("levels", ОчищенныеУровни);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// events: Optional[List[str]]
		Если АргументыЗапроса.Свойство("events") Тогда
			События = АргументыЗапроса.events;
			Если События = Null Или События = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "events");
			ИначеЕсли ТипЗнч(События) <> Тип("Массив") И ТипЗнч(События) <> Тип("ФиксированныйМассив") Тогда
				Возврат "Events must be a list";
			ИначеЕсли События.Количество() = 0 Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "events");
			Иначе
				ОчищенныеСобытия = Новый Массив;
				Для Каждого Событие Из События Цикл
					Если ТипЗнч(Событие) <> Тип("Строка") Тогда
						Возврат "Event must be a string, got: " + ТипЗнч(Событие).Имя();
					КонецЕсли;
					СобытиеСтрока = СокрЛП(Событие);
					Если ПустаяСтрока(СобытиеСтрока) Тогда
						Продолжить;
					КонецЕсли;
					ОчищенныеСобытия.Добавить(СобытиеСтрока);
				КонецЦикла;
				Если ОчищенныеСобытия.Количество() = 0 Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "events");
				Иначе
					АргументыЗапроса.Вставить("events", ОчищенныеСобытия);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// application: Optional[List[str]] with enum list
		Если АргументыЗапроса.Свойство("application") Тогда
			Приложения = АргументыЗапроса.application;
			Если Приложения = Null Или Приложения = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "application");
			ИначеЕсли ТипЗнч(Приложения) <> Тип("Массив") И ТипЗнч(Приложения) <> Тип("ФиксированныйМассив") Тогда
				Возврат "Application must be a list";
			ИначеЕсли Приложения.Количество() = 0 Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "application");
			Иначе
				ДопустимыеПриложения = Новый Соответствие;
				СписокДопустимыхПриложений = Новый Массив;
				СписокДопустимыхПриложений.Добавить("ThinClient");
				СписокДопустимыхПриложений.Добавить("WebClient");
				СписокДопустимыхПриложений.Добавить("ThickClient");
				СписокДопустимыхПриложений.Добавить("BackgroundJob");
				СписокДопустимыхПриложений.Добавить("Designer");
				СписокДопустимыхПриложений.Добавить("COMConnection");
				СписокДопустимыхПриложений.Добавить("Server");
				СписокДопустимыхПриложений.Добавить("WebService");
				СписокДопустимыхПриложений.Добавить("HTTPService");
				СписокДопустимыхПриложений.Добавить("ODataInterface");
				СписокДопустимыхПриложений.Добавить("MobileAppClient");
				СписокДопустимыхПриложений.Добавить("MobileAppServer");
				СписокДопустимыхПриложений.Добавить("MobileAppBackgroundJob");
				СписокДопустимыхПриложений.Добавить("MobileClient");
				СписокДопустимыхПриложений.Добавить("MobileStandaloneServer");
				СписокДопустимыхПриложений.Добавить("FileVariantBackgroundJob");
				СписокДопустимыхПриложений.Добавить("FileVariantServerSide");
				СписокДопустимыхПриложений.Добавить("WebSocket");
				СписокДопустимыхПриложений.Добавить("FileVariantWebSocket");
				СписокДопустимыхПриложений.Добавить("1CV8C");
				СписокДопустимыхПриложений.Добавить("1CV8");
				Для Каждого Доп Из СписокДопустимыхПриложений Цикл
					ДопустимыеПриложения.Вставить(Доп, Истина);
				КонецЦикла;
				
				НеверныеПриложения = Новый Массив;
				ОчищенныеПриложения = Новый Массив;
				Для Каждого Прил Из Приложения Цикл
					Если ТипЗнч(Прил) <> Тип("Строка") Тогда
						Возврат "Application must be a string, got: " + ТипЗнч(Прил).Имя();
					КонецЕсли;
					ПрилСтрока = СокрЛП(Прил);
					Если ПустаяСтрока(ПрилСтрока) Тогда
						Продолжить;
					КонецЕсли;
					Если ДопустимыеПриложения.Получить(ПрилСтрока) = Неопределено Тогда
						НеверныеПриложения.Добавить(ПрилСтрока);
					Иначе
						ОчищенныеПриложения.Добавить(ПрилСтрока);
					КонецЕсли;
				КонецЦикла;
				
				Если НеверныеПриложения.Количество() > 0 Тогда
					Возврат "Invalid application(s): " + ЗаписатьJSON2(НеверныеПриложения)
						+ ". Valid applications are: " + "['ThinClient', 'WebClient', 'ThickClient', 'BackgroundJob', 'Designer', 'COMConnection', 'Server', 'WebService', 'HTTPService', 'ODataInterface', 'MobileAppClient', 'MobileAppServer', 'MobileAppBackgroundJob', 'MobileClient', 'MobileStandaloneServer', 'FileVariantBackgroundJob', 'FileVariantServerSide', 'WebSocket', 'FileVariantWebSocket', '1CV8C', '1CV8']";
				КонецЕсли;
				
				Если ОчищенныеПриложения.Количество() = 0 Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "application");
				Иначе
					АргументыЗапроса.Вставить("application", ОчищенныеПриложения);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// transaction_status: enum
		Если АргументыЗапроса.Свойство("transaction_status") Тогда
			Статус = АргументыЗапроса.transaction_status;
			Если Статус = Null Или Статус = Неопределено Или Статус = "" Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "transaction_status");
			Иначе
				Статус = СокрЛП(Строка(Статус));
				Если Статус <> "Committed" И Статус <> "RolledBack" И Статус <> "NotApplicable" И Статус <> "Unfinished" Тогда
					Возврат "Invalid transaction_status: '" + Статус + "'. Valid statuses are: ['Committed', 'RolledBack', 'NotApplicable', 'Unfinished']";
				КонецЕсли;
				АргументыЗапроса.Вставить("transaction_status", Статус);
			КонецЕсли;
		КонецЕсли;
		
		// metadata_type: normalize string to list (как в прокси)
		Если АргументыЗапроса.Свойство("metadata_type") Тогда
			МетаТип = АргументыЗапроса.metadata_type;
			Если МетаТип = Null Или МетаТип = Неопределено Или МетаТип = "" Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "metadata_type");
			ИначеЕсли ТипЗнч(МетаТип) = Тип("Строка") Тогда
				Сырой = СокрЛП(МетаТип);
				Если ПустаяСтрока(Сырой) Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "metadata_type");
				ИначеЕсли Лев(Сырой, 1) = "[" И Прав(Сырой, 1) = "]" Тогда
					// stringified JSON array
					Попытка
						Разобранный = ПрочитатьJSON2(Сырой);
						Если ТипЗнч(Разобранный) = Тип("Массив") Тогда
							АргументыЗапроса.Вставить("metadata_type", Разобранный);
						Иначе
							ОдинТип = Новый Массив;
							ОдинТип.Добавить(Сырой);
							АргументыЗапроса.Вставить("metadata_type", ОдинТип);
						КонецЕсли;
					Исключение
						ОдинТип = Новый Массив;
						ОдинТип.Добавить(Сырой);
						АргументыЗапроса.Вставить("metadata_type", ОдинТип);
					КонецПопытки;
				Иначе
					ОдинТип = Новый Массив;
					ОдинТип.Добавить(Сырой);
					АргументыЗапроса.Вставить("metadata_type", ОдинТип);
				КонецЕсли;
			ИначеЕсли ТипЗнч(МетаТип) = Тип("Массив") Или ТипЗнч(МетаТип) = Тип("ФиксированныйМассив") Тогда
				// ок
			Иначе
				Возврат "Field 'metadata_type': Input should be a valid list";
			КонецЕсли;
		КонецЕсли;
		
		// object_description / link: validate only used filter (priority)
		Если АргументыЗапроса.Свойство("object_description") И АргументыЗапроса.object_description <> Неопределено И АргументыЗапроса.object_description <> Null Тогда
			ДетальОшибки = ПроверитьОписаниеОбъекта(АргументыЗапроса.object_description);
			Если ДетальОшибки <> Неопределено Тогда
				Возврат ДетальОшибки;
			КонецЕсли;
		ИначеЕсли АргументыЗапроса.Свойство("link") И АргументыЗапроса.link <> Неопределено И АргументыЗапроса.link <> Null Тогда
			Линк = АргументыЗапроса.link;
			Линк = СокрЛП(Строка(Линк));
			Если ПустаяСтрока(Линк) Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "link");
			Иначе
				ДетальОшибки = ПроверитьФорматНавигационнойСсылки(Линк, "link");
				Если ДетальОшибки <> Неопределено Тогда
					Возврат ДетальОшибки;
				КонецЕсли;
				АргументыЗапроса.Вставить("link", Линк);
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "get_object_by_link" Тогда
		
		ДетальОшибки = ПроверитьИНормализоватьНепустуюСтроку(АргументыЗапроса, "link", "Link cannot be empty");
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		Линк = АргументыЗапроса.link;
		ДетальОшибки = ПроверитьФорматНавигационнойСсылки(Линк, "Link");
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "get_link_of_object" Тогда
		
		Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
			Возврат "Field 'object_description': Field required";
		КонецЕсли;
		
		Если НЕ АргументыЗапроса.Свойство("object_description") Тогда
			Возврат "Field 'object_description': Field required";
		КонецЕсли;
		
		ДетальОшибки = ПроверитьОписаниеОбъекта(АргументыЗапроса.object_description);
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "find_references_to_object" Тогда
		
		Если АргументыЗапроса = Неопределено Или ТипЗнч(АргументыЗапроса) <> Тип("Структура") Тогда
			Возврат "Field 'target_object_description': Field required";
		КонецЕсли;
		
		Если НЕ АргументыЗапроса.Свойство("target_object_description") Тогда
			Возврат "Field 'target_object_description': Field required";
		КонецЕсли;
		
		ДетальОшибки = ПроверитьОписаниеОбъекта(АргументыЗапроса.target_object_description);
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		Если НЕ АргументыЗапроса.Свойство("search_scope") Тогда
			Возврат "Field 'search_scope': Field required";
		КонецЕсли;
		
		Области = АргументыЗапроса.search_scope;
		Если ТипЗнч(Области) <> Тип("Массив") И ТипЗнч(Области) <> Тип("ФиксированныйМассив") Тогда
			Возврат "search_scope must be a list";
		КонецЕсли;
		Если Области.Количество() = 0 Тогда
			Возврат "search_scope must contain at least one element";
		КонецЕсли;
		
		ДопустимыеОбласти = Новый Соответствие;
		ДопустимыеОбласти.Вставить("documents", Истина);
		ДопустимыеОбласти.Вставить("catalogs", Истина);
		ДопустимыеОбласти.Вставить("information_registers", Истина);
		ДопустимыеОбласти.Вставить("accumulation_registers", Истина);
		ДопустимыеОбласти.Вставить("accounting_registers", Истина);
		ДопустимыеОбласти.Вставить("calculation_registers", Истина);
		
		НеверныеОбласти = Новый Массив;
		ОчищенныеОбласти = Новый Массив;
		Для Каждого Обл Из Области Цикл
			Если ТипЗнч(Обл) <> Тип("Строка") Тогда
				Возврат "Each scope must be a string, got: " + ТипЗнч(Обл).Имя();
			КонецЕсли;
			ОблСтр = СокрЛП(Обл);
			Если ДопустимыеОбласти.Получить(ОблСтр) = Неопределено Тогда
				НеверныеОбласти.Добавить(ОблСтр);
			Иначе
				ОчищенныеОбласти.Добавить(ОблСтр);
			КонецЕсли;
		КонецЦикла;
		
		Если НеверныеОбласти.Количество() > 0 Тогда
			Возврат "Invalid search scope(s): " + ЗаписатьJSON2(НеверныеОбласти)
				+ ". Valid scopes are: ['documents', 'catalogs', 'information_registers', 'accumulation_registers', 'accounting_registers', 'calculation_registers']";
		КонецЕсли;
		
		АргументыЗапроса.Вставить("search_scope", ОчищенныеОбласти);
		
		// meta_filter: Optional[dict]
		Если АргументыЗапроса.Свойство("meta_filter") Тогда
			ФильтрМета = АргументыЗапроса.meta_filter;
			Если ФильтрМета = Null Или ФильтрМета = Неопределено Тогда
				УдалитьПолеЕслиЕсть(АргументыЗапроса, "meta_filter");
			ИначеЕсли ТипЗнч(ФильтрМета) <> Тип("Структура") Тогда
				Возврат "Input should be a valid dictionary";
			Иначе
				// names
				Если ФильтрМета.Свойство("names") Тогда
					Имена = ФильтрМета.names;
					Если Имена = Null Или Имена = Неопределено Тогда
						УдалитьПолеЕслиЕсть(ФильтрМета, "names");
					ИначеЕсли ТипЗнч(Имена) <> Тип("Массив") И ТипЗнч(Имена) <> Тип("ФиксированныйМассив") Тогда
						Возврат "names must be a list";
					ИначеЕсли Имена.Количество() = 0 Тогда
						УдалитьПолеЕслиЕсть(ФильтрМета, "names");
					Иначе
						ДопустимыеПрефиксы = Новый Соответствие;
						СписокПрефиксов = Новый Массив;
						СписокПрефиксов.Добавить("Документ");
						СписокПрефиксов.Добавить("Справочник");
						СписокПрефиксов.Добавить("РегистрСведений");
						СписокПрефиксов.Добавить("РегистрНакопления");
						СписокПрефиксов.Добавить("РегистрБухгалтерии");
						СписокПрефиксов.Добавить("РегистрРасчета");
						СписокПрефиксов.Добавить("ПланВидовХарактеристик");
						СписокПрефиксов.Добавить("ПланСчетов");
						СписокПрефиксов.Добавить("ПланВидовРасчета");
						СписокПрефиксов.Добавить("ПланОбмена");
						СписокПрефиксов.Добавить("БизнесПроцесс");
						СписокПрефиксов.Добавить("Задача");
						СписокПрефиксов.Добавить("Константа");
						СписокПрефиксов.Добавить("Перечисление");
						СписокПрефиксов.Добавить("Отчет");
						СписокПрефиксов.Добавить("Обработка");
						СписокПрефиксов.Добавить("РегламентноеЗадание");
						СписокПрефиксов.Добавить("ПараметрыСеанса");
						Для Каждого Преф Из СписокПрефиксов Цикл
							ДопустимыеПрефиксы.Вставить(Преф, Истина);
						КонецЦикла;
						
						ВалидныеИмена = Новый Массив;
						Для Каждого ИмяМета Из Имена Цикл
							Если ТипЗнч(ИмяМета) <> Тип("Строка") Тогда
								Возврат "Each name must be a string, got: " + ТипЗнч(ИмяМета).Имя();
							КонецЕсли;
							ИмяМетаСтр = СокрЛП(ИмяМета);
							// формат \w+\.\w+ -> упрощённо: ровно одна точка и обе части непустые
							ПозТочка = Найти(ИмяМетаСтр, ".");
							// В 1С 8.2 функция Найти() не поддерживает параметр "начальная позиция",
							// поэтому проверяем наличие второй точки через подстроку после первой.
							Если ПозТочка = 0 Или Найти(Сред(ИмяМетаСтр, ПозТочка + 1), ".") > 0 Тогда
								Возврат "Invalid name format: '" + ИмяМетаСтр + "'. Expected format: 'ТипМетаданных.ИмяОбъекта' (e.g., 'Документ.РеализацияТоваровУслуг')";
							КонецЕсли;
							ПрефиксМета = Лев(ИмяМетаСтр, ПозТочка - 1);
							СуффиксМета = Сред(ИмяМетаСтр, ПозТочка + 1);
							Если ПустаяСтрока(ПрефиксМета) Или ПустаяСтрока(СуффиксМета) Тогда
								Возврат "Invalid name format: '" + ИмяМетаСтр + "'. Expected format: 'ТипМетаданных.ИмяОбъекта' (e.g., 'Документ.РеализацияТоваровУслуг')";
							КонецЕсли;
							Если ДопустимыеПрефиксы.Получить(ПрефиксМета) = Неопределено Тогда
								Возврат "Invalid metadata type prefix: '" + ПрефиксМета + "'. Valid prefixes are: ['Документ', 'Справочник', 'РегистрСведений', 'РегистрНакопления', 'РегистрБухгалтерии', 'РегистрРасчета', 'ПланВидовХарактеристик', 'ПланСчетов', 'ПланВидовРасчета', 'ПланОбмена', 'БизнесПроцесс', 'Задача', 'Константа', 'Перечисление', 'Отчет', 'Обработка', 'РегламентноеЗадание', 'ПараметрыСеанса']";
							КонецЕсли;
							ВалидныеИмена.Добавить(ИмяМетаСтр);
						КонецЦикла;
						Если ВалидныеИмена.Количество() = 0 Тогда
							УдалитьПолеЕслиЕсть(ФильтрМета, "names");
						Иначе
							ФильтрМета.Вставить("names", ВалидныеИмена);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				// name_mask
				Если ФильтрМета.Свойство("name_mask") Тогда
					МаскаМета = ФильтрМета.name_mask;
					Если МаскаМета = Null Или МаскаМета = Неопределено Или МаскаМета = "" Тогда
						УдалитьПолеЕслиЕсть(ФильтрМета, "name_mask");
					Иначе
						МаскаМета = СокрЛП(Строка(МаскаМета));
						Если ПустаяСтрока(МаскаМета) Тогда
							Возврат "name_mask cannot be empty or whitespace only";
						КонецЕсли;
						ФильтрМета.Вставить("name_mask", МаскаМета);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
		
	ИначеЕсли ИмяИнструмента = "get_access_rights" Тогда
		
		ДетальОшибки = ПроверитьИНормализоватьНепустуюСтроку(АргументыЗапроса, "metadata_object", "metadata_object cannot be empty");
		Если ДетальОшибки <> Неопределено Тогда
			Возврат ДетальОшибки;
		КонецЕсли;
		
		Если Найти(АргументыЗапроса.metadata_object, ".") = 0 Тогда
			Возврат "metadata_object must be in format 'ТипМетаданных.ИмяОбъекта' (e.g., 'Справочник.Контрагенты'), got: '" + АргументыЗапроса.metadata_object + "'";
		КонецЕсли;
		
		// user_name: Optional[str] stripped, whitespace-only -> None
		Если АргументыЗапроса <> Неопределено И ТипЗнч(АргументыЗапроса) = Тип("Структура") Тогда
			Если АргументыЗапроса.Свойство("user_name") Тогда
				Пользователь = АргументыЗапроса.user_name;
				Если Пользователь = Null Или Пользователь = Неопределено Или Пользователь = "" Тогда
					УдалитьПолеЕслиЕсть(АргументыЗапроса, "user_name");
				Иначе
					Пользователь = СокрЛП(Строка(Пользователь));
					Если ПустаяСтрока(Пользователь) Тогда
						УдалитьПолеЕслиЕсть(АргументыЗапроса, "user_name");
					Иначе
						АргументыЗапроса.Вставить("user_name", Пользователь);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		// rights_filter, roles_filter: Optional[List[str]]
		ИменаСписков = Новый Массив;
		ИменаСписков.Добавить("rights_filter");
		ИменаСписков.Добавить("roles_filter");
		Для Каждого ИмяСписка Из ИменаСписков Цикл
			Если АргументыЗапроса <> Неопределено И ТипЗнч(АргументыЗапроса) = Тип("Структура") Тогда
				Если АргументыЗапроса.Свойство(ИмяСписка) Тогда
					Список = АргументыЗапроса[ИмяСписка];
					Если Список = Null Или Список = Неопределено Тогда
						УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяСписка);
					ИначеЕсли ТипЗнч(Список) <> Тип("Массив") И ТипЗнч(Список) <> Тип("ФиксированныйМассив") Тогда
						Возврат ИмяСписка + " must be a list";
					ИначеЕсли Список.Количество() = 0 Тогда
						УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяСписка);
					Иначе
						ОчищенныйСписок = Новый Массив;
						Для Каждого ЭлементСписка Из Список Цикл
							Если ТипЗнч(ЭлементСписка) <> Тип("Строка") Тогда
								Возврат "Each " + ?(ИмяСписка="rights_filter","right","role") + " must be a string, got: " + ТипЗнч(ЭлементСписка).Имя();
							КонецЕсли;
							ЭлС = СокрЛП(ЭлементСписка);
							Если ПустаяСтрока(ЭлС) Тогда
								Продолжить;
							КонецЕсли;
							ОчищенныйСписок.Добавить(ЭлС);
						КонецЦикла;
						Если ОчищенныйСписок.Количество() = 0 Тогда
							УдалитьПолеЕслиЕсть(АргументыЗапроса, ИмяСписка);
						Иначе
							АргументыЗапроса.Вставить(ИмяСписка, ОчищенныйСписок);
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

&НаКлиенте
Функция ОбработатьToolsCall(ДанныеЗапроса, ТелоJSON, Ид, ИдПотокаSSE = "")

	// Извлечение params.name и params.arguments
	ПараметрыЗапроса = Неопределено;
	ТелоJSON.Свойство("params", ПараметрыЗапроса);
	Если ПараметрыЗапроса = Неопределено ИЛИ ТипЗнч(ПараметрыЗапроса) <> Тип("Структура") Тогда
		Возврат СформироватьToolsCallОшибку("Missing params");
	КонецЕсли;

	ИмяИнструмента = "";
	ПараметрыЗапроса.Свойство("name", ИмяИнструмента);
	Если ПустаяСтрока(ИмяИнструмента) Тогда
		Возврат СформироватьToolsCallОшибку("Missing tool name");
	КонецЕсли;

	Аргументы = Новый Структура;
	ПараметрыЗапроса.Свойство("arguments", Аргументы);
	Если ТипЗнч(Аргументы) <> Тип("Структура") Тогда
		Аргументы = Новый Структура;
	КонецЕсли;

	// execute_query: дефолт/валидация limit как в прокси (default=100, ge=1, le=1000),
	// но только для встроенного HTTP-сервера (tools/call / REST).
	ДетальОшибки = ПроверитьИНормализоватьАргументыИнструмента(ИмяИнструмента, Аргументы);
	Если ДетальОшибки <> Неопределено Тогда
		СообщениеОшибки = "Ошибка валидации параметров: " + ДетальОшибки
			+ " / Parameter validation failed: " + ДетальОшибки;
		Возврат СформироватьToolsCallРезультат(
			Новый Структура("success, error", Ложь, СообщениеОшибки)
		);
	КонецЕсли;

	// Формируем команду (тот же формат что для proxy)
	Команда = Новый Структура;
	Команда.Вставить("id", Строка(Ид));
	Команда.Вставить("tool", ИмяИнструмента);
	Команда.Вставить("params", Аргументы);

	ДобавитьВЛог("Получена команда: " + ИмяИнструмента + Символы.ПС + ПолучитьТекстКоманды(Команда));

	// Проверка опасных операций для execute_code
	Если ИмяИнструмента = "execute_code" Тогда
		Код = "";
		Аргументы.Свойство("code", Код);
		МассивОпасныхСлов = ПроверитьОпасныеСлова(Код);

		Если МассивОпасныхСлов.Количество() > 0 Тогда
			Если ВсеОперацииАвтоРазрешены(МассивОпасныхСлов) Тогда
				// Автоматически разрешено
				ДобавитьВЛог("Операции автоматически разрешены: " + СоединитьМассив(МассивОпасныхСлов, ", "));
			ИначеЕсли РазрешатьОпасныеОперацииСПодтверждением Тогда
				// Нужен диалог — async
				ОпасныеСлова = СоединитьМассив(МассивОпасныхСлов, ", ");
				ОжидающиеПодтверждения.Вставить(ДанныеЗапроса.id,
					Новый Структура(
						"ДанныеЗапроса, Команда, Ид, ОпасныеКлючевыеСлова, ОпасныеКлючевыеСловаТекст, ИдПотокаSSE",
						ДанныеЗапроса,
						Команда,
						Ид,
						МассивОпасныхСлов,
						ОпасныеСлова,
						ИдПотокаSSE
					));

				// Открываем ту же форму подтверждения, что и в прокси-режиме, чтобы UI/логика были одинаковыми.
				ПараметрыФормы = Новый Структура;
				ПараметрыФормы.Вставить("ОпасныеСлова", ОпасныеСлова);
				ПараметрыФормы.Вставить("Код", Код);
				
				ОписаниеОповещения = Новый ОписаниеОповещения(
					"ОбработатьРезультатПодтвержденияВстроенный",
					ЭтаФорма,
					Новый Структура("RequestId", ДанныеЗапроса.id));
				
				ОткрытьФорму(
					"ВнешняяОбработка.MCPToolkit.Форма.ФормаПодтверждения",
					ПараметрыФормы,
					ЭтаФорма,
					,
					,
					,
					ОписаниеОповещения,
					РежимОткрытияОкнаФормы.БлокироватьВесьИнтерфейс
				);

				Возврат Неопределено; // async
			Иначе
				// Подтверждение опасных операций запрещено — блок (как в прокси block mode)
				КлючевыеСловаТекст = СоединитьМассив(МассивОпасныхСлов, ", ");
				ТекстОшибкиБлок = "Операция запрещена: код содержит опасные ключевые слова: " + КлючевыеСловаТекст
					+ " / Operation not allowed: code contains dangerous keywords: " + КлючевыеСловаТекст;
				ОшибкаБлок = Новый Структура("success, error, dangerous_keywords",
					Ложь, ТекстОшибкиБлок, МассивОпасныхСлов);
				Возврат СформироватьToolsCallРезультат(ОшибкаБлок);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	// Выполнение
	Попытка
		Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
	Исключение
		Возврат СформироватьToolsCallОшибку("Error: " + ОписаниеОшибки());
	КонецПопытки;

	ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
	Возврат СформироватьToolsCallРезультат(Результат, ДанныеЗапроса, Ид, ИдПотокаSSE);

КонецФункции

&НаКлиенте
Процедура ОбработатьРезультатПодтвержденияВстроенный(РезультатВопроса, ДополнительныеПараметры) Экспорт

	RequestId = ДополнительныеПараметры.RequestId;
	Контекст = ОжидающиеПодтверждения.Получить(RequestId);
	ОжидающиеПодтверждения.Удалить(RequestId);

	Если Контекст = Неопределено Тогда Возврат КонецЕсли;

	Разрешено = Ложь;
	Если ТипЗнч(РезультатВопроса) = Тип("Булево") Тогда
		Разрешено = РезультатВопроса;
	ИначеЕсли РезультатВопроса = КодВозвратаДиалога.Да Тогда
		Разрешено = Истина;
	КонецЕсли;
	
	ИдПотокаSSEКонтекст = "";
	Контекст.Свойство("ИдПотокаSSE", ИдПотокаSSEКонтекст);

	Если Разрешено Тогда
		ДобавитьВЛог("Пользователь разрешил выполнение опасной операции");
		Попытка
			Результат = ВыполнитьКомандуНаСервереСКэшированием(Контекст.Команда);
		Исключение
			Результат = Новый Структура("success, error", Ложь, "Error: " + ОписаниеОшибки());
		КонецПопытки;
		ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));
		ТулКолРез = СформироватьToolsCallРезультат(Результат,
			Контекст.ДанныеЗапроса, Контекст.Ид, ИдПотокаSSEКонтекст);
		Если ТулКолРез = Неопределено Тогда Возврат КонецЕсли; // async Toon-конвертация сама отправит
		ОтветJSON = СформироватьJSONRPCОтвет(Контекст.Ид, ТулКолРез);
	Иначе
		ДобавитьВЛог("Пользователь отклонил выполнение опасной операции");
		// Возвращаем текст ошибки как в прокси-режиме (RU+EN + список ключевых слов)
		ОпасныеСловаТекст = "";
		Если Контекст.Свойство("ОпасныеКлючевыеСловаТекст") Тогда
			ОпасныеСловаТекст = Контекст.ОпасныеКлючевыеСловаТекст;
		ИначеЕсли Контекст.Свойство("ОпасныеКлючевыеСлова") Тогда
			ОпасныеСловаТекст = СоединитьМассив(Контекст.ОпасныеКлючевыеСлова, ", ");
		КонецЕсли;
		ТекстОшибкиОтклонено = "Операция отклонена пользователем. Код содержит опасные ключевые слова: " + ОпасныеСловаТекст
			+ " / Operation rejected by user. Code contains dangerous keywords: " + ОпасныеСловаТекст;
		ОшибкаОтклонено = Новый Структура("success, error", Ложь, ТекстОшибкиОтклонено);
		// success=Ложь → Toon async не нужен, параметры не передаём
		ОтветJSON = СформироватьJSONRPCОтвет(Контекст.Ид,
			СформироватьToolsCallРезультат(ОшибкаОтклонено));
	КонецЕсли;

	// Legacy SSE: ответ через GET-поток, не POST (который уже вернул 202)
	Если ЗначениеЗаполнено(ИдПотокаSSEКонтекст) Тогда
		КомпонентаSendSSEEvent(ИдПотокаSSEКонтекст, ОтветJSON, "{}", "message");
	Иначе
		ОтправитьSSEОтвет(Контекст.ДанныеЗапроса, ОтветJSON); // Streamable HTTP — не трогаем
	КонецЕсли;

КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ДЕТЕКТ ОПАСНЫХ ОПЕРАЦИЙ (execute_code) — токенизация как в Python-прокси
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиенте
Функция НормализоватьКодДляСканированияОпасныхСлов(Текст)
	
	// Минимальная нормализация как в прокси: убираем zero-width символы, которые часто используют для обфускации.
	// Полная Unicode NFKC нормализация в 1С отсутствует, поэтому делаем только этот слой.
	
	Если Текст = Неопределено Или Текст = Null Тогда
		Возврат "";
	КонецЕсли;
	
	Текст = Строка(Текст);
	
	// Zero-width characters: U+200B, U+200C, U+200D, U+FEFF
	Текст = СтрЗаменить(Текст, Символ(8203), "");
	Текст = СтрЗаменить(Текст, Символ(8204), "");
	Текст = СтрЗаменить(Текст, Символ(8205), "");
	Текст = СтрЗаменить(Текст, Символ(65279), "");
	
	Возврат Текст;
	
КонецФункции

&НаКлиенте
Функция ЭтоПробельныйСимволДляСканирования(Символ)
	
	Если Символ = " " Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Символ = Символы.Таб Или Символ = Символы.ПС Или Символ = Символы.ВК Тогда
		Возврат Истина;
	КонецЕсли;
	
	// NBSP
	Если Символ = Символ(160) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

&НаКлиенте
Функция ЭтоНачалоИдентификатораДляСканирования(Символ)
	
	Если Символ = "_" Тогда
		Возврат Истина;
	КонецЕсли;
	
	// Для кириллицы/латиницы: буква имеет различие регистра (ВРег <> НРег).
	// Для цифр и знаков препинания это обычно не так.
	Попытка
		Возврат ВРег(Символ) <> НРег(Символ);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Функция ЭтоЧастьИдентификатораДляСканирования(Символ)
	
	Если Символ = "_" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Символ >= "0" И Символ <= "9" Тогда
		Возврат Истина;
	КонецЕсли;
	
	Попытка
		Возврат ВРег(Символ) <> НРег(Символ);
	Исключение
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

&НаКлиенте
Функция СобратьВызванныеИдентификаторы(КодТекст)
	
	// Возвращает Соответствие, где ключ = НРег(IDENT), значение = Истина.
	// Логика как в прокси: IDENT считается "вызовом", если далее встречается '(',
	// при этом пробелы/переносы/комментарии/строки игнорируются.
	
	Результат = Новый Соответствие;
	
	Если КодТекст = Неопределено Или КодТекст = Null Тогда
		Возврат Результат;
	КонецЕсли;
	
	КодТекст = Строка(КодТекст);
	Длина = СтрДлина(КодТекст);
	Позиция = 1;
	ОжидаемыйИдентификатор = "";
	
	Пока Позиция <= Длина Цикл
		
		Символ = Сред(КодТекст, Позиция, 1);
		
		// whitespace
		Если ЭтоПробельныйСимволДляСканирования(Символ) Тогда
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// comments: //... or /*...*/
		Если Символ = "/" И Позиция < Длина Тогда
			Следующий = Сред(КодТекст, Позиция + 1, 1);
			
			Если Следующий = "/" Тогда
				// line comment
				Позиция = Позиция + 2;
				Пока Позиция <= Длина Цикл
					Символ = Сред(КодТекст, Позиция, 1);
					Если Символ = Символы.ПС Или Символ = Символы.ВК Тогда
						Прервать;
					КонецЕсли;
					Позиция = Позиция + 1;
				КонецЦикла;
				Продолжить;
				
			ИначеЕсли Следующий = "*" Тогда
				// block comment
				Позиция = Позиция + 2;
				Пока Позиция <= Длина - 1 Цикл
					Если Сред(КодТекст, Позиция, 1) = "*" И Сред(КодТекст, Позиция + 1, 1) = "/" Тогда
						Позиция = Позиция + 2;
						Прервать;
					КонецЕсли;
					Позиция = Позиция + 1;
				КонецЦикла;
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		// 1C string literal: "text", escaped quote is doubled ""
		Если Символ = """" Тогда
			Позиция = Позиция + 1;
			Пока Позиция <= Длина Цикл
				Если Сред(КодТекст, Позиция, 1) = """" Тогда
					Если Позиция < Длина И Сред(КодТекст, Позиция + 1, 1) = """" Тогда
						Позиция = Позиция + 2;
						Продолжить;
					КонецЕсли;
					Позиция = Позиция + 1;
					Прервать;
				КонецЕсли;
				Позиция = Позиция + 1;
			КонецЦикла;
			Продолжить;
		КонецЕсли;
		
		// Single-quoted blocks (как в прокси — просто игнорируем)
		Если Символ = "'" Тогда
			Позиция = Позиция + 1;
			Пока Позиция <= Длина Цикл
				Если Сред(КодТекст, Позиция, 1) = "'" Тогда
					Если Позиция < Длина И Сред(КодТекст, Позиция + 1, 1) = "'" Тогда
						Позиция = Позиция + 2;
						Продолжить;
					КонецЕсли;
					Позиция = Позиция + 1;
					Прервать;
				КонецЕсли;
				Позиция = Позиция + 1;
			КонецЦикла;
			Продолжить;
		КонецЕсли;
		
		// call detection: IDENT + "("
		Если Символ = "(" Тогда
			Если НЕ ПустаяСтрока(ОжидаемыйИдентификатор) Тогда
				Если Результат.Получить(ОжидаемыйИдентификатор) = Неопределено Тогда
					Результат.Вставить(ОжидаемыйИдентификатор, Истина);
				КонецЕсли;
			КонецЕсли;
			ОжидаемыйИдентификатор = "";
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		
		// identifier
		Если ЭтоНачалоИдентификатораДляСканирования(Символ) Тогда
			
			НачалоИдентификатора = Позиция;
			Позиция = Позиция + 1;
			Пока Позиция <= Длина Цикл
				Символ = Сред(КодТекст, Позиция, 1);
				Если ЭтоЧастьИдентификатораДляСканирования(Символ) Тогда
					Позиция = Позиция + 1;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
			Идентификатор = Сред(КодТекст, НачалоИдентификатора, Позиция - НачалоИдентификатора);
			ОжидаемыйИдентификатор = НРег(Идентификатор);
			Продолжить;
			
		КонецЕсли;
		
		// Любой другой символ "разрывает" контекст IDENT -> "("
		ОжидаемыйИдентификатор = "";
		Позиция = Позиция + 1;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

&НаКлиенте
Функция ПроверитьОпасныеСлова(Код)

	ОпасныеСлова = Новый Массив;
	ОпасныеСлова.Добавить("Удалить");       ОпасныеСлова.Добавить("Delete");
	ОпасныеСлова.Добавить("Записать");      ОпасныеСлова.Добавить("Write");
	ОпасныеСлова.Добавить("УстановитьПривилегированныйРежим"); ОпасныеСлова.Добавить("SetPrivilegedMode");
	ОпасныеСлова.Добавить("ПодключитьВнешнююКомпоненту"); ОпасныеСлова.Добавить("AttachAddIn");
	ОпасныеСлова.Добавить("УстановитьВнешнююКомпоненту"); ОпасныеСлова.Добавить("InstallAddIn");
	ОпасныеСлова.Добавить("COMОбъект");     ОпасныеСлова.Добавить("COMObject");
	ОпасныеСлова.Добавить("УстановитьМонопольныйРежим"); ОпасныеСлова.Добавить("SetExclusiveMode");
	ОпасныеСлова.Добавить("УдалитьФайлы");  ОпасныеСлова.Добавить("DeleteFiles");
	ОпасныеСлова.Добавить("КопироватьФайл"); ОпасныеСлова.Добавить("CopyFile");
	ОпасныеСлова.Добавить("ПереместитьФайл"); ОпасныеСлова.Добавить("MoveFile");
	ОпасныеСлова.Добавить("СоздатьКаталог"); ОпасныеСлова.Добавить("CreateDirectory");

	// Встроенный режим: делаем детект как в Python-прокси:
	// - игнорируем строки и комментарии
	// - ищем ВЫЗОВ идентификатора: IDENT + LPAREN (между ними могут быть пробелы/переносы/комментарии)
	// - удаляем zero-width символы (минимальная защита от обфускации)

	КодНормализованный = НормализоватьКодДляСканированияОпасныхСлов(Код);
	ВызванныеИдентификаторы = СобратьВызванныеИдентификаторы(КодНормализованный);

	Найденные = Новый Массив;
	УжеДобавленные = Новый Соответствие;

	Для Каждого Слово Из ОпасныеСлова Цикл
		КаноническоеСлово = НормализоватьКодДляСканированияОпасныхСлов(Слово);
		КаноническоеСлово = НРег(КаноническоеСлово);

		Если ПустаяСтрока(КаноническоеСлово) Тогда
			Продолжить;
		КонецЕсли;

		Если УжеДобавленные.Получить(КаноническоеСлово) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если ВызванныеИдентификаторы.Получить(КаноническоеСлово) <> Неопределено Тогда
			Найденные.Добавить(Слово);
			УжеДобавленные.Вставить(КаноническоеСлово, Истина);
		КонецЕсли;
	КонецЦикла;

	Возврат Найденные;

КонецФункции

&НаКлиенте
Функция ХотяБыОдинФлажокВключён()
	Возврат АвтоРазрешитьЗаписать ИЛИ АвтоРазрешитьПривилегированныйРежим;
КонецФункции

&НаКлиенте
Функция СформироватьToolsCallРезультат(Результат, ДанныеЗапроса = Неопределено, Ид = Неопределено, ИдПотока = "")

	Содержимое = Новый Массив;
	Элемент = Новый Структура;
	Элемент.Вставить("type", "text");

	Если ТипЗнч(Результат) = Тип("Структура") И Результат.Свойство("success") Тогда
		Если Результат.success Тогда
			// Собираем полную структуру через whitelist — аналогично ОтправитьРезультатНаСервер()
			РезультатДляВывода = Новый Структура("success", Истина);
			ВсеПоля = Новый Массив;
			ВсеПоля.Добавить("data");
			ВсеПоля.Добавить("schema");
			ВсеПоля.Добавить("truncated");
			ВсеПоля.Добавить("limit");
			ВсеПоля.Добавить("returned");
			ВсеПоля.Добавить("count");
			ВсеПоля.Добавить("offset");
			ВсеПоля.Добавить("has_more");
			ВсеПоля.Добавить("next_offset");
			ВсеПоля.Добавить("last_date");
			ВсеПоля.Добавить("next_same_second_offset");
			ВсеПоля.Добавить("configuration");
			ВсеПоля.Добавить("extension");
			Для Каждого ИмяПоля Из ВсеПоля Цикл
				Если Результат.Свойство(ИмяПоля) И Результат[ИмяПоля] <> Неопределено Тогда
					РезультатДляВывода.Вставить(ИмяПоля, Результат[ИмяПоля]);
				КонецЕсли;
			КонецЦикла;

			// Async-ветка для JsonToToon:
			Если ИспользоватьАсинхронноеПодключениеКомпонент И КомпонентаТун <> Неопределено
				И ФорматОтветаВстроенный = 1 И РезультатДляВывода.Свойство("data") Тогда
				КомпонентаТун.НачатьВызовJsonToToon(
					Новый ОписаниеОповещения("ПослеJsonToToonMCP", ЭтаФорма,
						Новый Структура("ДанныеЗапроса, Ид, РезДляВывода, ИдПотока",
							ДанныеЗапроса, Ид, РезультатДляВывода, ИдПотока)),
					ЗаписатьJSON2(РезультатДляВывода.data));
				Возврат Неопределено;
			КонецЕсли;

			ПрименитьТунКонвертацию(РезультатДляВывода);
			Элемент.Вставить("text", ЗаписатьJSON2(РезультатДляВывода));
			Содержимое.Добавить(Элемент);
		Иначе
			// Application-level ошибка: возвращаем JSON-объект без isError (как в прокси)
			РезультатОшибки = Новый Структура("success", Ложь);
			Если Результат.Свойство("error") Тогда
				РезультатОшибки.Вставить("error", Результат.error);
			КонецЕсли;
			Если Результат.Свойство("dangerous_keywords") Тогда
				РезультатОшибки.Вставить("dangerous_keywords", Результат.dangerous_keywords);
			КонецЕсли;
			Элемент.Вставить("text", ЗаписатьJSON2(РезультатОшибки));
			Содержимое.Добавить(Элемент);
		КонецЕсли;
	Иначе
		Элемент.Вставить("text", ЗаписатьJSON2(Результат));
		Содержимое.Добавить(Элемент);
	КонецЕсли;

	Возврат Новый Структура("content", Содержимое);

КонецФункции

&НаКлиенте
Процедура ПослеJsonToToonMCP(РезВызова, ПарВызова, ДопПар) Экспорт
	// ДопПар = {ДанныеЗапроса, Ид, РезДляВывода, ИдПотока}
	Если ЗначениеЗаполнено(РезВызова) Тогда
		ДопПар.РезДляВывода.data = РезВызова;
	КонецЕсли;
	Элемент = Новый Структура("type, text", "text", ЗаписатьJSON2(ДопПар.РезДляВывода));
	Содержимое = Новый Массив;
	Содержимое.Добавить(Элемент);
	ТулКолРез = Новый Структура("content", Содержимое);
	ОтветJSON = СформироватьJSONRPCОтвет(ДопПар.Ид, ТулКолРез);
	// Ветка legacy SSE vs streamable HTTP:
	Если ЗначениеЗаполнено(ДопПар.ИдПотока) Тогда
		КомпонентаSendSSEEvent(ДопПар.ИдПотока, ОтветJSON, "{}", "message"); // Legacy SSE
	Иначе
		ОтправитьSSEОтвет(ДопПар.ДанныеЗапроса, ОтветJSON); // Streamable HTTP
	КонецЕсли;
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьToolsCallОшибку(Сообщение)
	Содержимое = Новый Массив;
	Элемент = Новый Структура;
	Элемент.Вставить("type", "text");
	Элемент.Вставить("text", Сообщение);
	Содержимое.Добавить(Элемент);
	Возврат Новый Структура("content, isError", Содержимое, Истина);
КонецФункции

// ─────────────────────────────────────────────────────────────────────────────────
// REST API
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция РазбитьRESTQueryЗначениеПоЗапятым(Текст)
	
	// Аналог _parse_csv_or_repeated_query_param из Python-прокси: поддержка CSV в одном параметре.
	// Пустые элементы игнорируем (",," -> пропускаем).
	
	Результат = Новый Массив;
	
	Если Текст = Неопределено Или Текст = Null Тогда
		Возврат Результат;
	КонецЕсли;
	
	Остаток = Строка(Текст);
	Пока Истина Цикл
		ПозЗапятая = Найти(Остаток, ",");
		Если ПозЗапятая = 0 Тогда
			Часть = Остаток;
			Остаток = "";
		Иначе
			Часть = Лев(Остаток, ПозЗапятая - 1);
			Остаток = Сред(Остаток, ПозЗапятая + 1);
		КонецЕсли;
		
		Часть = СокрЛП(Часть);
		Если НЕ ПустаяСтрока(Часть) Тогда
			Результат.Добавить(Часть);
		КонецЕсли;
		
		Если ПустаяСтрока(Остаток) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция НормализоватьRESTQueryСписок(СырыеЗначения)
	
	// Возвращает Массив или Неопределено (если после нормализации нет элементов).
	
	Список = Новый Массив;
	
	Если СырыеЗначения = Неопределено Или СырыеЗначения = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(СырыеЗначения) = Тип("Массив") Или ТипЗнч(СырыеЗначения) = Тип("ФиксированныйМассив") Тогда
		Для Каждого Сырой Из СырыеЗначения Цикл
			Части = РазбитьRESTQueryЗначениеПоЗапятым(Сырой);
			Для Каждого Элемент Из Части Цикл
				Список.Добавить(Элемент);
			КонецЦикла;
		КонецЦикла;
	Иначе
		Части = РазбитьRESTQueryЗначениеПоЗапятым(СырыеЗначения);
		Для Каждого Элемент Из Части Цикл
			Список.Добавить(Элемент);
		КонецЦикла;
	КонецЕсли;
	
	Если Список.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Список;
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьRESTОшибка(КодОтвета, Сообщение, Детали = Неопределено)
	
	Тело = Новый Структура("success, error", Ложь, Сообщение);
	Если Детали <> Неопределено Тогда
		Тело.Вставить("details", Детали);
	КонецЕсли;
	
	Возврат Новый Структура("КодОтвета, Тело", КодОтвета, ЗаписатьJSON2(Тело));
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьRESTGETОшибкаЦелого(ИмяПоля, СыройТекст)
	
	ИмяПоля = СокрЛП(Строка(ИмяПоля));
	СыройТекст = Строка(СыройТекст);
	
	Сообщение = "Ошибка валидации: " + ИмяПоля + " должен быть целым числом, получено '" + СыройТекст + "' / "
		+ "Validation error: " + ИмяПоля + " must be an integer, got '" + СыройТекст + "'";
	
	Лок = Новый Массив;
	Лок.Добавить(ИмяПоля);
	
	Детали = Новый Массив;
	Детали.Добавить(Новый Структура(
		"loc, msg, type, input",
		Лок,
		"value is not a valid integer",
		"int_parsing",
		СыройТекст
	));
	
	Возврат СформироватьRESTОшибка(422, Сообщение, Детали);
	
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, ИмяПоля)
	
	// Если поле отсутствует — ок.
	// Если есть и это строка, но не целое — возвращает структуру REST ошибки (КодОтвета/Тело).
	// Если можно распарсить — заменяет значение на целое и возвращает Неопределено.
	
	Если RESTПараметры = Неопределено Или ТипЗнч(RESTПараметры) <> Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ RESTПараметры.Свойство(ИмяПоля) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Сырой = RESTПараметры[ИмяПоля];
	
	// Если пришло несколько значений — берём первое (как request.query_params.get в прокси).
	Если ТипЗнч(Сырой) = Тип("Массив") Или ТипЗнч(Сырой) = Тип("ФиксированныйМассив") Тогда
		Если Сырой.Количество() = 0 Тогда
			Сырой = "";
		Иначе
			Сырой = Сырой[0];
		КонецЕсли;
	КонецЕсли;
	
	Если Сырой = Null Или Сырой = Неопределено Тогда
		Возврат СформироватьRESTGETОшибкаЦелого(ИмяПоля, "");
	КонецЕсли;
	
	Если ТипЗнч(Сырой) = Тип("Число") Тогда
		Если Сырой <> Цел(Сырой) Тогда
			Возврат СформироватьRESTGETОшибкаЦелого(ИмяПоля, Строка(Сырой));
		КонецЕсли;
		RESTПараметры.Вставить(ИмяПоля, Цел(Сырой));
		Возврат Неопределено;
	КонецЕсли;
	
	СыройСтрока = СокрЛП(Строка(Сырой));
	Если ПустаяСтрока(СыройСтрока) Тогда
		Возврат СформироватьRESTGETОшибкаЦелого(ИмяПоля, СыройСтрока);
	КонецЕсли;
	
	ЧислоЗначение = Неопределено;
	Попытка
		ЧислоЗначение = Число(СыройСтрока);
	Исключение
		ЧислоЗначение = Неопределено;
	КонецПопытки;
	
	Если ЧислоЗначение = Неопределено Или ЧислоЗначение <> Цел(ЧислоЗначение) Тогда
		Возврат СформироватьRESTGETОшибкаЦелого(ИмяПоля, СыройСтрока);
	КонецЕсли;
	
	RESTПараметры.Вставить(ИмяПоля, Цел(ЧислоЗначение));
	Возврат Неопределено;
	
КонецФункции

&НаКлиенте
Функция ОбработатьRESTЗапрос(ДанныеЗапроса)

	// path → tool: /api/execute_query → execute_query
	ИмяИнструмента = Сред(ДанныеЗапроса.path, 6); // убираем "/api/"

	// Формируем Команда
	Команда = Новый Структура;
	Команда.Вставить("id", ДанныеЗапроса.id);
	Команда.Вставить("tool", ИмяИнструмента);

	// Параметры: GET из query, POST из body
	Если ДанныеЗапроса.method = "GET" Тогда
		RESTПараметры = Новый Структура;
		Попытка
			Для Каждого КлючЗначение Из ДанныеЗапроса.query Цикл
				ИмяПоля = КлючЗначение.Ключ;
				Значения = КлючЗначение.Значение;
				
				// channel — транспортный параметр прокси-режима (маршрутизация на разные БД).
				// Во встроенном сервере не используется и не должен попадать в params инструмента.
				Если ИмяПоля = "channel" Тогда
					Продолжить;
				КонецЕсли;
				
				// Списки: поддерживаем CSV и повторяющиеся параметры как в прокси.
				Если ИмяПоля = "meta_type"
					Или ИмяПоля = "sections"
					Или ИмяПоля = "levels"
					Или ИмяПоля = "events"
					Или ИмяПоля = "rights_filter"
					Или ИмяПоля = "roles_filter"
					Или ИмяПоля = "names"
				Тогда
					СписокЗначений = НормализоватьRESTQueryСписок(Значения);
					Если СписокЗначений <> Неопределено Тогда
						Если СписокЗначений.Количество() = 1 Тогда
							RESTПараметры.Вставить(ИмяПоля, СписокЗначений[0]);
						Иначе
							RESTПараметры.Вставить(ИмяПоля, СписокЗначений);
						КонецЕсли;
					КонецЕсли;
				ИначеЕсли ТипЗнч(Значения) = Тип("Массив") И Значения.Количество() = 1 Тогда
					RESTПараметры.Вставить(ИмяПоля, Значения[0]);
				Иначе
					RESTПараметры.Вставить(ИмяПоля, Значения);
				КонецЕсли;
			КонецЦикла;
		Исключение
			// query может быть пустым
		КонецПопытки;
		
		// Числовые параметры из query: если не парсятся, отдаём ошибку как в прокси (422 + details).
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "limit");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "offset");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "same_second_offset");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "limit_hits");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "limit_per_meta");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		RESTОшибка = ПопробоватьРаспарситьRESTGETЦелоеПоле(RESTПараметры, "timeout_budget_sec");
		Если RESTОшибка <> Неопределено Тогда Возврат RESTОшибка КонецЕсли;
		
		Команда.Вставить("params", RESTПараметры);
	Иначе
		Попытка
			ТелоREST = ПрочитатьJSON2(ДанныеЗапроса.body);
		Исключение
			ТекстОшибки = ОписаниеОшибки();
			Возврат СформироватьRESTОшибка(400,
				"Ошибка разбора JSON: " + ТекстОшибки + " / JSON parse error: " + ТекстОшибки);
		КонецПопытки;
		
		Если ТипЗнч(ТелоREST) <> Тип("Структура") Тогда
			Возврат СформироватьRESTОшибка(400,
				"Тело запроса должно быть JSON объектом / Request body must be a JSON object");
		КонецЕсли;
		
		// channel — транспортный параметр прокси-режима (маршрутизация на разные БД).
		// Во встроенном сервере не используется и не должен попадать в params инструмента.
		УдалитьПолеЕслиЕсть(ТелоREST, "channel");
		
		Команда.Вставить("params", ТелоREST);
	КонецЕсли;

	// Валидация аргументов (строгие типы/дефолты): только для встроенного HTTP-сервера (REST).
	ПараметрыRESTЗапроса = Неопределено;
	Команда.Свойство("params", ПараметрыRESTЗапроса);
	
	Если ТипЗнч(ПараметрыRESTЗапроса) = Тип("Структура") Тогда
		ДетальОшибки = ПроверитьИНормализоватьАргументыИнструмента(ИмяИнструмента, ПараметрыRESTЗапроса);
		Если ДетальОшибки <> Неопределено Тогда
			СообщениеОшибки = "Ошибка валидации параметров: " + ДетальОшибки
				+ " / Parameter validation failed: " + ДетальОшибки;
			Возврат Новый Структура("КодОтвета, Тело", 422,
				ЗаписатьJSON2(Новый Структура("success, error", Ложь, СообщениеОшибки))
			);
		КонецЕсли;
	Иначе
		// Если параметры не объект, то не пытаемся "валидировать лимиты" по типам,
		// иначе будет неинформативная ошибка на неверный JSON. Лимит-поля всё равно не извлечь.
	КонецЕсли;

	ДобавитьВЛог("Получена команда: " + ИмяИнструмента + Символы.ПС + ПолучитьТекстКоманды(Команда));

	// Выполнение
	Попытка
		Результат = ВыполнитьКомандуНаСервереСКэшированием(Команда);
	Исключение
		ТекстОшибки = ОписаниеОшибки();
		Возврат СформироватьRESTОшибка(500,
			"Необработанное исключение сервера: " + ТекстОшибки
			+ " / Unhandled server exception: " + ТекстОшибки);
	КонецПопытки;

	ДобавитьВЛог("Результат команды отправлен успешно" + Символы.ПС + ПолучитьТекстРезультата(Результат));

	// Async-ветка для JsonToToon:
	Если ИспользоватьАсинхронноеПодключениеКомпонент И КомпонентаТун <> Неопределено
		И ФорматОтветаВстроенный = 1 И ТипЗнч(Результат) = Тип("Структура")
		И Результат.Свойство("success") И Результат.success И Результат.Свойство("data") Тогда
		КомпонентаТун.НачатьВызовJsonToToon(
			Новый ОписаниеОповещения("ПослеJsonToToonREST", ЭтаФорма,
				Новый Структура("ДанныеЗапроса, Результат", ДанныеЗапроса, Результат)),
			ЗаписатьJSON2(Результат.data));
		Возврат Неопределено;
	КонецЕсли;

	// sync path: оригинальный вызов ПрименитьТунКонвертацию и Возврат
	ПрименитьТунКонвертацию(Результат);
	Возврат Новый Структура("КодОтвета, Тело", 200, ЗаписатьJSON2(Результат));

КонецФункции

&НаКлиенте
Процедура ПослеJsonToToonREST(РезВызова, ПарВызова, ДопПар) Экспорт
	// ДопПар = Структура("ДанныеЗапроса, Результат", ...)
	Если ЗначениеЗаполнено(РезВызова) Тогда
		ДопПар.Результат.data = РезВызова;
	КонецЕсли;
	КомпонентаSendResponse(ДопПар.ДанныеЗапроса.id, 200,
		ЗаголовкиJSON(), ЗаписатьJSON2(ДопПар.Результат));
КонецПроцедуры

// ─────────────────────────────────────────────────────────────────────────────────
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ─────────────────────────────────────────────────────────────────────────────────

&НаКлиентеНаСервереБезКонтекста
Функция ЗаголовкиJSON()
	Возврат "{""Content-Type"":""application/json""}";
КонецФункции

&НаКлиенте
Функция СформироватьSSEЗаголовки(ДанныеЗапроса, ИдСессииДляЗаголовка = Неопределено)

	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Cache-Control", "no-cache, no-transform");
	Заголовки.Вставить("Connection", "keep-alive");

	// Источник mcp-session-id
	Если ИдСессииДляЗаголовка <> Неопределено Тогда
		Заголовки.Вставить("mcp-session-id", ИдСессииДляЗаголовка);
	Иначе
		ИдСессии = ДанныеЗапроса.headers["mcp-session-id"];
		Если ИдСессии <> Неопределено Тогда
			Заголовки.Вставить("mcp-session-id", ИдСессии);
		КонецЕсли;
	КонецЕсли;

	Возврат ЗаписатьJSON2(Заголовки);

КонецФункции

&НаКлиенте
Процедура ОтправитьSSEОтвет(ДанныеЗапроса, ОтветJSON, ИдСессииДляЗаголовка = Неопределено)
	Если ИспользоватьАсинхронноеПодключениеКомпонент Тогда
		// CloseSSEStream вызывается в колбэке — гарантированный порядок
		Компонента.НачатьВызовSendSSEEvent(
			Новый ОписаниеОповещения("ПослеОтправкиSSEОтвета", ЭтаФорма, ДанныеЗапроса.id),
			ДанныеЗапроса.id, ОтветJSON,
			СформироватьSSEЗаголовки(ДанныеЗапроса, ИдСессииДляЗаголовка), "message");
	Иначе
		Компонента.SendSSEEvent(ДанныеЗапроса.id, ОтветJSON,
			СформироватьSSEЗаголовки(ДанныеЗапроса, ИдСессииДляЗаголовка));
		Компонента.CloseSSEStream(ДанныеЗапроса.id);
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПослеОтправкиSSEОтвета(РезВызова, ПарВызова, ДопПар) Экспорт
	КомпонентаCloseSSEStream(ДопПар); // ДопПар = ДанныеЗапроса.id
КонецПроцедуры

&НаКлиенте
Функция СформироватьОтветHealth()
	Ответ = Новый Структура;
	Ответ.Вставить("status", "healthy");
	Ответ.Вставить("mode", "native");
	Ответ.Вставить("port", ПортВстроенногоСервера);
	Возврат ЗаписатьJSON2(Ответ);
КонецФункции

&НаКлиенте
Функция СформироватьJSONRPCОтвет(Идентификатор, Результат)
	Ответ = Новый Структура;
	Ответ.Вставить("jsonrpc", "2.0");
	Ответ.Вставить("id", Идентификатор);
	Ответ.Вставить("result", Результат);
	Возврат ЗаписатьJSON2(Ответ);
КонецФункции

&НаКлиентеНаСервереБезКонтекста
Функция СформироватьJSONRPCОшибку(Идентификатор, КодОшибки, Сообщение)
	Ответ = Новый Структура;
	Ответ.Вставить("jsonrpc", "2.0");
	Ответ.Вставить("id", Идентификатор);
	Ответ.Вставить("error", Новый Структура("code, message", КодОшибки, Сообщение));
	Возврат ЗаписатьJSON2(Ответ, Истина);
КонецФункции
