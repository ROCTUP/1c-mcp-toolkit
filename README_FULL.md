# 1C MCP Toolkit

### Обзор

1C MCP Toolkit — система для интеграции AI-агентов (Kiro, Claude и др.) с базами данных 1С:Предприятие через Model Context Protocol (MCP). Состоит из Python прокси-сервера и внешней обработки 1С, связанных через HTTP long polling.

**Ключевые особенности:**
- Не требует изменения конфигурации базы 1С
- Не требует публикации на сервере 1С
- Не использует COM-соединение
- Совместимость с 1С:Предприятие 8.2.13+ и 8.3.25
- Поддержка MCP-протокола и REST API
- Автоопределение кодировки (CP1251/CP866) для Windows-клиентов
- Поддержка TOON формата для оптимизации токенов (экономия 30-60%)
- Изоляция каналов для работы нескольких клиентов
- Поддержка развёртывания в Docker

### Архитектура

```
┌─────────────────┐     MCP HTTP Streamable     ┌─────────────────┐
│    AI Агент     │ ◄─────────────────────────► │                 │
│  (Kiro, Claude) │         /mcp                │                 │
└─────────────────┘                             │   Python Proxy  │
                                                │     Server      │
┌─────────────────┐     REST API                │                 │
│  HTTP Клиент    │ ◄─────────────────────────► │   (FastAPI +    │
│                 │         /api/*              │    MCP SDK)     │
└─────────────────┘                             │                 │
                                                │                 │
┌─────────────────┐     HTTP Long Polling       │                 │
│  1С Обработка   │ ◄─────────────────────────► │                 │
│ (Внешняя .epf)  │    /1c/poll, /1c/result     │                 │
└─────────────────┘                             └─────────────────┘
        │                                               │
        ▼                                               │
┌─────────────────┐                             ┌───────┴───────┐
│   База 1С       │                             │    Docker     │
│ (8.2.13/8.3.25) │                             │   Container   │
└─────────────────┘                             └───────────────┘
```

**Интерфейсы:**
- **MCP HTTP Streamable** (`/mcp`) - основной протокол для AI-агентов (Kiro, Claude)
- **REST API** (`/api/*`) - альтернативный HTTP API для любых клиентов (8 эндпоинтов)
- **HTTP Long Polling** (`/1c/poll`, `/1c/result`) - канал связи с внешней обработкой 1С
- **Health Check** (`/health`) - мониторинг состояния сервера

### Изоляция каналов (Channel Isolation)

Когда несколько клиентов 1С подключаются к одному прокси-серверу, можно изолировать их потоки команд с помощью идентификаторов каналов. Каждый канал имеет свою очередь команд, гарантируя, что команды от одного MCP-клиента получает только соответствующий клиент 1С.

**Как это работает:**
1. MCP-клиент указывает `?channel=<id>` в URL
2. Клиент 1С указывает тот же идентификатор канала в настройках
3. Команды маршрутизируются только между клиентами с совпадающими идентификаторами каналов

**Конфигурация MCP-клиента с каналом:**

```json
{
  "mcpServers": {
    "onec-mcp-toolkit-proxy-dev": {
      "url": "http://localhost:6003/mcp?channel=dev-environment",
      "transport": "http"
    },
    "onec-mcp-toolkit-proxy-prod": {
      "url": "http://localhost:6003/mcp?channel=prod-environment",
      "transport": "http"
    }
  }
}
```

**Правила идентификатора канала:**
- Допустимые символы: `a-z`, `A-Z`, `0-9`, `_`, `-`
- Максимальная длина: 64 символа
- Если не указан или невалиден, используется `"default"`

**Сценарии использования:**
- Несколько разработчиков используют один прокси-сервер
- Разделение окружений разработки и продакшена
- Одновременное тестирование разных баз 1С

### Быстрый старт

#### Вариант 1: Развёртывание в Docker (рекомендуется)

```bash
# Клонировать репозиторий
git clone <repository-url>
cd 1c-mcp-toolkit

# Собрать и запустить через Docker Compose
docker-compose up -d

# Или собрать и запустить вручную
docker build -t onec-mcp-toolkit-proxy .
docker run -d -p 6003:6003 --name onec-mcp-toolkit-proxy onec-mcp-toolkit-proxy
```

#### Вариант 2: Прямой запуск Python

```bash
# Создать виртуальное окружение
python -m venv .venv
source .venv/bin/activate  # Linux/Mac
# или
.venv\Scripts\activate     # Windows

# Установить зависимости
pip install -r requirements.txt

# Запустить сервер
python -m onec_mcp_toolkit_proxy
```

Сервер запустится на `http://localhost:6003` по умолчанию.

### Настройка IDE

Чтобы использовать 1C MCP Toolkit с AI-ассистентами, такими как Kiro или Claude Desktop, необходимо настроить MCP-сервер в вашей IDE.

#### Kiro IDE

1. Откройте файл конфигурации MCP:
   - **Уровень проекта**: `.kiro/settings/mcp.json` (в папке проекта)
   - **Уровень пользователя**: `~/.kiro/settings/mcp.json` (глобальная конфигурация)

2. Добавьте следующую конфигурацию (Streamable HTTP на `/mcp`):

```json
{
  "mcpServers": {
    "onec-mcp-toolkit-proxy": {
      "url": "http://localhost:6003/mcp",
      "transport": "http",
      "disabled": false,
      "autoApprove": ["execute_query", "get_metadata"]
    }
  }
}
```

3. Если клиент поддерживает только legacy HTTP+SSE, укажите SSE-транспорт на `http://localhost:6003/mcp`.
   Сервер вернёт endpoint (`/mcp/message?session_id=...`) автоматически.

4. Перезапустите Kiro или переподключите MCP-сервер из панели MCP Server в Kiro.

#### Claude Desktop

1. Откройте файл конфигурации Claude Desktop:
   - **macOS**: `~/Library/Application Support/Claude/claude_desktop_config.json`
   - **Windows**: `%APPDATA%\Claude\claude_desktop_config.json`

2. Добавьте следующую конфигурацию (Streamable HTTP на `/mcp`):

```json
{
  "mcpServers": {
    "onec-mcp-toolkit-proxy": {
      "url": "http://localhost:6003/mcp",
      "transport": "http"
    }
  }
}
```

3. Если клиент поддерживает только legacy HTTP+SSE, укажите SSE-транспорт на `http://localhost:6003/mcp`.
   Сервер вернёт endpoint (`/mcp/message?session_id=...`) автоматически.

4. Перезапустите Claude Desktop.

#### Примечания к конфигурации

- Массив `autoApprove` позволяет указать инструменты, которые могут выполняться без подтверждения пользователя
- Установите `disabled: true`, чтобы временно отключить MCP-сервер без удаления конфигурации
- Для production-окружений рекомендуется использовать переменные окружения для URL и порта сервера
- Убедитесь, что прокси-сервер запущен перед подключением из IDE
- Streamable HTTP и legacy SSE обслуживаются на одном пути `/mcp`

### MCP-инструменты

Прокси предоставляет восемь MCP-инструментов для взаимодействия с 1С:Предприятие:

#### 1. execute_query

Выполняет запрос на языке запросов 1С и возвращает результат.

**Параметры:**
| Параметр | Тип | Обязательный | По умолчанию | Описание |
|----------|-----|--------------|--------------|----------|
| `query` | string | Да | - | Текст запроса на языке 1С |
| `params` | object | Нет | null | Параметры запроса |
| `limit` | integer | Нет | 100 | Максимальное количество строк (1-1000) |
| `include_schema` | boolean | Нет | false | Включить схему типов колонок в ответ |

**Примеры:**

```json
// Простой запрос
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ * ИЗ Справочник.Номенклатура"
  }
}

// Запрос с параметрами
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ * ИЗ Справочник.Номенклатура ГДЕ Код = &КодТовара",
    "params": {
      "КодТовара": "001"
    },
    "limit": 100
  }
}

// Запрос с информацией о схеме
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ Код, Наименование, Цена, Поставщик ИЗ Справочник.Номенклатура",
    "limit": 100,
    "include_schema": true
  }
}
```

**Ответ (без схемы):**
```json
{
  "success": true,
  "data": [
    {"Код": "001", "Наименование": "Товар 1"},
    {"Код": "002", "Наименование": "Товар 2"}
  ]
}
```

**Ответ (со схемой):**
```json
{
  "success": true,
  "data": [
    {
      "Код": "001",
      "Наименование": "Товар 1",
      "Цена": 100.50,
      "Поставщик": {
        "_objectRef": true,
        "УникальныйИдентификатор": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "ТипОбъекта": "СправочникСсылка.Контрагенты",
        "Представление": "ООО \"Поставщик\""
      }
    }
  ],
  "schema": {
    "columns": [
      {"name": "Код", "types": ["Строка"]},
      {"name": "Наименование", "types": ["Строка"]},
      {"name": "Цена", "types": ["Число"]},
      {"name": "Поставщик", "types": ["СправочникСсылка.Контрагенты"]}
    ]
  }
}
```

**Информация о схеме:**

При `include_schema=true` ответ включает поле `schema` с метаданными о типах колонок:
- **name**: Имя колонки из запроса
- **types**: Массив возможных типов для колонки (отсортирован по алфавиту, без дублей)
  - Примитивные типы: `"Строка"`, `"Число"`, `"Дата"`, `"Булево"`
  - Ссылочные типы: Полные имена типов, например `"СправочникСсылка.Контрагенты"`, `"ДокументСсылка.РеализацияТоваровУслуг"`
  - Составные типы: Несколько типов в массиве, если колонка может иметь разные типы

**Сценарии использования схемы:**
- Понимание структуры данных без анализа конкретных значений
- Определение ссылочных типов для итеративных запросов
- Обработка колонок с составными типами (несколько возможных типов)
- Построение динамического UI или отчётов на основе структуры запроса

#### 2. execute_code

Выполняет произвольный код на языке 1С. Результат должен быть присвоен переменной `Результат`.

**Ограничения:** фрагмент выполняется как блок операторов (через `Выполнить`), поэтому **нельзя** объявлять `Процедура/Функция` и **нельзя** использовать `Возврат`. Для результата используйте `Результат = ...;`.

**Параметры:**
| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `code` | string | Да | Код 1С для выполнения |

**Примеры:**

```json
// Получить текущую дату
{
  "name": "execute_code",
  "arguments": {
    "code": "Результат = ТекущаяДата();"
  }
}

// Сложная операция
{
  "name": "execute_code",
  "arguments": {
    "code": "Запрос = Новый Запрос(\"ВЫБРАТЬ КОЛИЧЕСТВО(*) КАК Количество ИЗ Справочник.Номенклатура\"); Результат = Запрос.Выполнить().Выгрузить()[0].Количество;"
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "data": "2024-01-15T10:30:00"
}
```

**Безопасность:** Опасные операции блокируются настраиваемым чёрным списком. См. [Переменные окружения](#переменные-окружения).

#### 3. get_metadata

Возвращает информацию о структуре метаданных базы 1С.

**Параметры:**
| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `filter` | string | Нет | Полное имя объекта для детальной структуры (например, "Справочник.Номенклатура") |
| `meta_type` | string \| array[string] | Нет | Корневой тип(ы) метаданных для режима списка (например, `"Документ"` или `["Документ","РегистрСведений"]`). Используйте `"*"` чтобы перечислить объекты по всем корневым типам |
| `name_mask` | string | Нет | Маска поиска по имени/синониму (регистронезависимая подстрока), работает в режиме списка |
| `limit` | integer | Нет | Максимальное количество объектов в режиме списка (по умолчанию 100, макс 1000) |
| `offset` | integer | Нет | Смещение для постраничного вывода в режиме списка (по умолчанию 0). Режим списка сортируется по `ПолноеИмя` |
| `sections` | array[string] | Нет | Секции детального ответа (работает только с `filter`): `properties`, `forms`, `commands`, `layouts`, `predefined` |
| `extension_name` | string | Нет | Имя расширения: `None` - основная конфигурация, `""` - список расширений, `"Имя"` - объекты расширения. Whitespace-only запрещён |

**Примеры:**

```json
// Получить сводку: информация о конфигурации + корневые типы (тип + количество)
{
  "name": "get_metadata",
  "arguments": {}
}

// Получить список по всем корневым типам (может быть обрезан по limit)
{
  "name": "get_metadata",
  "arguments": {
    "meta_type": "*",
    "limit": 200,
    "offset": 0
  }
}

// Получить детальную информацию об объекте
{
  "name": "get_metadata",
  "arguments": {
    "filter": "Справочник.Номенклатура"
  }
}

// Получить "богатую карточку" объекта (доп. секции)
{
  "name": "get_metadata",
  "arguments": {
    "filter": "Справочник.Номенклатура",
    "sections": ["properties", "forms", "commands", "layouts", "predefined"]
  }
}

// Получить список всех расширений конфигурации
{
  "name": "get_metadata",
  "arguments": {
    "extension_name": ""
  }
}

// Получить объекты внутри расширения
{
  "name": "get_metadata",
  "arguments": {
    "extension_name": "МоёРасширение",
    "meta_type": "Справочник"
  }
}
```

**Ответ (сводка + информация о конфигурации, без filter/meta_type/name_mask):**
```json
{
  "success": true,
  "configuration": {
    "platform_version": "8.3.25.XXXX",
    "infobase_name": "MyInfoBase",
    "metadata": {
      "Имя": "MyConfiguration",
      "Синоним": "Моя конфигурация",
      "РежимСовместимости": "8.2.13"
    }
  },
  "data": [
    {"Тип": "Справочник", "Количество": 265},
    {"Тип": "Документ", "Количество": 27}
  ]
}
```

**Ответ (режим списка, с meta_type/name_mask):**
```json
{
  "success": true,
  "truncated": false,
  "limit": 100,
  "offset": 0,
  "returned": 2,
  "has_more": false,
  "next_offset": 2,
  "data": [
    {"ПолноеИмя": "Документ.РеализацияТоваровУслуг", "Синоним": "Реализация товаров и услуг"}
  ]
}
```

**Ответ (детали, с filter):**
```json
{
  "success": true,
  "data": {
    "Имя": "Номенклатура",
    "Синоним": "Номенклатура",
    "ПолноеИмя": "Справочник.Номенклатура",
    "Реквизиты": [
      {"Имя": "Код", "Тип": "Строка", "Длина": 10},
      {"Имя": "Наименование", "Тип": "Строка", "Длина": 100},
      {"Имя": "Цена", "Тип": "Число", "Точность": 15, "Масштаб": 2}
    ],
    "ТабличныеЧасти": [
      {"Имя": "Штрихкоды", "Реквизиты": [...]}
    ]
  }
}
```

Примечание: в **детальном режиме** ответ может содержать поле `extension_marks` (как у основного объекта, так и у вложенных элементов: реквизиты/табличные части и т.д.), если объект добавлен/заимствован/изменён расширениями конфигурации. Для «обычных» объектов основной конфигурации без влияния расширений `extension_marks` не выводится.

Пример (фрагмент):
```json
{
  "extension_marks": {
    "ПринадлежностьОбъекта": "Заимствованный",
    "РасширениеКонфигурации": {"Имя": "МоёРасширение", "Синоним": "Моё расширение", "УникальныйИдентификатор": "00000000-0000-0000-0000-000000000000"},
    "ЕстьИзмененияРасширениямиКонфигурации": true
  }
}
```

Примечание: некоторые секции в деталях (например, `Реквизиты`, `ТабличныеЧасти`, `Измерения`, `Ресурсы`) могут отсутствовать, если они не применимы для типа запрошенного объекта метаданных. Если секция применима, она возвращается как массив и может быть пустой (`[]`).

#### 4. get_event_log

Получает записи из журнала регистрации 1С с расширенными возможностями фильтрации.

**Параметры:**
| Параметр | Тип | Обязательный | По умолчанию | Описание |
|----------|-----|--------------|--------------|----------|
| `start_date` | string | Нет | null | Дата начала периода в формате ISO 8601 (YYYY-MM-DDTHH:MM:SS) |
| `end_date` | string | Нет | null | Дата окончания периода в формате ISO 8601 |
| `levels` | array | Нет | null | Уровни важности: Information, Warning, Error, Note |
| `events` | array | Нет | null | Фильтр по типу события |
| `limit` | integer | Нет | 100 | Максимальное количество записей (1-1000) |
| `same_second_offset` | integer | Нет | 0 | Пропустить N записей с той же секундой, что и `start_date` (курсорная пагинация). Используйте `next_same_second_offset` из предыдущего ответа; нужно задать `start_date`. |
| `data` | string | Нет | null | Ссылка на объект данных (навигационная ссылка или UUID) |
| `metadata_type` | array | Нет | null | Типы объектов метаданных (например, "Документ.РеализацияТоваровУслуг") |
| `user` | array | Нет | null | Имена пользователей |
| `session` | array | Нет | null | Номера сеансов |
| `application` | array | Нет | null | Типы приложений: ThinClient, WebClient, ThickClient, BackgroundJob, Designer, COMConnection |
| `computer` | string | Нет | null | Имя компьютера |
| `comment_contains` | string | Нет | null | Подстрока для поиска в комментарии (регистронезависимый) |
| `transaction_status` | string | Нет | null | Статус транзакции: Committed, RolledBack, NotApplicable, Unfinished |

**Примеры:**

```json
// Получить последние 100 ошибок и предупреждений
{
  "name": "get_event_log",
  "arguments": {
    "levels": ["Error", "Warning"],
    "limit": 100
  }
}

// Получить события за определённый период
{
  "name": "get_event_log",
  "arguments": {
    "start_date": "2024-01-01T00:00:00",
    "end_date": "2024-01-31T23:59:59",
    "limit": 500
  }
}

// Получить определённые типы событий
{
  "name": "get_event_log",
  "arguments": {
    "events": ["_$Data$_.Post", "_$Data$_.Delete"],
    "levels": ["Error"],
    "limit": 50
  }
}

// Фильтр по типу метаданных (все операции с документами реализации)
{
  "name": "get_event_log",
  "arguments": {
    "metadata_type": ["Документ.РеализацияТоваровУслуг"],
    "limit": 100
  }
}

// Фильтр по пользователю
{
  "name": "get_event_log",
  "arguments": {
    "user": ["Иванов", "Петров"],
    "levels": ["Error"],
    "limit": 50
  }
}

// Фильтр по типу приложения (только фоновые задания)
{
  "name": "get_event_log",
  "arguments": {
    "application": ["BackgroundJob"],
    "levels": ["Error", "Warning"],
    "limit": 100
  }
}

// Поиск по тексту комментария
{
  "name": "get_event_log",
  "arguments": {
    "comment_contains": "недостаточно товара",
    "levels": ["Error"],
    "limit": 50
  }
}

// Фильтр по статусу транзакции (откаченные транзакции)
{
  "name": "get_event_log",
  "arguments": {
    "transaction_status": "RolledBack",
    "limit": 100
  }
}

// Комбинированные фильтры: ошибки из тонкого клиента для конкретного пользователя
{
  "name": "get_event_log",
  "arguments": {
    "user": ["Иванов"],
    "application": ["ThinClient"],
    "levels": ["Error"],
    "start_date": "2024-01-01T00:00:00",
    "limit": 50
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "data": [
    {
      "date": "2024-01-15T10:30:45",
      "level": "Error",
      "event": "_$Data$_.Post",
      "comment": "Ошибка проведения документа: недостаточно товара на складе",
      "user": "Иванов И.И.",
      "metadata": "Документ.РеализацияТоваровУслуг",
      "data_presentation": "Реализация товаров 00001 от 15.01.2024",
      "session": 12345,
      "application": "ThinClient",
      "computer": "WORKSTATION-01",
      "transaction_status": "RolledBack"
    }
  ],
  "count": 1
}
```

**Типы событий:**
| Событие | Описание |
|---------|----------|
| `_$Data$_.New` | Создание объекта |
| `_$Data$_.Update` | Изменение объекта |
| `_$Data$_.Delete` | Удаление объекта |
| `_$Data$_.Post` | Проведение документа |
| `_$Session$_.Start` | Начало сеанса |
| `_$Session$_.Finish` | Завершение сеанса |
| `_$User$_.AuthenticationError` | Ошибка аутентификации |

**Типы приложений:**
| Приложение | Описание |
|------------|----------|
| `ThinClient` | Тонкий клиент 1С |
| `WebClient` | Веб-клиент |
| `ThickClient` | Толстый клиент (управляемое приложение) |
| `BackgroundJob` | Фоновое задание |
| `Designer` | Конфигуратор |
| `COMConnection` | COM-соединение |

**Статусы транзакций:**
| Статус | Описание |
|--------|----------|
| `Committed` | Транзакция зафиксирована |
| `RolledBack` | Транзакция отменена |
| `NotApplicable` | Транзакция не применима |
| `Unfinished` | Транзакция не завершена |

**Курсорная пагинация:**

Инструмент `get_event_log` поддерживает курсорную пагинацию для итерации по большим наборам данных. При использовании фильтров по дате ответ содержит метаданные пагинации:

| Поле | Тип | Описание |
|------|-----|----------|
| `last_date` | string | ISO 8601 дата последней записи (курсор для следующей страницы) |
| `next_same_second_offset` | integer | Накопленное смещение для записей с той же секундой |
| `has_more` | boolean | Есть ли ещё записи |

**Пример пагинации:**

```json
// Страница 1: Начальный запрос
{
  "name": "get_event_log",
  "arguments": {
    "start_date": "2024-01-01T00:00:00",
    "end_date": "2024-01-31T23:59:59",
    "levels": ["Error"],
    "limit": 100
  }
}

// Ответ страницы 1
{
  "success": true,
  "data": [...],
  "count": 100,
  "last_date": "2024-01-15T14:30:45",
  "next_same_second_offset": 3,
  "has_more": true
}

// Страница 2: Используем last_date и next_same_second_offset из предыдущего ответа
{
  "name": "get_event_log",
  "arguments": {
    "start_date": "2024-01-15T14:30:45",
    "end_date": "2024-01-31T23:59:59",
    "levels": ["Error"],
    "limit": 100,
    "same_second_offset": 3
  }
}
```

**Как это работает:**
- `last_date` становится новым `start_date` для следующего запроса
- `next_same_second_offset` становится `same_second_offset` для пропуска уже просмотренных записей
- Продолжайте пока `has_more` не станет `false`

**Примечание:** Смещение накопительное. Если несколько страниц содержат записи в одну секунду, смещение накапливается. При переходе на новую секунду смещение сбрасывается и считает только записи с новой секундой.

#### 5. get_link_of_object

Генерирует навигационную ссылку 1С по описанию объекта. Используй чтобы дать пользователю кликабельную ссылку для открытия объекта в 1С.

**Параметры:**
| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `object_description` | object | Да | Описание объекта из результатов execute_query с полями {_objectRef, УникальныйИдентификатор, ТипОбъекта} |

**Примеры:**

```json
// Сгенерировать ссылку из результата запроса
{
  "name": "get_link_of_object",
  "arguments": {
    "object_description": {
      "_objectRef": true,
      "УникальныйИдентификатор": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
      "ТипОбъекта": "СправочникСсылка.Контрагенты",
      "Представление": "ООО \"Рога и Копыта\""
    }
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "link": "e1cib/data/Справочник.Контрагенты?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
}
```

**Сценарий использования:**
После нахождения объекта через `execute_query`, используй `get_link_of_object` чтобы сгенерировать кликабельную ссылку, которую пользователь может использовать для открытия объекта непосредственно в 1С.

#### 6. find_references_to_object

Находит все ссылки на заданный объект в указанных коллекциях метаданных (документы, справочники, регистры).

Инструмент выполняет двухэтапный поиск:
1. **Поиск кандидатов**: Обход метаданных для поиска полей, которые могут содержать целевой тип объекта
2. **Выполнение запросов**: Выполнение запросов для поиска фактических объектов/записей, ссылающихся на цель

**Параметры:**
| Параметр | Тип | Обязательный | По умолчанию | Описание |
|----------|-----|--------------|--------------|----------|
| `target_object_description` | object | Да | - | Описание целевого объекта из результатов execute_query |
| `search_scope` | array | Да | - | Области поиска: documents, catalogs, information_registers, accumulation_registers, accounting_registers, calculation_registers |
| `meta_filter` | object | Нет | null | Фильтр объектов метаданных по именам или маске |
| `limit_hits` | integer | Нет | 200 | Максимум находок всего (1-10000) |
| `limit_per_meta` | integer | Нет | 20 | Максимум находок на объект метаданных (1-1000) |
| `timeout_budget_sec` | integer | Нет | 30 | Бюджет времени в секундах (5-300) |

**Примеры:**

```json
// Найти все документы, ссылающиеся на контрагента
{
  "name": "find_references_to_object",
  "arguments": {
    "target_object_description": {
      "_objectRef": true,
      "УникальныйИдентификатор": "ba7e5a3d-1234-5678-9abc-def012345678",
      "ТипОбъекта": "СправочникСсылка.Контрагенты",
      "Представление": "ООО Рога и Копыта"
    },
    "search_scope": ["documents"],
    "limit_hits": 50
  }
}

// Найти ссылки в конкретных объектах метаданных
{
  "name": "find_references_to_object",
  "arguments": {
    "target_object_description": {
      "_objectRef": true,
      "УникальныйИдентификатор": "...",
      "ТипОбъекта": "СправочникСсылка.Номенклатура"
    },
    "search_scope": ["documents", "accumulation_registers"],
    "meta_filter": {
      "names": [
        "Документ.РеализацияТоваровУслуг",
        "РегистрНакопления.ТоварыНаСкладах"
      ]
    },
    "limit_hits": 100
  }
}

// Быстрый поиск с таймаутом
{
  "name": "find_references_to_object",
  "arguments": {
    "target_object_description": {...},
    "search_scope": ["documents", "catalogs"],
    "timeout_budget_sec": 10
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "data": {
    "hits": [
      {
        "found_in_meta": "Документ.РеализацияТоваровУслуг",
        "found_in_object": {
          "_objectRef": true,
          "УникальныйИдентификатор": "...",
          "ТипОбъекта": "ДокументСсылка.РеализацияТоваровУслуг",
          "Представление": "Реализация №001 от 01.01.2024"
        },
        "path": "Контрагент",
        "match_kind": "attribute",
        "note": "Реализация №001 от 01.01.2024"
      },
      {
        "found_in_meta": "РегистрНакопления.ТоварыНаСкладах",
        "found_in_object": null,
        "record_key": {
          "Номенклатура": {"_objectRef": true, "...": "..."},
          "Склад": {"_objectRef": true, "...": "..."},
          "Период": "2024-01-15T00:00:00",
          "Регистратор": {"_objectRef": true, "...": "..."}
        },
        "path": "Номенклатура",
        "match_kind": "dimension",
        "note": "Номенклатура=Товар А; Склад=Основной; Период=15.01.2024"
      }
    ],
    "total_hits": 2,
    "candidates_checked": 8,
    "timeout_exceeded": false,
    "skipped_names": []
  }
}
```

**Поля ответа:**
| Поле | Описание |
|------|----------|
| `hits` | Массив найденных ссылок |
| `total_hits` | Количество найденных ссылок |
| `candidates_checked` | Количество проверенных кандидатных полей |
| `timeout_exceeded` | True если бюджет времени исчерпан |
| `skipped_names` | Имена из meta_filter.names, которые были пропущены с причинами |

**Структура элемента hits (Документы/Справочники):**
- `found_in_meta`: Имя объекта метаданных
- `found_in_object`: Описание объекта-владельца
- `path`: Путь к полю (например, "Контрагент" или "Товары.Номенклатура")
- `match_kind`: Тип поля (attribute, tabular_section)
- `note`: Человекочитаемое описание

**Структура элемента hits (Регистры):**
- `found_in_meta`: Имя объекта метаданных
- `found_in_object`: Всегда null
- `record_key`: Контекст записи с измерениями, периодом (для РегистрСведений/РегистрНакопления/РегистрБухгалтерии) и регистратором (для РегистрНакопления/РегистрБухгалтерии/РегистрРасчета)
- `path`: Имя поля, где найдена ссылка
- `match_kind`: Тип поля (dimension, resource, requisite)
- `note`: Человекочитаемое описание записи

**Сценарии использования:**
- Проверка зависимостей перед удалением объекта
- Аудит использования объектов в базе
- Поиск всех документов конкретного контрагента или товара
- Отслеживание потоков данных через регистры

**См. также:** [docs/find_references_to_object_usage.md](docs/find_references_to_object_usage.md) для детальной документации.



#### 7. get_object_by_link

Получает данные объекта 1С по навигационной ссылке.

**Параметры:**
| Параметр | Тип | Обязательный | Описание |
|----------|-----|--------------|----------|
| `link` | string | Да | Навигационная ссылка в формате `e1cib/data/ТипОбъекта.ИмяОбъекта?ref=HexGUID` |

**Примеры:**

```json
{
  "name": "get_object_by_link",
  "arguments": {
    "link": "e1cib/data/Справочник.Номенклатура?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "data": {
    "_objectRef": true,
    "УникальныйИдентификатор": "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5",
    "ТипОбъекта": "СправочникСсылка.Номенклатура",
    "Представление": "Товар 1",
    "Код": "000000001",
    "Наименование": "Товар 1",
    "Цена": 100
  }
}
```

#### 8. get_access_rights

Получает права ролей на объект метаданных и опционально эффективные права конкретного пользователя ИБ.

**Важно:** `effective_rights` — это "права по сумме ролей", НЕ гарантия реального доступа. RLS (Row Level Security) и контекстные ограничения НЕ учитываются. Требует административных прав; не работает в привилегированном режиме.

**Параметры:**
| Параметр | Тип | Обязательный | По умолчанию | Описание |
|----------|-----|--------------|--------------|----------|
| `metadata_object` | string | Да | - | Полное имя объекта метаданных (например, "Справочник.Контрагенты") |
| `user_name` | string | Нет | null | Имя пользователя ИБ или наименование из справочника Пользователи (регистронезависимый поиск) для расчета эффективных прав |
| `rights_filter` | array | Нет | null | Показывать только эти права (пустой = дефолтный список для типа) |
| `roles_filter` | array | Нет | null | Показывать только эти роли (пустой = все роли) |

**Примеры:**

```json
// Получить права для конкретного пользователя
{
  "name": "get_access_rights",
  "arguments": {
    "metadata_object": "Справочник.Номенклатура",
    "user_name": "Иванов"
  }
}

// Проверить конкретные права для всех ролей
{
  "name": "get_access_rights",
  "arguments": {
    "metadata_object": "Документ.РеализацияТоваровУслуг",
    "rights_filter": ["Insert", "Update", "Posting"]
  }
}
```

**Ответ:**
```json
{
  "success": true,
  "data": {
    "metadata_object": "Справочник.Номенклатура",
    "roles": {
      "ПолныеПрава": {
        "Read": true,
        "Insert": true,
        "Update": true,
        "Delete": true
      },
      "Менеджер": {
        "Read": true,
        "Insert": true,
        "Update": true,
        "Delete": false
      }
    },
    "effective_rights": {
      "user": "Иванов",
      "rights": {
        "Read": true,
        "Insert": true,
        "Update": true,
        "Delete": false
      }
    }
  }
}
```

### Автоматическая конвертация ссылочных типов

Инструмент `execute_query` автоматически конвертирует ссылочные типы 1С (Справочники, Документы, Перечисления и т.д.) в описания объектов и обратно. Это позволяет AI выполнять итеративный анализ: результаты одного запроса можно использовать как параметры следующего.

**Формат описания объекта:**

Когда запрос возвращает ссылочные поля, они автоматически конвертируются в описания объектов:

```json
{
  "_objectRef": true,
  "УникальныйИдентификатор": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "ТипОбъекта": "СправочникСсылка.Контрагенты",
  "Представление": "ООО \"Рога и Копыта\""
}
```

**Использование описаний объектов как параметров:**

Описания объектов можно передавать обратно как параметры запроса, и они будут автоматически конвертированы в ссылки:

```json
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ * ИЗ Документ.РеализацияТоваровУслуг ГДЕ Контрагент = &Контрагент",
    "params": {
      "Контрагент": {
        "_objectRef": true,
        "УникальныйИдентификатор": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "ТипОбъекта": "СправочникСсылка.Контрагенты",
        "Представление": "ООО \"Рога и Копыта\""
      }
    }
  }
}
```

**Пример итеративных запросов:**

```javascript
// Шаг 1: Найти контрагента по наименованию
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ Ссылка ИЗ Справочник.Контрагенты ГДЕ Наименование ПОДОБНО &Наименование",
    "params": { "Наименование": "%Рога%" },
    "limit": 1
  }
}
// Возвращает: [{ "Ссылка": { "_objectRef": true, "УникальныйИдентификатор": "...", ... } }]

// Шаг 2: Использовать ссылку на контрагента для поиска его заказов
{
  "name": "execute_query",
  "arguments": {
    "query": "ВЫБРАТЬ * ИЗ Документ.РеализацияТоваровУслуг ГДЕ Контрагент = &Контрагент",
    "params": {
      "Контрагент": {
        "_objectRef": true,
        "УникальныйИдентификатор": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        "ТипОбъекта": "СправочникСсылка.Контрагенты",
        "Представление": "ООО \"Рога и Копыта\""
      }
    }
  }
}
```

**Преимущества:**
- AI может "ходить" по связям объектов без знания внутренней структуры базы данных
- Не нужно вручную конструировать строки ссылок или GUID
- Типобезопасность: система проверяет соответствие типа ссылки типу параметра
- Работает со всеми ссылочными типами: Справочники, Документы, Перечисления, Планы видов характеристик, Планы счетов

### REST API (Альтернатива MCP)

Для AI-агентов, которые не поддерживают протокол MCP или предпочитают стандартные HTTP-запросы, прокси предоставляет REST API с той же функциональностью, что и MCP-инструменты.

**Базовый URL:** `http://localhost:6003/api/`

**Все REST-эндпоинты поддерживают изоляцию каналов через параметр запроса `?channel=<id>`.**

#### REST API эндпоинты

| Эндпоинт | Метод | Описание | MCP эквивалент |
|----------|-------|----------|----------------|
| `/api/execute_query` | POST | Выполнить запрос 1С | Инструмент `execute_query` |
| `/api/execute_code` | POST | Выполнить код 1С | Инструмент `execute_code` |
| `/api/get_metadata` | GET/POST | Получить метаданные | Инструмент `get_metadata` |
| `/api/get_event_log` | POST | Получить журнал регистрации | Инструмент `get_event_log` |
| `/api/get_object_by_link` | POST | Получить объект по ссылке | Инструмент `get_object_by_link` |
| `/api/get_link_of_object` | POST | Сгенерировать ссылку на объект | Инструмент `get_link_of_object` |
| `/api/find_references_to_object` | POST | Найти ссылки на объект | Инструмент `find_references_to_object` |
| `/api/get_access_rights` | POST | Получить права доступа | Инструмент `get_access_rights` |

#### Формат ответов REST API

Все ответы REST API следуют единой структуре:

**Успешный ответ:**
```json
{
  "success": true,
  "data": <результат>
}
```

**Ответ с ошибкой:**
```json
{
  "success": false,
  "error": "Описание ошибки на русском / Error description in English"
}
```

#### HTTP коды состояния

| Код | Когда используется |
|-----|-------------------|
| 200 | Запрос обработан (включая ошибки бизнес-логики и таймауты) |
| 400 | Невалидный JSON в теле запроса |
| 415 | Content-Type не `application/json` (для POST запросов) |
| 422 | Валидный JSON, но параметры не прошли валидацию |
| 500 | Необработанное исключение сервера |

**Важно:** Ошибки бизнес-логики (1С не отвечает, объект не найден, ошибка выполнения запроса) возвращают HTTP 200 с `success: false`.

#### Примеры REST API

**Выполнить запрос:**
```bash
curl -X POST http://localhost:6003/api/execute_query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "ВЫБРАТЬ * ИЗ Справочник.Номенклатура ГДЕ Код = &Код",
    "params": {"Код": "001"},
    "limit": 100
  }'
```

**Выполнить запрос со схемой:**
```bash
curl -X POST http://localhost:6003/api/execute_query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "ВЫБРАТЬ Код, Наименование, Цена ИЗ Справочник.Номенклатура",
    "limit": 100,
    "include_schema": true
  }'
```

**Выполнить код:**
```bash
curl -X POST http://localhost:6003/api/execute_code \
  -H "Content-Type: application/json" \
  -d '{
    "code": "Результат = ТекущаяДата();"
  }'
```

**Получить метаданные (GET):**
```bash
curl http://localhost:6003/api/get_metadata?filter=Справочник.Номенклатура
```

**Получить метаданные (POST):**
```bash
curl -X POST http://localhost:6003/api/get_metadata \
  -H "Content-Type: application/json" \
  -d '{
    "filter": "Справочник.Номенклатура",
    "meta_type": "Справочник",
    "limit": 50
  }'
```

**Получить журнал регистрации:**
```bash
curl -X POST http://localhost:6003/api/get_event_log \
  -H "Content-Type: application/json" \
  -d '{
    "start_date": "2024-01-01T00:00:00",
    "end_date": "2024-01-31T23:59:59",
    "levels": ["Error", "Warning"],
    "limit": 100
  }'
```

**Получить объект по ссылке:**
```bash
curl -X POST http://localhost:6003/api/get_object_by_link \
  -H "Content-Type: application/json" \
  -d '{
    "link": "e1cib/data/Справочник.Номенклатура?ref=80c6cc1a7e58902811ebcda8cb07c0f5"
  }'
```

**Сгенерировать ссылку на объект:**
```bash
curl -X POST http://localhost:6003/api/get_link_of_object \
  -H "Content-Type: application/json" \
  -d '{
    "object_description": {
      "_objectRef": true,
      "УникальныйИдентификатор": "80c6cc1a-7e58-9028-11eb-cda8cb07c0f5",
      "ТипОбъекта": "СправочникСсылка.Контрагенты"
    }
  }'
```

**Найти ссылки на объект:**
```bash
curl -X POST http://localhost:6003/api/find_references_to_object \
  -H "Content-Type: application/json" \
  -d '{
    "target_object_description": {
      "_objectRef": true,
      "УникальныйИдентификатор": "ba7e5a3d-1234-5678-9abc-def012345678",
      "ТипОбъекта": "СправочникСсылка.Контрагенты",
      "Представление": "ООО Рога и Копыта"
    },
    "search_scope": ["documents"],
    "limit_hits": 50
  }'
```

**Получить права доступа:**
```bash
curl -X POST http://localhost:6003/api/get_access_rights \
  -H "Content-Type: application/json" \
  -d '{
    "metadata_object": "Справочник.Номенклатура",
    "user_name": "Менеджер",
    "rights_filter": ["Insert", "Update"]
  }'
```

**Использование изоляции каналов:**
```bash
curl -X POST "http://localhost:6003/api/execute_query?channel=dev-environment" \
  -H "Content-Type: application/json" \
  -d '{"query": "ВЫБРАТЬ 1"}'
```

### API-эндпоинты

| Эндпоинт | Метод | Описание | Поддержка каналов |
|----------|-------|----------|-------------------|
| `/mcp` | POST/GET/DELETE | MCP HTTP Streamable и legacy SSE транспорт | ✅ Да (`?channel=<id>`) |
| `/mcp/message` | POST | Endpoint сообщений legacy SSE | ✅ Да (из scope) |
| `/api/execute_query` | POST | REST: Выполнить запрос 1С | ✅ Да (`?channel=<id>`) |
| `/api/execute_code` | POST | REST: Выполнить код 1С | ✅ Да (`?channel=<id>`) |
| `/api/get_metadata` | GET/POST | REST: Получить метаданные | ✅ Да (`?channel=<id>`) |
| `/api/get_event_log` | POST | REST: Получить журнал регистрации | ✅ Да (`?channel=<id>`) |
| `/api/get_object_by_link` | POST | REST: Получить объект по ссылке | ✅ Да (`?channel=<id>`) |
| `/api/get_link_of_object` | POST | REST: Сгенерировать ссылку на объект | ✅ Да (`?channel=<id>`) |
| `/api/find_references_to_object` | POST | REST: Найти ссылки на объект | ✅ Да (`?channel=<id>`) |
| `/api/get_access_rights` | POST | REST: Получить права доступа | ✅ Да (`?channel=<id>`) |
| `/1c/poll` | GET | Long polling для получения команд от прокси | ✅ Да (`?channel=<id>`) |
| `/1c/result` | POST | Отправка результатов выполнения в прокси | ✅ Да (`?channel=<id>`) |
| `/health` | GET | Проверка состояния сервера и статистика | ❌ Нет |

#### Health Check Endpoint

**Эндпоинт:** `GET /health`

**Описание:** Возвращает состояние сервера и статистику для мониторинга.

**Пример ответа:**

```json
{
  "status": "healthy",
  "pending_commands": 5,
  "pending_channels_count": 2,
  "active_channels_count": 3,
  "active_sessions_count": 4,
  "mcp_endpoint": "/mcp"
}
```

**Поля ответа:**

| Поле | Тип | Описание |
|------|-----|----------|
| `status` | string | Статус сервера (всегда "healthy") |
| `pending_commands` | integer | Общее количество команд в очереди (по всем каналам) |
| `pending_channels_count` | integer | Количество каналов с ожидающими командами |
| `active_channels_count` | integer | Количество активных каналов |
| `active_sessions_count` | integer | Количество активных MCP-сессий |
| `mcp_endpoint` | string | Путь к MCP эндпоинту |

**Детальная статистика по каналам:**

Для получения детальной статистики по каждому каналу (только для отладки в доверенном окружении) установите переменную окружения:
```bash
HEALTH_INCLUDE_CHANNEL_DETAILS=true
```

Тогда ответ будет включать дополнительные поля:
```json
{
  "status": "healthy",
  "pending_commands": 5,
  "pending_channels_count": 2,
  "active_channels_count": 3,
  "active_sessions_count": 4,
  "mcp_endpoint": "/mcp",
  "pending_commands_by_channel": {
    "default": 3,
    "dev-environment": 2
  },
  "active_sessions_by_channel": {
    "default": 2,
    "dev-environment": 2
  }
}
```

### Переменные окружения

| Переменная | По умолчанию | Описание |
|------------|--------------|----------|
| `PORT` | `6003` | HTTP-порт прокси-сервера |
| `TIMEOUT` | `180` | Таймаут ожидания ответа от 1С (секунды) |
| `POLL_TIMEOUT` | `0` | Таймаут long polling для `/1c/poll` (0 = не блокировать 1С) |
| `LOG_LEVEL` | `INFO` | Уровень логирования (DEBUG, INFO, WARNING, ERROR) |
| `DEBUG` | `false` | Режим отладки (авто-перезагрузка для разработки) |
| `DANGEROUS_KEYWORDS` | См. ниже | Список запрещённых ключевых слов через запятую |
| `ALLOW_DANGEROUS_WITH_APPROVAL` | `false` | Режим подтверждения опасных операций (пользователь может разрешить/отклонить в 1С) |
| `RESPONSE_FORMAT` | `toon` | Формат ответов инструментов: `toon` (по умолчанию, компактный формат) или `json` (максимальная совместимость) |
| `ENABLE_ENCODING_AUTO_DETECTION` | `true` | Автоопределение кодировки для не-UTF-8 запросов (помогает Windows-клиентам с CP1251/CP866) |

**Настройка RESPONSE_FORMAT:**
- `toon` (по умолчанию): Формат TOON (Token-Oriented Object Notation), экономия 30-60% токенов для LLM-контекстов
- `json`: Стандартный JSON формат, максимальная совместимость

TOON — компактный формат сериализации, оптимизированный для AI/LLM контекстов. Использует табличный синтаксис для массивов и синтаксис на основе отступов для вложенных структур, значительно сокращая количество токенов при сохранении целостности данных.

**Пример TOON-вывода для табличных данных:**
```toon
[3,]{Код,Наименование,Цена}:
  001,Товар 1,100.50
  002,Товар 2,200.00
  003,Товар 3,150.75
```

**Примечание:** Если библиотека `toon-format` не установлена или кодирование не удалось, система автоматически переключается на JSON формат с соответствующим логированием.

**Режим ALLOW_DANGEROUS_WITH_APPROVAL:**
- При `false` (по умолчанию): Опасные операции блокируются прокси-сервером
- При `true`: Опасные операции отправляются в 1С с диалогом подтверждения, позволяя пользователю разрешить или отклонить выполнение

**Запрещённые ключевые слова по умолчанию:**
```
Удалить,Delete,Записать,Write,УстановитьПривилегированныйРежим,SetPrivilegedMode,ПодключитьВнешнююКомпоненту,AttachAddIn,УстановитьВнешнююКомпоненту,InstallAddIn,COMОбъект,COMObject,УстановитьМонопольныйРежим,SetExclusiveMode,УдалитьФайлы,DeleteFiles,КопироватьФайл,CopyFile,ПереместитьФайл,MoveFile,СоздатьКаталог,CreateDirectory
```

**Пример docker-compose.yml с пользовательскими настройками:**
```yaml
version: '3.8'
services:
  onec-mcp-toolkit-proxy:
    build: .
    ports:
      - "6003:6003"
    environment:
      - PORT=6003
      - TIMEOUT=180
      - POLL_TIMEOUT=0
      - LOG_LEVEL=DEBUG
      - DEBUG=false
      - DANGEROUS_KEYWORDS=Удалить,Delete,УдалитьФайлы,DeleteFiles
      - ALLOW_DANGEROUS_WITH_APPROVAL=true  # Включить подтверждение опасных операций
      - RESPONSE_FORMAT=toon  # Формат ответов: toon (по умолчанию) или json
    restart: unless-stopped
```

### Настройка клиента 1С

Подробные инструкции по настройке внешней обработки 1С см. в [1c_client/README.md](1c_client/README.md).

**Быстрая настройка:**
1. Откройте внешнюю обработку `build/MCP_Toolkit_Клиент.epf` в 1С:Предприятие
2. Введите адрес прокси-сервера (например, `http://localhost:6003`)
3. Нажмите "Подключиться"
4. Статус изменится на "Подключено" при успешном соединении

#### Флаги автоматического разрешения опасных операций

При включённом `ALLOW_DANGEROUS_WITH_APPROVAL=true` на прокси-сервере, обработка 1С предоставляет флажки для автоматического разрешения определённых опасных операций без показа диалога подтверждения каждый раз.

**Доступные флаги:**
| Флаг | Описание |
|------|----------|
| Записать (Write) | Автоматически разрешать операции с ключевыми словами "Записать" или "Write" |
| УстановитьПривилегированныйРежим (SetPrivilegedMode) | Автоматически разрешать операции с ключевыми словами "УстановитьПривилегированныйРежим" или "SetPrivilegedMode" |

**Как это работает:**
- Если ВСЕ опасные ключевые слова в команде покрыты включёнными флагами, диалог подтверждения пропускается и код выполняется автоматически
- Если ХОТЯ БЫ ОДНО опасное ключевое слово НЕ покрыто включённым флагом, показывается диалог подтверждения
- Автоматически разрешённые операции логируются: "Операции автоматически разрешены: [ключевые слова]"
- Оба флага **выключены по умолчанию** для безопасности

**Примеры сценариев:**
1. Флаг "Записать" включён, код содержит только "Записать" → Автоматически разрешено, диалог не показывается
2. Флаг "Записать" включён, код содержит "Записать" и "Удалить" → Показывается диалог (Удалить не покрыт)
3. Оба флага выключены, любой опасный код → Диалог показывается всегда

### Обработка ошибок

| Ситуация | Ответ |
|----------|-------|
| 1С не подключена | `{"success": false, "error": "1C client not connected"}` |
| Таймаут ожидания 1С | `{"success": false, "error": "Timeout waiting for 1C response"}` |
| Ошибка выполнения в 1С | `{"success": false, "error": "<сообщение об ошибке от 1С>"}` |
| Опасная операция заблокирована | `{"success": false, "error": "Operation not allowed: <ключевое слово>"}` |
| Ошибка валидации JSON | `{"success": false, "error": "JSON validation error: <детали>"}` |


